;ps-dphil-test.lisp#|This file contains all functions related to testing the algorithms.|#;;;;;;;;;;;;;;;;;;;;Cambouropoulos;;;;;;;;;;;;;;;;;;;;#|The following function runs all versions of Cambouropoulos'salgorithms evaluated on the theme from Bach's Musical Offering.This is used to check that all versions actually run.|#(defun cam-mus-off ()  (let* ((midi-list '(72 75 79 80 71 79 78 77 76 75 74 73 72 71 69 67 72 77 75 74 72))         (alg-list '(cam-03-a cam-03-d cam-01-d cam-03-e cam-03-b cam-03-f                     cam-03-g cam-03-c cam-03-h cam-03-i cam-03-j cam-03-k                     cam-03-l cam-03-m cam-03-n cam-03-o cam-03-p cam-01-e                     cam-03-r cam-03-s cam-03-t cam-03-u                      ;cam-03-v                     )))    (mapcar #'(lambda (alg)                (format t "~%~a~%" alg)                (time (pprint (funcall alg midi-list))))            alg-list)))(defun sort-by-onset (opndv-dataset)  (sort (mapcar #'copy-list opndv-dataset)        #'sort-dps-by-onset))(defun sort-dps-by-onset (opndv-datapoint1 opndv-datapoint2)  (let* ((onset1 (first opndv-datapoint1))         (onset2 (first opndv-datapoint2))         (pitch1 (pn2p (second opndv-datapoint1)))         (pitch2 (pn2p (second opndv-datapoint2)))         (chromatic-pitch1 (first pitch1))         (chromatic-pitch2 (first pitch2))         (morphetic-pitch1 (second pitch1))         (morphetic-pitch2 (second pitch2))         (duration1 (third opndv-datapoint1))         (duration2 (third opndv-datapoint2))         (voice1 (fourth opndv-datapoint1))         (voice2 (fourth opndv-datapoint2)))    (vector-less-than-p (list onset1                               chromatic-pitch1                              duration1                              voice1                              morphetic-pitch1)                        (list onset2                              chromatic-pitch2                              duration2                              voice2                              morphetic-pitch2))))(defun sort-by-voice (opndv-dataset)  (sort (mapcar #'copy-list opndv-dataset)        #'(lambda (opndv-datapoint1 opndv-datapoint2)            (let* ((onset1 (first opndv-datapoint1))                   (onset2 (first opndv-datapoint2))                   (pitch1 (pn2p (second opndv-datapoint1)))                   (pitch2 (pn2p (second opndv-datapoint2)))                   (chromatic-pitch1 (first pitch1))                   (chromatic-pitch2 (first pitch2))                   (morphetic-pitch1 (second pitch1))                   (morphetic-pitch2 (second pitch2))                   (duration1 (third opndv-datapoint1))                   (duration2 (third opndv-datapoint2))                   (voice1 (fourth opndv-datapoint1))                   (voice2 (fourth opndv-datapoint2)))              (vector-less-than-p (list voice1                                        onset1                                         chromatic-pitch1                                        duration1                                        morphetic-pitch1)                                  (list voice2                                        onset2                                        chromatic-pitch2                                        duration2                                        morphetic-pitch2))))))(defun vector-less-than-p (v1 v2)  (cond ((null v2) nil)        ((null v1) t)        ((< (list-length v1)            (list-length v2))         t)        ((> (list-length v1)            (list-length v2))         nil)        ((and (first v1)              (null (first v2)))         nil)        ((and (null (first v1))              (first v2))         t)        ((and (first v1)              (first v2)              (< (first v1)                 (first v2)))         t)        ((and (first v1)              (first v2)              (> (first v1)                 (first v2)))         nil)        (t (vector-less-than-p (cdr v1) (cdr v2)))))(defun opndv2midilist1 (opndv)  (let ((sorted-opndv (sort-by-onset opndv)))    (mapcar #' (lambda (opndv-datapoint)                 (+ 21 (elt (pn2p (elt opndv-datapoint 1)) 0)))            sorted-opndv)))(defun opndv2midilist2 (opndv)  (let ((sorted-opndv (sort-by-voice opndv)))    (mapcar #' (lambda (opndv-datapoint)                 (+ 21 (elt (pn2p (elt opndv-datapoint 1)) 0)))            sorted-opndv)))(defun opndv2midilist (sorted-opndv)  (mapcar #'(lambda (opndv-datapoint)              (+ 21 (elt (pn2p (elt opndv-datapoint 1)) 0)))          sorted-opndv))(defun run-algorithm (algorithm                      opndv-sorter                      opndv-to-input-converter                      output-to-opndv-converter                      input-file-suffix                      output-file-suffix                      &optional                      (input-directory (choose-directory-dialog :button-string "INPUT"))                      (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (format t "~%ALGORITHM: ~aOPNDV SORTER: ~AOPNDV-TO-INPUT CONVERTER: ~AOUTPUT-TO-OPNDV CONVERTER: ~AINPUT FILE SUFFIX: ~AOUTPUT FILE SUFFIX: ~AINPUT DIRECTORY: ~AOUTPUT DIRECTORY: ~A"          algorithm           opndv-sorter          opndv-to-input-converter          output-to-opndv-converter          input-file-suffix          output-file-suffix          input-directory          output-directory          )  (let* ((input-opndv-file-name-list (directory (make-pathname :directory (pathname-directory input-directory)                                                               :name :wild                                                               :type input-file-suffix))))    (time (mapcar #'(lambda (input-opndv-file-name)                      (format t "~%~a..." input-opndv-file-name)                                            (let* ((input-opndv-dataset (with-open-file (input-opndv-file-stream                                                                   input-opndv-file-name                                                                   :direction :input)                                                    (read input-opndv-file-stream)))                             (sorted-input-opndv-dataset (funcall opndv-sorter input-opndv-dataset))                             (algorithm-input (funcall opndv-to-input-converter sorted-input-opndv-dataset))                             (algorithm-output (time (funcall algorithm algorithm-input)))                             (output-opndv-dataset (funcall output-to-opndv-converter                                                            algorithm-input                                                            algorithm-output                                                            sorted-input-opndv-dataset))                             (output-opndv-file-name (make-pathname :directory (pathname-directory output-directory)                                                                    :name (pathname-name input-opndv-file-name)                                                                    :type output-file-suffix)))                        (with-open-file (output-opndv-file-stream                                         output-opndv-file-name                                         :direction :output                                         :if-exists :rename-and-delete)                          (pprint output-opndv-dataset output-opndv-file-stream))))                  input-opndv-file-name-list))))(defun camoutput2opndv (midi-list                        pnc-list                        sorted-input-opndv-dataset)  (let* ((output-pitch-names-p1 (mapcar #'pncmidi2pn pnc-list midi-list))         (output-pitch-names-rd2 (mapcar #'(lambda (pitch-name)                                             (pn-tran pitch-name "rd2"))                                         output-pitch-names-p1))         (output-pitch-names-fd2 (mapcar #'(lambda (pitch-name)                                             (pn-tran pitch-name "fd2"))                                         output-pitch-names-p1))         (input-pitch-names (mapcar #'second sorted-input-opndv-dataset))         (error-number-list (list                              ;number of errors for p1                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-p1))                             ;number of errors for rd2                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-rd2))                             ;number of errors for fd2                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-fd2))                             ))         (pitch-names (elt                        (list output-pitch-names-p1                             output-pitch-names-rd2                             output-pitch-names-fd2)                       (position (apply #'min error-number-list)                                 error-number-list))))    (mapcar #'(lambda (opndv-datapoint pitch-name)                (append (list (first opndv-datapoint))                        (list pitch-name)                        (cddr opndv-datapoint)))            sorted-input-opndv-dataset            pitch-names)))(defun nlist2opndv-2 (input-nlist                      output-nlist                      sorted-input-opndv-dataset)  input-nlist  (let* ((output-pitch-names-p1 (mapcar #'newnote-pitchname output-nlist))         (output-pitch-names-rd2 (mapcar #'(lambda (pitch-name)                                             (pn-tran pitch-name "rd2"))                                         output-pitch-names-p1))         (output-pitch-names-fd2 (mapcar #'(lambda (pitch-name)                                             (pn-tran pitch-name "fd2"))                                         output-pitch-names-p1))         (input-pitch-names (mapcar #'second sorted-input-opndv-dataset))         (error-number-list (list                              ;number of errors for p1                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-p1))                             ;number of errors for rd2                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-rd2))                             ;number of errors for fd2                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-fd2))                             ))         (pitch-names (elt                        (list output-pitch-names-p1                             output-pitch-names-rd2                             output-pitch-names-fd2)                       (position (apply #'min error-number-list)                                 error-number-list))))    (mapcar #'(lambda (opndv-datapoint pitch-name)                (append (list (first opndv-datapoint))                        (list pitch-name)                        (cddr opndv-datapoint)))            sorted-input-opndv-dataset            pitch-names)))#|Let's check to see if there are any instances in the test corpus where two notes with the samechromatic pitch begin simultaneously. If I understand the process of generating OPND-M files,this should never happen.See check-if-overlapped-notes-removed in ps-dphil-musedata.lisp.|#(defun same-cp-same-onset (&optional (opnd-m-file (choose-file-dialog :button-string "OPND-M")))  (let* ((sorted-opnd-m-dataset (sort-by-onset (read-dataset opnd-m-file)))         (chord-list (let* ((cl nil)                            (last-onset -1))                       (dolist (opndv-datapoint sorted-opnd-m-dataset (reverse cl))                         (if (= (first opndv-datapoint)                                last-onset)                           (setf (first cl)                                 (cons opndv-datapoint (first cl)))                           (setf cl (cons (list opndv-datapoint)                                          cl)                                 last-onset (first opndv-datapoint))))))         (chord-pn-list (mapcar #'(lambda (opndv-list)                                    (mapcar #'second opndv-list))                                chord-list))         (chord-p-list (mapcar #'(lambda (pn-list)                                    (mapcar #'pn2p pn-list))                               chord-pn-list))         (chord-cp-list (mapcar #'(lambda (p-list)                                    (mapcar #'first p-list))                                chord-p-list))         (list-of-chords-containing-duplicate-cps (remove-if #'null                                                             (mapcar #'(lambda (opndv-list                                                                                cp-list)                                                                         (if (/= (list-length cp-list)                                                                                 (list-length (remove-duplicates (copy-list cp-list)                                                                                                                 :test #'=)))                                                                           opndv-list                                                                           nil))                                                                     chord-list                                                                     chord-cp-list))))    list-of-chords-containing-duplicate-cps))(defun batch-same-cp-same-onset (&optional (dir (choose-directory-dialog :button-string "DIR")))  (let* ((list-of-files (directory (make-pathname :directory (pathname-directory dir)                                                  :name :wild                                                  :type "opnd-m")))         (list-of-file-names (mapcar #'pathname-name list-of-files))         (list-of-same-cp-same-onset-lists (mapcar #'same-cp-same-onset list-of-files)))    (remove-if #'null               (mapcar #'(lambda (file-name list-of-instances)                           (if list-of-instances                             (list file-name list-of-instances)))                       list-of-file-names                       list-of-same-cp-same-onset-lists))))(defun batch-notes2opndv (notes-file-suffix                          output-file-suffix                          &optional                           (opnd-m-file-suffix "opnd-m")                          (notes-directory (choose-directory-dialog :button-string "NOTES"))                          (opnd-m-directory (choose-directory-dialog :button-string "OPND-M"))                          (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (let* ((list-of-notes-files (directory (make-pathname :directory (pathname-directory notes-directory)                                                        :name :wild                                                        :type notes-file-suffix)))         (list-of-opnd-m-files (directory (make-pathname :directory (pathname-directory opnd-m-directory)                                                         :name :wild                                                         :type opnd-m-file-suffix))))    (mapcar #'(lambda (notes-file                       original-opndv-file)                (notes2opndv output-file-suffix                             notes-file                             original-opndv-file                             output-directory))            list-of-notes-files            list-of-opnd-m-files            )))(defun notes2opndv (output-file-suffix                    &optional                     (notes-file (choose-file-dialog :button-string "NOTES IN"))                    (original-opnd-m-file (choose-file-dialog :button-string "OPND-M IN"))                    (output-directory (choose-directory-dialog :button-string output-file-suffix)))  (format t "~%~a..." (pathname-name notes-file))  (let* ((tpc-string-list (remove-if-not #'(lambda (s)                                             (and (>= (length s) 7)                                                  (string= "TPCNote"                                                           (subseq s 0 7))))                                         (with-open-file (notes-stream                                                          notes-file)                                           (do* ((sl nil)                                                 (line (read-line notes-stream nil nil)                                                       (read-line notes-stream nil nil)))                                                ((null line)                                                 (reverse sl)                                                 )                                             (setf sl                                                   (cons (string-right-trim '(#\Space)                                                                            (if (eq #\Linefeed (char line 0)) (subseq line 1) line))                                                         sl))))))         (tpc-item-list (mapcar #'(lambda (s)                                    (do* ((next-start-pos 0)                                          (tpc-note-list-item nil)                                          (element nil))                                         ((>= next-start-pos (length s))                                          (cdr tpc-note-list-item))                                      (multiple-value-setq (element next-start-pos)                                        (read-from-string s nil nil :start next-start-pos))                                      (setf tpc-note-list-item (append tpc-note-list-item (list element)))))                                tpc-string-list))         (original-opnd-m-dataset (read-dataset original-opnd-m-file))         (sorted-original-opnd-m-dataset (sort (mapcar #'copy-list original-opnd-m-dataset)                                               #'(lambda (opnd1 opnd2)                                                   (vector-less-than-p (list (first (pn2p (second opnd1)))                                                                             (first opnd1))                                                                       (list (first (pn2p (second opnd2)))                                                                             (first opnd2))))))         (initial-original-onset (apply #'min (mapcar #'first sorted-original-opnd-m-dataset)))         (sorted-original-opnd-m-dataset (mapcar #'(lambda (opnd-datapoint)                                                     (cons (- (first opnd-datapoint) initial-original-onset)                                                           (cdr opnd-datapoint)))                                                 sorted-original-opnd-m-dataset))         (test-opnd (mapcar #'tpc-item-to-opnd-datapoint tpc-item-list))         (sorted-test-opnd (sort (mapcar #'copy-list test-opnd)                                 #'(lambda (opnd1 opnd2)                                     (vector-less-than-p (list (first (pn2p (second opnd1)))                                                               (first opnd1))                                                         (list (first (pn2p (second opnd2)))                                                               (first opnd2))))))         (initial-test-onset (if sorted-test-opnd (apply #'min (mapcar #'first sorted-test-opnd))))         (sorted-test-opnd (mapcar #'(lambda (opnd-datapoint)                                       (cons (- (first opnd-datapoint) initial-test-onset)                                             (cdr opnd-datapoint)))                                   sorted-test-opnd))         (original-partition (do* ((p (list (list (copy-list (first sorted-original-opnd-m-dataset)))))                                   (i 1 (1+ i)))                                  ((= i (list-length sorted-original-opnd-m-dataset))                                   p)                               (if (= (first (pn2p (second (elt sorted-original-opnd-m-dataset i))))                                      (first (pn2p (second (elt sorted-original-opnd-m-dataset (1- i))))))                                 (setf (first p)                                       (cons (copy-list (elt sorted-original-opnd-m-dataset i))                                             (first p)))                                 (setf p (cons (list (copy-list (elt sorted-original-opnd-m-dataset i)))                                               p)))))         (test-partition (if sorted-test-opnd                           (do* ((p (list (list (copy-list (first sorted-test-opnd)))))                                 (i 1 (1+ i)))                                ((= i (list-length sorted-test-opnd))                                 p)                             (if (= (first (pn2p (second (elt sorted-test-opnd i))))                                    (first (pn2p (second (elt sorted-test-opnd (1- i))))))                               (setf (first p)                                     (cons (copy-list (elt sorted-test-opnd i))                                           (first p)))                               (setf p (cons (list (copy-list (elt sorted-test-opnd i)))                                             p))))))         (match-partition (mapcar #'(lambda (test-class)                                      (let* ((cp-for-this-test-class (first (pn2p (second (first test-class)))))                                             (original-class (mapcar #'copy-list                                                                     (find cp-for-this-test-class                                                                           original-partition                                                                           :key #'(lambda (oc)                                                                                    (first (pn2p (second (first oc))))))))                                             (list-of-best-orig-dp-indices (do* ((test 0 (1+ test))                                                                                 (lobod nil))                                                                                ((= test (list-length test-class))                                                                                 (reverse lobod))                                                                             (do* ((orig 0 (1+ orig))                                                                                   (best-orig nil)                                                                                   (least-difference nil))                                                                                  ((= orig (list-length original-class))                                                                                   (setf lobod                                                                                         (cons best-orig lobod)))                                                                               (let* ((test-dp (elt test-class test))                                                                                      (orig-dp (elt original-class orig))                                                                                      (difference (list (abs (- (first test-dp)                                                                                                                (first orig-dp)))                                                                                                        (abs (- (third test-dp)                                                                                                                (third orig-dp))))))                                                                                 (if (and (not (member orig lobod))                                                                                          (or (null best-orig)                                                                                              (vector-less-than-p difference                                                                                                                  least-difference)))                                                                                   (setf best-orig orig                                                                                         least-difference difference))))))                                             (list-of-orig-test-dp-pairs (mapcar #'(lambda (best-orig-index test-dp)                                                                                     (list (elt original-class best-orig-index)                                                                                           test-dp))                                                                                 list-of-best-orig-dp-indices                                                                                 test-class))                                             (unmatched-indices (let* ((ol nil))                                                                  (dotimes (i (list-length original-class) ol)                                                                    (unless (member i list-of-best-orig-dp-indices)                                                                      (setf ol (cons i ol))))))                                             (unmatched-pairs (mapcar #'(lambda (unmatched-orig-dp-index)                                                                          (list (elt original-class unmatched-orig-dp-index)                                                                                nil))                                                                      unmatched-indices)))                                        (append list-of-orig-test-dp-pairs                                                unmatched-pairs)))                                  (mapcar #'(lambda (test-class)                                              (copy-list test-class))                                          test-partition)))         (match-partition (if (= (list-length original-partition)                                 (list-length match-partition))                            match-partition                            (let* ((missing-classes (remove-if #'null                                                               (mapcar #'(lambda (orig-class)                                                                           (if (member orig-class                                                                                       test-partition                                                                                       :test #'(lambda (c1 c2)                                                                                                 (= (pn2midi (second (first c1)))                                                                                                    (pn2midi (second (first c2))))))                                                                             nil                                                                             orig-class))                                                                       original-partition)))                                   (extra-match-partition-classes (mapcar #'(lambda (missing-class)                                                                              (mapcar #'(lambda (orig-dp)                                                                                          (list orig-dp nil))                                                                                      missing-class))                                                                          missing-classes)))                              (append match-partition                                      extra-match-partition-classes))))         (list-of-orig-test-dp-pairs (apply #'append match-partition))         (sorted-original-opnd-m-dataset (sort-by-onset sorted-original-opnd-m-dataset))         (list-of-orig-test-dp-pairs (sort (mapcar #'copy-list list-of-orig-test-dp-pairs)                                           #'sort-dps-by-onset                                           :key #'first))         (output-pitch-names-p1 (if tpc-string-list                                  (mapcar #'second (mapcar #'second list-of-orig-test-dp-pairs))                                  (mapcar #'null sorted-original-opnd-m-dataset)))         (output-pitch-names-rd2 (mapcar #'(lambda (pitch-name)                                             (if pitch-name                                                (pn-tran pitch-name "rd2")))                                         output-pitch-names-p1))         (output-pitch-names-fd2 (mapcar #'(lambda (pitch-name)                                             (if pitch-name                                               (pn-tran pitch-name "fd2")))                                         output-pitch-names-p1))         (input-pitch-names (if tpc-string-list                              (mapcar #'second (mapcar #'first list-of-orig-test-dp-pairs))                              (mapcar #'second sorted-original-opnd-m-dataset)))         (error-number-list (list                              ;number of errors for p1                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-p1))                             ;number of errors for rd2                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-rd2))                             ;number of errors for fd2                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-fd2))                             ))         (pitch-names (elt                        (list output-pitch-names-p1                             output-pitch-names-rd2                             output-pitch-names-fd2)                       (position (apply #'min error-number-list)                                 error-number-list)))         (output-opndv-dataset (if tpc-string-list                                 (sort-by-onset (mapcar #'(lambda (orig-test-dp-pair pitch-name)                                                            (append (list (first (first orig-test-dp-pair))                                                                          pitch-name)                                                                    (cddr (first orig-test-dp-pair))))                                                        list-of-orig-test-dp-pairs                                                        pitch-names))                                 (sort-by-onset (mapcar #'(lambda (orig-dp)                                                            (append (list (first orig-dp)                                                                          nil)                                                                    (cddr orig-dp)))                                                        sorted-original-opnd-m-dataset))))         (output-file-name (make-pathname :directory (pathname-directory output-directory)                                          :name (pathname-name notes-file)                                          :type output-file-suffix)))        (with-open-file (output-file-stream                     output-file-name                     :direction :output                     :if-exists :rename-and-delete)      (pprint output-opndv-dataset output-file-stream))    (format t "DONE (~d errors)" (apply #'min error-number-list))))#|(defun notes2opndv (output-file-suffix                    &optional                     (notes-file (choose-file-dialog :button-string "NOTES"))                    (original-opnd-m-file (choose-file-dialog :button-string "OPND-M"))                    (output-directory (choose-directory-dialog :button-string output-file-suffix)))  (format t "~%~a..." (pathname-name notes-file))  (let* ((tpc-string-list (remove-if-not #'(lambda (s)                                             (and (>= (length s) 7)                                                  (string= "TPCNote"                                                           (subseq s 0 7))))                                         (with-open-file (notes-stream                                                          notes-file)                                           (do* ((sl nil)                                                 (line (read-line notes-stream nil nil)                                                       (read-line notes-stream nil nil)))                                                ((null line)                                                 (reverse sl)                                                 )                                             (setf sl                                                   (cons (string-right-trim '(#\Space)                                                                            (if (eq #\Linefeed (char line 0)) (subseq line 1) line))                                                         sl))))))         (tpc-item-list (mapcar #'(lambda (s)                                    (do* ((next-start-pos 0)                                          (tpc-note-list-item nil)                                          (element nil))                                         ((>= next-start-pos (length s))                                          (cdr tpc-note-list-item))                                      (multiple-value-setq (element next-start-pos)                                        (read-from-string s nil nil :start next-start-pos))                                      (setf tpc-note-list-item (append tpc-note-list-item (list element)))))                                tpc-string-list))         (original-opnd-m-dataset (read-dataset original-opnd-m-file))         (sorted-original-opnd-m-dataset (sort (mapcar #'copy-list original-opnd-m-dataset)                                               #'(lambda (opnd1 opnd2)                                                   (vector-less-than-p (list (first opnd1)                                                                             (first (pn2p (second opnd1))))                                                                       (list (first opnd2)                                                                             (first (pn2p (second opnd2))))))))         (initial-original-onset (first (first sorted-original-opnd-m-dataset)))         (sorted-original-opnd-m-dataset (mapcar #'(lambda (opnd-datapoint)                                                     (cons (- (first opnd-datapoint) initial-original-onset)                                                           (cdr opnd-datapoint)))                                                 sorted-original-opnd-m-dataset))         (test-opnd (mapcar #'tpc-item-to-opnd-datapoint tpc-item-list))         (sorted-test-opnd (sort (mapcar #'copy-list test-opnd)                                 #'(lambda (opnd1 opnd2)                                     (vector-less-than-p (list (first opnd1)                                                               (first (pn2p (second opnd1))))                                                         (list (first opnd2)                                                               (first (pn2p (second opnd2))))))))         (initial-test-onset (first (first sorted-test-opnd)))         (sorted-test-opnd (mapcar #'(lambda (opnd-datapoint)                                       (cons (- (first opnd-datapoint) initial-test-onset)                                             (cdr opnd-datapoint)))                                   sorted-test-opnd))         (test-onset-cp-list (mapcar #'(lambda (opnd-datapoint)                                         (list (first opnd-datapoint)                                               (first (pn2p (second opnd-datapoint)))))                                     sorted-test-opnd))         (test-cp-list (mapcar #'second test-onset-cp-list))         (original-onset-cp-list (mapcar #'(lambda (opnd-datapoint)                                             (list (first opnd-datapoint)                                                   (first (pn2p (second opnd-datapoint)))))                                         sorted-original-opnd-m-dataset))         (original-cp-list (mapcar #'second original-onset-cp-list))         (new-test-opnd (cond ((equalp test-onset-cp-list                                       original-onset-cp-list)                               sorted-test-opnd)                                                            ((and (equalp test-cp-list                                            original-cp-list)                                    (every #'(lambda (d)                                               (<= (- tolerance) d tolerance))                                           (mapcar #'-                                                    (mapcar #'first test-onset-cp-list)                                                   (mapcar #'first original-onset-cp-list))))                                                              sorted-test-opnd)                              (t                               (do* ((i 0 (1+ i))                                     (nto nil))                                    ((= i (list-length sorted-original-opnd-m-dataset))                                     nto)                                 (cond ((>= i (list-length sorted-test-opnd))                                        (format t "~%(>= i (list-length sorted-test-opnd))")                                        (do* ((j (1- (list-length sorted-test-opnd)) (1- j))                                              (found nil))                                             ((or found                                                  (< j 0)                                                  (and (elt sorted-test-opnd j)                                                       (< (first (elt sorted-test-opnd j))                                                          (- (first (elt sorted-original-opnd-m-dataset i)) tolerance))))                                              (if found                                                (setf nto (append nto (list (elt sorted-test-opnd found)))                                                      (elt sorted-test-opnd found) nil)                                                (setf nto (append nto (list nil)))))                                          (if (and (elt sorted-test-opnd j)                                                   (<= (- tolerance)                                                       (- (first (elt sorted-original-opnd-m-dataset i))                                                          (first (elt sorted-test-opnd j)))                                                       tolerance)                                                   (= (elt test-cp-list j)                                                      (elt original-cp-list i)))                                            (setf found j))))                                                                              ((and (elt sorted-test-opnd i)                                             (<= (- tolerance)                                                 (- (first (elt sorted-original-opnd-m-dataset i))                                                    (first (elt sorted-test-opnd i)))                                                 tolerance)                                             (= (elt test-cp-list i)                                                (elt original-cp-list i)))                                        (setf nto (append nto (list (elt sorted-test-opnd i)))                                              (elt sorted-test-opnd i) nil))                                                                              ((and (elt sorted-test-opnd i)                                             (> (first (elt sorted-test-opnd i))                                                (+ tolerance (first (elt sorted-original-opnd-m-dataset i)))))                                        (do* ((j (1- i) (1- j))                                              (found nil))                                             ((or found                                                  (< j 0)                                                  (and (elt sorted-test-opnd j)                                                       (< (first (elt sorted-test-opnd j))                                                          (- (first (elt sorted-original-opnd-m-dataset i)) tolerance))))                                              (if found                                                (setf nto (append nto (list (elt sorted-test-opnd found)))                                                      (elt sorted-test-opnd found) nil)                                                (setf nto (append nto (list nil)))))                                          (if (and (elt sorted-test-opnd j)                                                   (<= (- tolerance)                                                       (- (first (elt sorted-original-opnd-m-dataset i))                                                          (first (elt sorted-test-opnd j)))                                                       tolerance)                                                   (= (elt test-cp-list j)                                                      (elt original-cp-list i)))                                            (setf found j))))                                                                              ((and (elt sorted-test-opnd i)                                             (< (first (elt sorted-test-opnd i))                                                (- (first (elt sorted-original-opnd-m-dataset i)) tolerance)))                                        (do* ((j (1+ i) (1+ j))                                              (found nil))                                             ((or found                                                  (= j (list-length sorted-test-opnd))                                                  (and (elt sorted-test-opnd j)                                                       (> (first (elt sorted-test-opnd j))                                                          (+ (first (elt sorted-original-opnd-m-dataset i)) tolerance))))                                              (if found                                                (setf nto (append nto (list (elt sorted-test-opnd found)))                                                      (elt sorted-test-opnd found) nil)                                                (setf nto (append nto (list nil)))))                                          (if (and (elt sorted-test-opnd j)                                                   (<= (- tolerance)                                                       (- (first (elt sorted-original-opnd-m-dataset i))                                                          (first (elt sorted-test-opnd j)))                                                       tolerance)                                                   (= (elt test-cp-list j)                                                      (elt original-cp-list i)))                                            (setf found j))))                                                                              (t                                        (do* ((j i (1- j))                                              (found nil))                                             ((or found                                                  (< j 0)                                                  (and (elt sorted-test-opnd j)                                                       (< (first (elt sorted-test-opnd j))                                                          (- (first (elt sorted-original-opnd-m-dataset i)) tolerance))))                                              (if found                                                (setf nto (append nto (list (elt sorted-test-opnd found)))                                                      (elt sorted-test-opnd found) nil)                                                (do* ((j (1+ i) (1+ j))                                                      (found nil))                                                     ((or found                                                          (= j (list-length sorted-test-opnd))                                                          (and (elt sorted-test-opnd j)                                                               (> (first (elt sorted-test-opnd j))                                                                  (+ (first (elt sorted-original-opnd-m-dataset i)) tolerance))))                                                      (if found                                                        (setf nto (append nto (list (elt sorted-test-opnd found)))                                                              (elt sorted-test-opnd found) nil)                                                        (setf nto (append nto (list nil)))))                                                  (if (and (elt sorted-test-opnd j)                                                           (<= (- tolerance)                                                               (- (first (elt sorted-original-opnd-m-dataset i))                                                                  (first (elt sorted-test-opnd j)))                                                               tolerance)                                                           (= (elt test-cp-list j)                                                              (elt original-cp-list i)))                                                    (setf found j)))))                                          (if (and (elt sorted-test-opnd j)                                                   (<= (- tolerance)                                                       (- (first (elt sorted-original-opnd-m-dataset i))                                                          (first (elt sorted-test-opnd j)))                                                       tolerance)                                                   (= (elt test-cp-list j)                                                      (elt original-cp-list i)))                                            (setf found j)))))))                                                    #|(progn                            (format t "~%WARNING: onset-cp-lists not equalp.")                            (if (equalp test-cp-list original-cp-list)                              sorted-test-opnd                              (progn                                (format t "~%WARNING: cp-lists not equalp.")                                (do* ((nto nil)                                      (i 0 (1+ i)))                                     ((= i (list-length sorted-original-opnd-m-dataset))                                      nto)                                  (if (and (< i (list-length sorted-test-opnd))                                           (equalp (elt original-onset-cp-list i)                                                   (elt test-onset-cp-list i)))                                    (setf nto (append nto (list (elt sorted-test-opnd i)))                                          (elt sorted-test-opnd i) nil)                                    (do* ((j (min i (1- (list-length sorted-test-opnd))) (1- j)))                                         ((or (= j -1)                                              (and (elt sorted-test-opnd j)                                                   (or (< (first (elt sorted-test-opnd j))                                                          (- (first (elt sorted-original-opnd-m-dataset i)) tolerance))                                                       (= (first (pn2p (second (elt sorted-test-opnd j))))                                                          (first (pn2p (second (elt sorted-original-opnd-m-dataset i))))))))                                          (if (and (>= j 0)                                                   (elt sorted-test-opnd j)                                                   (= (first (pn2p (second (elt sorted-test-opnd j))))                                                      (first (pn2p (second (elt sorted-original-opnd-m-dataset i))))))                                            (setf nto (append nto (list (elt sorted-test-opnd j)))                                                  (elt sorted-test-opnd j) nil)                                            (do* ((j (1+ i) (1+ j)))                                                 ((or (>= j (list-length sorted-test-opnd))                                                      (and (elt sorted-test-opnd j)                                                           (or (> (first (elt sorted-test-opnd j))                                                                  (+ (first (elt sorted-original-opnd-m-dataset i)) tolerance))                                                               (= (first (pn2p (second (elt sorted-test-opnd j))))                                                                  (first (pn2p (second (elt sorted-original-opnd-m-dataset i))))))))                                                  (if (and (< j (list-length sorted-test-opnd))                                                           (elt sorted-test-opnd j)                                                           (= (first (pn2p (second (elt sorted-test-opnd j))))                                                              (first (pn2p (second (elt sorted-original-opnd-m-dataset i))))))                                                    (setf nto (append nto (list (elt sorted-test-opnd j)))                                                          (elt sorted-test-opnd j) nil)                                                    (progn (format t "~%WARNING: Unable to find corresponding datapoint in program output.")                                                           (setf nto (append nto (list nil)))))))))))))))|#))         ;(dummy (format t "~%new-test-opnd computed"))         (new-test-cp-list (mapcar #'(lambda (opnd-datapoint)                                       (if opnd-datapoint                                         (first (pn2p (second opnd-datapoint)))))                                   new-test-opnd))         ;(dummy (format t "~%new-test-cp-list computed"))         (output-pitch-names-p1 (if (equalp new-test-cp-list                                            original-cp-list)                                  (mapcar #'second new-test-opnd)                                  (progn (format t "~%WARNING: new-test-cp-list is not equalp to original-cp-list (maybe because of missing notes).")                                         (if (= (list-length new-test-cp-list)                                                (list-length original-cp-list))                                           (mapcar #'second new-test-opnd)                                           (progn "~%ERROR: Length of new-test-cp-list is not equal to length of original-cp-list.")))))         ;(dummy (format t "~%output-pitch-names-p1 computed"))         (output-pitch-names-rd2 (mapcar #'(lambda (pitch-name)                                             (if pitch-name                                                (pn-tran pitch-name "rd2")))                                         output-pitch-names-p1))         ;(dummy (format t "~%output-pitch-names-rd2 computed"))         (output-pitch-names-fd2 (mapcar #'(lambda (pitch-name)                                             (if pitch-name                                               (pn-tran pitch-name "fd2")))                                         output-pitch-names-p1))         ;(dummy (format t "~%output-pitch-names-fd2 computed"))         (input-pitch-names (mapcar #'second sorted-original-opnd-m-dataset))         ;(dummy (format t "~%input-pitch-names computed"))         (error-number-list (list                              ;number of errors for p1                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-p1))                             ;number of errors for rd2                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-rd2))                             ;number of errors for fd2                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-fd2))                             ))         ;(dummy (format t "~%error-number-list computed"))         (pitch-names (elt                        (list output-pitch-names-p1                             output-pitch-names-rd2                             output-pitch-names-fd2)                       (position (apply #'min error-number-list)                                 error-number-list)))         ;(dummy (format t "~%pitch-names computed"))         (output-opndv-dataset (mapcar #'(lambda (original-opnd-m-datapoint pitch-name)                                           (append (list (first original-opnd-m-datapoint)                                                         pitch-name)                                                   (cddr original-opnd-m-datapoint)))                                       sorted-original-opnd-m-dataset                                       pitch-names))         ;(dummy (format t "~%output-opndv-dataset computed"))         (output-file-name (make-pathname :directory (pathname-directory output-directory)                                          :name (pathname-name original-opnd-m-file)                                          :type output-file-suffix)))    ;(format t "~%output-file-name computed")        (with-open-file (output-file-stream                     output-file-name                     :direction :output                     :if-exists :rename-and-delete)      (pprint output-opndv-dataset output-file-stream))    (format t "~%DONE (~d errors)" (apply #'min error-number-list))))|##|(defun notes2opndv (output-file-suffix                    &optional                     (notes-file (choose-file-dialog :button-string "NOTES"))                    (original-opndv-file (choose-file-dialog :button-string "OPND-M"))                    (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (let* ((tpc-string-list (remove-if-not #'(lambda (s)                                             (and (>= (length s) 7)                                                  (string= "TPCNote"                                                           (subseq s 0 7))))                                         (with-open-file (notes-stream                                                          notes-file)                                           (do* ((sl nil)                                                 (line (read-line notes-stream nil nil)                                                       (read-line notes-stream nil nil)))                                                ((null line)                                                 (reverse sl)                                                 )                                             (setf sl                                                   (cons (string-right-trim '(#\Space)                                                                            (if (eq #\Linefeed (char line 0)) (subseq line 1) line))                                                         sl))))))         (tpc-item-list (mapcar #'(lambda (s)                                    (do* ((next-start-pos 0)                                          (tpc-note-list-item nil)                                          (element nil))                                         ((>= next-start-pos (length s))                                          (cdr tpc-note-list-item))                                      (multiple-value-setq (element next-start-pos)                                        (read-from-string s nil nil :start next-start-pos))                                      (setf tpc-note-list-item (append tpc-note-list-item (list element)))))                                tpc-string-list))         (test-opnd (mapcar #'tpc-item-to-opnd-datapoint tpc-item-list))         (test-opndv (mapcar #'(lambda (opnd-datapoint) (append opnd-datapoint (list 1)))                             test-opnd))         (sorted-test-opndv (sort-by-onset test-opndv))         (sorted-test-cps (mapcar #'(lambda (opndv-datapoint)                                      (first (pn2p (second opndv-datapoint))))                                  sorted-test-opndv))         (original-opndv-dataset (read-dataset original-opndv-file))         (sorted-original-opndv (sort-by-onset original-opndv-dataset))         (sorted-original-cps (mapcar #'(lambda (opndv-datapoint)                                          (first (pn2p (second opndv-datapoint))))                                      sorted-original-opndv))         (list-of-cp-diffs (mapcar #'- sorted-test-cps sorted-original-cps))         (sorted-test-onsets (mapcar #'first sorted-test-opndv))         (pip-size (apply #'gcd sorted-test-onsets))         (sorted-original-onsets (mapcar #'first sorted-original-opndv))         (ratios-of-test-onsets-to-original-onsets (mapcar #'(lambda (test-onset                                                                      original-onset)                                                               (unless (or (zerop test-onset)                                                                           (zerop original-onset))                                                                 (* 1.0 (/ test-onset original-onset))))                                                           sorted-test-onsets                                                           sorted-original-onsets))         (mean-onset-ratio (/ (apply #'+ (remove-if #'null ratios-of-test-onsets-to-original-onsets))                              (list-length (remove-if #'null ratios-of-test-onsets-to-original-onsets))))         (quantized-original-onsets (mapcar #'(lambda (original-onset)                                                (* pip-size                                                   (round (/ (* mean-onset-ratio original-onset)                                                             pip-size))))                                            sorted-original-onsets))         (adjusted-sorted-test-opndv (do* ((i 0 (1+ i))                                           (asto nil)                                           (this-cp-diff nil)                                           (temp-test-opndv nil))                                          ((= i (list-length sorted-test-opndv))                                           asto)                                       (if (zerop (setf this-cp-diff (elt list-of-cp-diffs i)))                                         (setf asto (append asto (list (elt sorted-test-opndv i))))                                         (do* ((j (1+ i) (1+ j)))                                              ((or (= j (list-length list-of-cp-diffs))                                                   (> (elt sorted-test-onsets j)                                                      (+ pip-size (elt quantized-original-onsets i)))                                                   (= (elt list-of-cp-diffs j)                                                      (- this-cp-diff)))                                               (if (or (= j (list-length list-of-cp-diffs))                                                       (> (elt sorted-test-onsets j)                                                          (+ pip-size (elt quantized-original-onsets i))))                                                 (progn (format t "~%ERROR: Cannot find corresponding datapoints.")                                                        (abort))                                                 (setf temp-test-opndv                                                       (copy-list (elt sorted-test-opndv j))                                                       asto                                                       (append asto (list temp-test-opndv))                                                       (elt sorted-test-opndv j)                                                       (copy-list (elt sorted-test-opndv i))                                                       (elt list-of-cp-diffs j)                                                       0))                                               )))))         (adjusted-sorted-test-cps (mapcar #'(lambda (opndv-datapoint)                                               (first (pn2p (second opndv-datapoint))))                                           adjusted-sorted-test-opndv))         (dummy (if (not (equalp adjusted-sorted-test-cps                                 sorted-original-cps))                  (progn (format t "~%ERROR: adjusted-sorted-test-cps not equalp to sorted-original-cps")                         (abort))))         (output-pitch-names-p1 (mapcar #'second adjusted-sorted-test-opndv))         (output-pitch-names-rd2 (mapcar #'(lambda (pitch-name)                                             (pn-tran pitch-name "rd2"))                                         output-pitch-names-p1))         (output-pitch-names-fd2 (mapcar #'(lambda (pitch-name)                                             (pn-tran pitch-name "fd2"))                                         output-pitch-names-p1))         (input-pitch-names (mapcar #'second sorted-original-opndv))         (error-number-list (list                              ;number of errors for p1                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-p1))                             ;number of errors for rd2                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-rd2))                             ;number of errors for fd2                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-fd2))                             ))         (pitch-names (elt                        (list output-pitch-names-p1                             output-pitch-names-rd2                             output-pitch-names-fd2)                       (position (apply #'min error-number-list)                                 error-number-list)))         (output-opndv-dataset (mapcar #'(lambda (original-opndv-datapoint pitch-name)                                           (append (list (first original-opndv-datapoint)                                                         pitch-name)                                                   (cddr original-opndv-datapoint)))                                       sorted-original-opndv                                       pitch-names))         (output-file-name (make-pathname :directory (pathname-directory output-directory)                                          :name (pathname-name original-opndv-file)                                          :type output-file-suffix)))    dummy    (with-open-file (output-file-stream                     output-file-name                     :direction :output                     :if-exists :rename-and-delete)      (pprint output-opndv-dataset output-file-stream))))|##|(defun notes2opndv (output-file-suffix                    pip-size                    &optional (notes-file (choose-file-dialog :button-string "NOTES"))                              (original-opndv-file (choose-file-dialog :button-string "OPND-M"))                              (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (let* ((tpc-string-list (remove-if-not #'(lambda (s)                                             (and (>= (length s) 7)                                                  (string= "TPCNote"                                                           (subseq s 0 7))))                                         (with-open-file (notes-stream                                                          notes-file)                                           (do* ((sl nil)                                                 (line (read-line notes-stream nil nil)                                                       (read-line notes-stream nil nil)))                                                ((null line)                                                 (reverse sl)                                                 )                                             (setf sl                                                   (cons (string-right-trim '(#\Space)                                                                            (if (eq #\Linefeed (char line 0)) (subseq line 1) line))                                                         sl))))))         (tpc-item-list (mapcar #'(lambda (s)                                    (do* ((next-start-pos 0)                                          (tpc-note-list-item nil)                                          (element nil))                                         ((>= next-start-pos (length s))                                          (cdr tpc-note-list-item))                                      (multiple-value-setq (element next-start-pos)                                        (read-from-string s nil nil :start next-start-pos))                                      (setf tpc-note-list-item (append tpc-note-list-item (list element)))))                                tpc-string-list))         (test-opnd (mapcar #'tpc-item-to-opnd-datapoint tpc-item-list))         (test-opndv (mapcar #'(lambda (opnd-datapoint) (append opnd-datapoint (list 1)))                        test-opnd))         (sorted-test-opndv (sort-by-onset test-opndv))         (original-opndv-dataset (read-dataset original-opndv-file))         (sorted-original-opndv (sort-by-onset original-opndv-dataset))         (sorted-test-cp-list (mapcar #'(lambda (opndv-datapoint)                                          (first (pn2p (second opndv-datapoint))))                                      sorted-test-opndv))         (sorted-original-cp-list (mapcar #'(lambda (opndv-datapoint)                                              (first (pn2p (second opndv-datapoint))))                                          sorted-original-opndv))         (output-pitch-names-p1 nil)         (original-opndv-for-output nil))    (if (/= (list-length sorted-test-opndv)            (list-length sorted-original-opndv))      (progn (format t "~%ERROR: sorted-test-opndv does not contain same number of datapoints as sorted-original-opndv.")             (abort))      (if (equalp sorted-original-cp-list                  sorted-test-cp-list)        (setf output-pitch-names-p1 (mapcar #'second sorted-test-opndv)              original-opndv-for-output sorted-original-opndv)        (let* ((factor (/ (first (first (last sorted-test-opndv)))                          (first (first (last sorted-original-opndv)))))               (new-test-opndv-dataset (do* ((i 0 (1+ i))                                             (ntod nil)                                             (min-onset nil)                                             (max-onset nil)                                             )                                            ((= i (list-length sorted-test-opndv))                                             ntod)                                         (setf max-onset (+ pip-size                                                            (* factor (first (elt sorted-original-opndv i))))                                               min-onset (- (* factor (first (elt sorted-original-opndv i)))                                                            pip-size))                                         (if (and (= (first (pn2p (second (elt sorted-test-opndv i))))                                                     (first (pn2p (second (elt sorted-original-opndv i)))))                                                  (<= min-onset                                                       (first (elt sorted-test-opndv i))                                                      max-onset))                                           (setf ntod                                                 (append ntod (list (elt sorted-test-opndv i))))                                           ())))))))    ))|##|(defun notes2opndv (output-file-suffix                    &optional (notes-file (choose-file-dialog :button-string "NOTES"))                              (original-opndv-file (choose-file-dialog :button-string "OPND-M"))                              (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (let* ((tpc-string-list (remove-if-not #'(lambda (s)                                             (and (>= (length s) 7)                                                  (string= "TPCNote"                                                           (subseq s 0 7))))                                         (with-open-file (notes-stream                                                          notes-file)                                           (do* ((sl nil)                                                 (line (read-line notes-stream nil nil)                                                       (read-line notes-stream nil nil)))                                                ((null line)                                                 (reverse sl)                                                 )                                             (setf sl                                                   (cons (string-right-trim '(#\Space)                                                                            (if (eq #\Linefeed (char line 0)) (subseq line 1) line))                                                         sl))))))         (tpc-item-list (mapcar #'(lambda (s)                                    (do* ((next-start-pos 0)                                          (tpc-note-list-item nil)                                          (element nil))                                         ((>= next-start-pos (length s))                                          (cdr tpc-note-list-item))                                      (multiple-value-setq (element next-start-pos)                                        (read-from-string s nil nil :start next-start-pos))                                      (setf tpc-note-list-item (append tpc-note-list-item (list element)))))                                tpc-string-list))         (test-opnd (mapcar #'tpc-item-to-opnd-datapoint tpc-item-list))         (test-opndv (mapcar #'(lambda (opnd-datapoint) (append opnd-datapoint (list 1)))                        test-opnd))         (sorted-test-opndv (sort-by-onset test-opndv))         (original-opndv-dataset (read-dataset original-opndv-file))         (sorted-original-opndv (sort-by-onset original-opndv-dataset))         (test-chord-list (let* ((cl nil)                                 (last-onset -1))                            (dolist (opndv-datapoint sorted-test-opndv (reverse cl))                              (if (= (first opndv-datapoint)                                     last-onset)                                (setf (first cl)                                      (cons opndv-datapoint (first cl)))                                (setf cl (cons (list opndv-datapoint)                                               cl)                                      last-onset (first opndv-datapoint))))))         (original-chord-list (let* ((cl nil)                                     (last-onset -1))                                (dolist (opndv-datapoint sorted-original-opndv (reverse cl))                                  (if (= (first opndv-datapoint)                                         last-onset)                                    (setf (first cl)                                          (cons opndv-datapoint (first cl)))                                    (setf cl (cons (list opndv-datapoint)                                                   cl)                                          last-onset (first opndv-datapoint))))))         (test-chord-pn-list (mapcar #'(lambda (opndv-list)                                         (mapcar #'second opndv-list))                                     test-chord-list))         (original-chord-pn-list (mapcar #'(lambda (opndv-list)                                         (mapcar #'second opndv-list))                                     original-chord-list))         (test-chord-cp-list (mapcar #'(lambda (pn-list)                                         (mapcar #'(lambda (pn) (first (pn2p pn))) pn-list))                                      test-chord-pn-list))         (original-chord-cp-list (mapcar #'(lambda (pn-list)                                             (mapcar #'(lambda (pn) (first (pn2p pn))) pn-list))                                         original-chord-pn-list))         (sorted-test-chord-cp-list (mapcar #'(lambda (cplist)                                                (sort cplist #'<))                                            (mapcar #'copy-list test-chord-cp-list)))         (sorted-original-chord-cp-list (mapcar #'(lambda (cplist)                                                    (sort cplist #'<))                                                (mapcar #'copy-list original-chord-cp-list)))         (output-file-name (make-pathname :directory (pathname-directory output-directory)                                          :name (pathname-name original-opndv-file)                                          :type output-file-suffix)))    (if (equalp test-chord-cp-list                original-chord-cp-list)      (let* ((new-test-opndv (apply #'append test-chord-list))             (new-original-opndv (apply #'append original-chord-list))             (output-pitch-names-p1 (mapcar #'second new-test-opndv))             (output-pitch-names-rd2 (mapcar #'(lambda (pitch-name)                                             (pn-tran pitch-name "rd2"))                                         output-pitch-names-p1))             (output-pitch-names-fd2 (mapcar #'(lambda (pitch-name)                                                 (pn-tran pitch-name "fd2"))                                             output-pitch-names-p1))             (input-pitch-names (mapcar #'second new-original-opndv))             (error-number-list (list                                  ;number of errors for p1                                 (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-p1))                                 ;number of errors for rd2                                 (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-rd2))                                 ;number of errors for fd2                                 (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-fd2))                                 ))             (pitch-names (elt                            (list output-pitch-names-p1                                 output-pitch-names-rd2                                 output-pitch-names-fd2)                           (position (apply #'min error-number-list)                                     error-number-list)))             (output-opndv-dataset (mapcar #'(lambda (original-opndv-datapoint pitch-name)                                               (append (list (first original-opndv-datapoint)                                                             pitch-name)                                                       (cddr original-opndv-datapoint)))                                           new-original-opndv                                           pitch-names)))        (with-open-file (output-file-stream                         output-file-name                         :direction :output                         :if-exists :rename-and-delete)          (pprint output-opndv-dataset output-file-stream)))      (let* ((differences (remove-if #'null (mapcar #'(lambda (test-chord-cp original-chord-cp                                                                             test-chord original-chord)                                                        (if (not (equalp test-chord-cp original-chord-cp))                                                          (list test-chord original-chord                                                                test-chord-cp original-chord-cp)))                                                    test-chord-cp-list                                                    original-chord-cp-list                                                    test-chord-list                                                    original-chord-list))))        (format t "~%WARNING: test-chord-cp-list is not equalp to original-chord-cp-list~%NOTES FILE: ~a~%OPND-M FILE: ~a~%Differences: ~a"                 notes-file                 original-opndv-file                differences)        (if (equalp sorted-test-chord-cp-list                    sorted-original-chord-cp-list)          (let* ((new-test-opndv (apply #'append (mapcar #'(lambda (test-chord)                                                             (sort (copy-list test-chord)                                                                   #'vector-less-than-p                                                                   :key #'(lambda (opndv-datapoint)                                                                            (pn2p (second opndv-datapoint)))))                                                         test-chord-list)))                 (new-original-opndv (apply #'append (mapcar #'(lambda (original-chord)                                                                 (sort (copy-list original-chord)                                                                       #'vector-less-than-p                                                                       :key #'(lambda (opndv-datapoint)                                                                                (pn2p (second opndv-datapoint)))))                                                             original-chord-list)))                 (output-pitch-names-p1 (mapcar #'second new-test-opndv))                 (output-pitch-names-rd2 (mapcar #'(lambda (pitch-name)                                                     (pn-tran pitch-name "rd2"))                                                 output-pitch-names-p1))                 (output-pitch-names-fd2 (mapcar #'(lambda (pitch-name)                                                     (pn-tran pitch-name "fd2"))                                                 output-pitch-names-p1))                 (input-pitch-names (mapcar #'second new-original-opndv))                 (error-number-list (list                                      ;number of errors for p1                                     (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-p1))                                     ;number of errors for rd2                                     (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-rd2))                                     ;number of errors for fd2                                     (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-fd2))                                     ))                 (pitch-names (elt                                (list output-pitch-names-p1                                     output-pitch-names-rd2                                     output-pitch-names-fd2)                               (position (apply #'min error-number-list)                                         error-number-list)))                 (output-opndv-dataset (mapcar #'(lambda (original-opndv-datapoint pitch-name)                                                   (append (list (first original-opndv-datapoint)                                                                 pitch-name)                                                           (cddr original-opndv-datapoint)))                                               new-original-opndv                                               pitch-names)))            (with-open-file (output-file-stream                             output-file-name                             :direction :output                             :if-exists :rename-and-delete)              (pprint output-opndv-dataset output-file-stream)))          (let* ((differences (remove-if #'null (mapcar #'(lambda (test-chord-cp original-chord-cp                                                                                 test-chord original-chord)                                                            (if (not (equalp test-chord-cp original-chord-cp))                                                              (list test-chord original-chord                                                                    test-chord-cp original-chord-cp)))                                                        sorted-test-chord-cp-list                                                        sorted-original-chord-cp-list                                                        test-chord-list                                                        original-chord-list))))            (format t "~%ERROR: sorted-test-chord-cp-list is not equalp to sorted-test-chord-cp-list~%FILE: ~a~%OPND-M FILE: ~a~%Differences: ~a"                    notes-file                    original-opndv-file                    differences)            (abort)))))    ))|#(defun tpc-item-to-opnd-datapoint (tpc-note-list-item)  (let* ((midi-note (third tpc-note-list-item))         (tpc (fourth tpc-note-list-item))         (chromatic-pitch (compute-chromatic-pitch midi-note))         (morph (compute-morph tpc))         (inflection (compute-inflection tpc))         (morphetic-pitch (compute-morphetic-pitch chromatic-pitch morph inflection))         (pitch-name (p-pn (list chromatic-pitch                                 morphetic-pitch))))    (list (first tpc-note-list-item)          pitch-name          (- (second tpc-note-list-item)             (first tpc-note-list-item)))))(defun compute-morphetic-pitch (cp m i)  (let* ((undisplaced-chromatic-pitch (- cp i))         (morphetic-octave (floor undisplaced-chromatic-pitch 12))         ;(morphetic-octave (floor cp 12))         ;compare (compute-morphetic-pitch tolerance 0 -1) with morphetic-octave = (floor cp 12) and         ;morphetic-octave = (floor undisplaced-chromatic-pitch 12)         )    (+ (* 7 morphetic-octave)       m)))(defun compute-chromatic-pitch (midi-note-number)  (- midi-note-number 21))(defun midi2chromatic-pitch (midi-note-number)  (compute-chromatic-pitch midi-note-number))(defun compute-morph (tpc)  (mod (+ 1 (* 4 tpc)) 7))(defun tpc2morph (tpc)  (compute-morph tpc))(defun compute-inflection (tpc)  (floor (1- tpc) 7))(defun tpc2inflection (tpc)  (compute-inflection tpc))(defun pitch-name-equal-p (pn1 pn2)  (and pn1 pn2       (equalp (pn2p pn1) (pn2p pn2))))(defun pn= (pn1 pn2)  (pitch-name-equal-p pn1 pn2))(defun print-results (test-corpus-file-suffix                      computed-file-suffix                      &optional                      (file-prefix "")                      (test-corpus-directory (choose-directory-dialog :button-string test-corpus-file-suffix))                      (computed-file-directory (choose-directory-dialog :button-string computed-file-suffix))                      (results-directory (choose-directory-dialog :button-string "RESULTS")))  (with-open-file (output-stream                   (make-pathname :directory (pathname-directory results-directory)                                  :name (concatenate 'string                                                     test-corpus-file-suffix                                                     "-"                                                     computed-file-suffix                                                     (if (string= file-prefix "") "" "-")                                                     file-prefix                                                     )                                  :type "res")                   :direction :output                   :if-exists :rename-and-delete)    (let* ((test-corpus-file-name-list (directory (make-pathname :directory (pathname-directory test-corpus-directory)                                                                 :name (concatenate 'string file-prefix "*")                                                                 :type test-corpus-file-suffix)))           (number-of-files (list-length test-corpus-file-name-list))           (numbers-of-errors-for-each-file (mapcar #'(lambda (test-corpus-file-name)                                                        (format t "~a..." (pathname-name test-corpus-file-name))                                                        (let* ((test-corpus-dataset (with-open-file (test-corpus-file-stream                                                                                                     test-corpus-file-name                                                                                                     :direction :input)                                                                                      (read test-corpus-file-stream)))                                                               (computed-file-name (make-pathname :directory (pathname-directory computed-file-directory)                                                                                                  :name (pathname-name test-corpus-file-name)                                                                                                  :type computed-file-suffix))                                                               (computed-dataset (with-open-file (computed-file-stream                                                                                                  computed-file-name                                                                                                  :direction :input)                                                                                   (read computed-file-stream)))                                                               (sorted-test-corpus-dataset (sort-by-onset test-corpus-dataset))                                                               (sorted-computed-dataset (sort-by-onset computed-dataset))                                                               (test-corpus-pn-list (mapcar #'second sorted-test-corpus-dataset))                                                               (number-of-notes (list-length test-corpus-pn-list))                                                               (computed-pn-list (mapcar #'second sorted-computed-dataset))                                                               (test-corpus-pin-list (mapcar #'(lambda (pn1 pn2)                                                                                                 (pn2pin pn1 pn2))                                                                                             (butlast test-corpus-pn-list)                                                                                             (cdr test-corpus-pn-list)))                                                               (number-of-pins (list-length test-corpus-pin-list))                                                               (computed-pin-list (mapcar #'(lambda (pn1 pn2)                                                                                              (pn2pin pn1 pn2))                                                                                          (butlast computed-pn-list)                                                                                          (cdr computed-pn-list)))                                                               (note-error-list (mapcar #'pitch-name-equal-p                                                                                         test-corpus-pn-list                                                                                        computed-pn-list))                                                               (pin-error-list (mapcar #'pin=                                                                                        test-corpus-pin-list                                                                                       computed-pin-list))                                                               (number-of-note-errors (count nil note-error-list))                                                               (number-of-pin-errors (count nil pin-error-list))                                                               (output-list-of-note-errors (remove-if #'null                                                                                                      (mapcar #'(lambda (same test-corpus-datapoint computed-datapoint)                                                                                                                  (if (not same)                                                                                                                    (list test-corpus-datapoint                                                                                                                          computed-datapoint)))                                                                                                              note-error-list                                                                                                              sorted-test-corpus-dataset                                                                                                              sorted-computed-dataset)))                                                               (output-list-of-pin-errors (remove-if #'null                                                                                                     (mapcar #'(lambda (same                                                                                                                         this-test-corpus-datapoint                                                                                                                        next-test-corpus-datapoint                                                                                                                        this-computed-datapoint                                                                                                                        next-computed-datapoint                                                                                                                        test-corpus-pin                                                                                                                        computed-pin)                                                                                                                 (if (not same)                                                                                                                   (list this-test-corpus-datapoint                                                                                                                         next-test-corpus-datapoint                                                                                                                         test-corpus-pin                                                                                                                         this-computed-datapoint                                                                                                                         next-computed-datapoint                                                                                                                         computed-pin)))                                                                                                             pin-error-list                                                                                                             (butlast sorted-test-corpus-dataset)                                                                                                             (cdr sorted-test-corpus-dataset)                                                                                                             (butlast sorted-computed-dataset)                                                                                                             (cdr sorted-computed-dataset)                                                                                                             test-corpus-pin-list                                                                                                             computed-pin-list)))                                                               (percentage-notes-correct (* 100.0 (- 1 (/ number-of-note-errors number-of-notes))))                                                               (percentage-pins-correct (* 100.0 (- 1 (/ number-of-pin-errors number-of-pins)))))                                                          (format output-stream "TEST CORPUS FILE: ~ACOMPUTED FILE: ~ANUMBER OF NOTES: ~DNUMBER OF PINS: ~DNUMBER OF NOTE ERRORS: ~DNUMBER OF PIN ERRORS: ~D% NOTES SPELT CORRECTLY: ~,2F%% PINS SPELT CORRECTLY: ~,2F%LIST OF NOTE ERRORS:"                                                                  test-corpus-file-name                                                                  computed-file-name                                                                  number-of-notes                                                                  number-of-pins                                                                  number-of-note-errors                                                                  number-of-pin-errors                                                                  percentage-notes-correct                                                                  percentage-pins-correct)                                                          (pprint output-list-of-note-errors output-stream)                                                          (format output-stream "~%~%LIST OF PIN ERRORS:")                                                          (pprint output-list-of-pin-errors output-stream)                                                          (format t "DONE~%")                                                          (list number-of-notes number-of-note-errors number-of-pins number-of-pin-errors)))                                                    test-corpus-file-name-list))           (total-number-of-notes (apply #'+ (mapcar #'first numbers-of-errors-for-each-file)))           (total-number-of-note-errors (apply #'+ (mapcar #'second numbers-of-errors-for-each-file)))           (total-number-of-pins (apply #'+ (mapcar #'third numbers-of-errors-for-each-file)))           (total-number-of-pin-errors (apply #'+ (mapcar #'fourth numbers-of-errors-for-each-file)))           (total-percentage-notes-correct (* 100.0 (- 1 (/ total-number-of-note-errors total-number-of-notes))))           (total-percentage-pins-correct (* 100.0 (- 1 (/ total-number-of-pin-errors total-number-of-pins)))))      (format output-stream "FILE PREFIX: ~ATEST CORPUS FILE SUFFIX: ~ACOMPUTED FILE SUFFIX: ~ATEST CORPUS DIRECTORY: ~ACOMPUTED FILE DIRECTORY: ~ANUMBER OF FILES: ~DTOTAL NUMBER OF NOTES: ~DTOTAL NUMBER OF NOTE ERRORS: ~DTOTAL NUMBER OF PINS: ~DTOTAL NUMBER OF PIN ERRORS: ~DTOTAL % NOTES SPELT CORRECTLY: ~,2F%TOTAL % PINS SPELT CORRECTLY: ~,2F%"              file-prefix              test-corpus-file-suffix              computed-file-suffix              test-corpus-directory              computed-file-directory              number-of-files              total-number-of-notes              total-number-of-note-errors              total-number-of-pins              total-number-of-pin-errors              total-percentage-notes-correct              total-percentage-pins-correct))))(defun pin= (pin1 pin2)  (and pin1 pin2       (equalp (pin2pi pin1) (pin2pi pin2))))#|Create a small test corpus which contains as close as possible to 30000 notes from each composer apart fromMarcello. Make the movements as evenly distributed as possible throughout list of pieces for each composer. |#(defun note-file-pair-list (&optional (file-prefix "")                                      (corpus-directory (choose-directory-dialog :button-string "CORPUS"))                                      )  (let* ((file-name-list (directory (make-pathname :directory (pathname-directory corpus-directory)                                                   :name (concatenate 'string file-prefix "*")                                                   :type "opnd-m")))         (number-of-notes-list (mapcar #'(lambda (file-name)                                           (with-open-file (file-stream                                                            file-name                                                            :direction :input)                                             (list-length (read file-stream))))                                       file-name-list))         (total-number-of-notes (apply #'+ number-of-notes-list))         (note-file-pair-list (mapcar #'list number-of-notes-list file-name-list)))    (values (sort note-file-pair-list #'< :key #'first)            total-number-of-notes)))(defun create-small-test-corpus (&optional (file-prefix "")                                           (number-of-notes-for-each-composer 30000)                                           (corpus-directory (choose-directory-dialog :button-string "CORPUS"))                                           (verbose nil))  (let* ((file-name-list (directory (make-pathname :directory (pathname-directory corpus-directory)                                                   :name (concatenate 'string file-prefix "*")                                                   :type "opnd-m")))         (number-of-notes-list (mapcar #'(lambda (file-name)                                           (with-open-file (file-stream                                                            file-name                                                            :direction :input)                                             (list-length (read file-stream))))                                       file-name-list))         (note-file-pair-list (mapcar #'list number-of-notes-list file-name-list))         (number-of-files (list-length file-name-list))         (number-of-notes (apply #'+ number-of-notes-list))         (number-of-files-needed (ceiling (* number-of-files (/ number-of-notes-for-each-composer number-of-notes))))         (original-gap-between-files (ceiling (/ number-of-files number-of-files-needed)))         (gap-between-files (if (= (floor (/ number-of-files original-gap-between-files))                                   (/ number-of-files original-gap-between-files))                              (1- original-gap-between-files)                              original-gap-between-files))         (gap-between-files (if (= (floor (/ number-of-files gap-between-files))                                   (/ number-of-files gap-between-files))                              (+ 1 original-gap-between-files)                              gap-between-files))         (gap-between-files (if (= (floor (/ number-of-files gap-between-files))                                   (/ number-of-files gap-between-files))                              (progn (format t "ERROR: Cannot find appropriate gap size.")                                     (abort))                              gap-between-files))         (best-set-of-files (let* (bsof                                   best-number-of-notes                                   best-difference)                              (dotimes (first-position gap-between-files (list bsof best-number-of-notes best-difference))                                (let* ((this-file-list (do* ((tfl nil)                                                             (file-position first-position (mod (+ file-position gap-between-files) number-of-files)))                                                            ((= (list-length tfl) number-of-files-needed)                                                             (reverse tfl))                                                         (setf tfl (cons (elt note-file-pair-list file-position)                                                                         tfl))))                                       (this-number-of-notes (apply #'+ (mapcar #'first this-file-list)))                                       (this-difference (abs (- this-number-of-notes number-of-notes-for-each-composer))))                                  (if verbose (format t "~5d~10d~10d~%" first-position this-number-of-notes this-difference))                                  (if (or (not bsof)                                          (< this-difference best-difference))                                    (setf bsof this-file-list                                          best-number-of-notes this-number-of-notes                                          best-difference this-difference)))))))    best-set-of-files))(defun find-best-corpus-size (lower-size-limit upper-size-limit step-size)  (do* ((number-of-notes-for-each-composer lower-size-limit (+ number-of-notes-for-each-composer step-size))        (list-of-prefices '("bach" "beet" "corell" "handel" "haydn" "mozart" "telema" "vivald"))        (corpus-directory (choose-directory-dialog :button-string "Corpus"))        best-number-of-notes-for-each-composer        best-corpus        best-difference)       ((> number-of-notes-for-each-composer upper-size-limit)        (list best-number-of-notes-for-each-composer              best-corpus              best-difference))    (let* ((list-of-corpora-for-this-size (mapcar #'(lambda (prefix)                                                      (create-small-test-corpus prefix number-of-notes-for-each-composer corpus-directory))                                                  list-of-prefices))           (total-difference-for-this-size (apply #'+ (mapcar #'third list-of-corpora-for-this-size))))      (format t "~10d~10d" number-of-notes-for-each-composer total-difference-for-this-size)      (if (or (not best-difference)              (< total-difference-for-this-size best-difference))        (progn (setf best-number-of-notes-for-each-composer number-of-notes-for-each-composer                     best-corpus list-of-corpora-for-this-size                     best-difference total-difference-for-this-size)               (format t " *~%"))        (format t "~%"))      )))(defun find-best-comb (target-number                       &optional (file-prefix "")                       (corpus-directory (choose-directory-dialog :button-string "CORPUS")))  (let* ((nfpl (note-file-pair-list file-prefix corpus-directory))         (number-of-notes-list (mapcar #'first nfpl))         (max-bit-vec-int (1- (expt 2 (list-length nfpl))))         (best-vector nil)         (best-distance-from-target nil)         (distance-from-target nil)         bit-vec)    (dotimes (i max-bit-vec-int)      (setf bit-vec (bit-vector i (list-length nfpl)))      (setf distance-from-target (abs (- target-number                                         (apply #'+                                                (remove-if #'null                                                           (mapcar #'(lambda (zero-or-one number-of-notes)                                                                       (if (= 1 zero-or-one)                                                                         number-of-notes))                                                                   bit-vec                                                                   number-of-notes-list))))))      (if (or (not best-distance-from-target)              (< distance-from-target best-distance-from-target))        (setf best-vector bit-vec              best-distance-from-target distance-from-target)))    (format t "~d" best-distance-from-target)    (remove-if #'null (mapcar #'(lambda (zero-or-one note-file-pair)                                  (if (= 1 zero-or-one)                                    note-file-pair))                              best-vector                              nfpl))))(defun compare-file-sizes (computed-file-suffix                           &optional                           (test-corpus-directory (choose-directory-dialog :button-string "TEST"))                           (computed-directory (choose-directory-dialog :button-string "COMP")))  (let* ((list-of-test-files (directory (make-pathname :directory (pathname-directory test-corpus-directory)                                                       :name :wild                                                       :type "opnd-m")))         (list-of-computed-files (directory (make-pathname :directory (pathname-directory computed-directory)                                                           :name :wild                                                           :type computed-file-suffix))))    (format t "~%Checking number of files...")    (if (/= (list-length list-of-test-files)            (list-length list-of-computed-files))      (progn (format t "~%ERROR: Directories do not contain same number of files:~%TEST CORPUS: ~d~%COMPUTED: ~d~%"                     (list-length list-of-test-files)                     (list-length list-of-computed-files))             (abort))      (format t "~%Number of files in test corpus; ~d~%Number of files in computed directory: ~d"               (list-length list-of-test-files)              (list-length list-of-computed-files)))    (format t "~%DONE~%")    (mapcar #'(lambda (test-file comp-file)                (if (string/= (pathname-name test-file)                              (pathname-name comp-file))                  (progn (format t "~%ERROR: Corresponding files don't match:~%TEST: ~a~%COMP: ~a~%"                                 test-file                                 comp-file)                         (abort)))                (let* ((test-data (with-open-file (file-stream                                                   test-file                                                   :direction :input)                                    (read file-stream)))                       (comp-data (with-open-file (file-stream                                                   comp-file                                                   :direction :input)                                    (read file-stream))))                  (if (/= (list-length test-data)                          (list-length comp-data))                    (progn (format t "~%ERROR: Files do not contain same number of notes:~%TEST: ~a (~d)~%COMP: ~a (~d)~%"                                   test-file                                   (list-length test-data)                                   comp-file                                   (list-length comp-data))                           (abort))                    (format t "~%~6d~6d"                             (list-length test-data)                            (list-length comp-data)))))            list-of-test-files            list-of-computed-files)))(defun opnd-datapoint-equal-p (opnd-datapoint1 opnd-datapoint2 &optional (include-voice t))  (equalp (list (first opnd-datapoint1)                 (pn2p (second opnd-datapoint1))                (if include-voice                   (cddr opnd-datapoint1)                  (butlast (cddr opnd-datapoint1))))          (list (first opnd-datapoint2)                (pn2p (second opnd-datapoint2))                (if include-voice                   (cddr opnd-datapoint2)                  (butlast (cddr opnd-datapoint2))))))(defun compare-opndv-files (&optional (include-voice t)                                      (file1 (choose-file-dialog :button-string "FILE1"))                                      (file2 (choose-file-dialog :button-string "FILE2"))                                      )  (FORMAT T "~%FILE 1: ~A~%FILE 2: ~A~%" FILE1 FILE2)  (remove-if #'null             (mapcar #'(lambda (dp1 dp2)                         (unless (opnd-datapoint-equal-p dp1 dp2 include-voice)                           (list dp1 dp2)))                     (sort-by-onset (read-dataset file1))                     (sort-by-onset (read-dataset file2)))))(defun opndv2error-file (&key (include-voice t)                              (correct-file (choose-file-dialog :button-string "Correct"))                              (incorrect-file (choose-file-dialog :button-string "Incorrect"))                              (output-directory (choose-directory-dialog :button-string "OUTPUT"))                              (output-file-type "error"))  (let* ((correct-dataset (sort-by-onset (read-dataset correct-file)))         (incorrect-dataset (sort-by-onset (read-dataset incorrect-file)))         (error-dataset (mapcar #'(lambda (correct-dp incorrect-dp)                                    (if (opnd-datapoint-equal-p correct-dp incorrect-dp include-voice)                                      correct-dp                                      (append correct-dp (list 'error))))                                correct-dataset                                incorrect-dataset))         (output-file-name (make-pathname :directory (pathname-directory output-directory)                                          :name (pathname-name correct-file)                                          :type output-file-type)))    (with-open-file (output-stream                     output-file-name                     :direction :output                     :if-exists :rename-and-delete)      (pprint error-dataset output-stream))))(defun opnd-file-size (&optional (file (choose-file-dialog :button-string "OPND")))  (list-length (read-dataset file)))#|(setf new-corpus-directory (choose-directory-dialog :button-string "NEW"))(setf old-large-corpus-directory (choose-directory-dialog :button-string "OLD BIG"))(setf old-small-c1d-directory (choose-directory-dialog :button-string "OLD c1d"))|#(defun find-list-of-unchanged-corpus-files (&optional (new-corpus-directory (choose-directory-dialog :button-string "NEW"))                                                      (old-large-corpus-directory (choose-directory-dialog :button-string "OLD BIG"))                                                      (old-small-c1d-directory (choose-directory-dialog :button-string "OLD c1d")))  (let* ((list-of-new-opnd-m-files (directory (make-pathname :directory (pathname-directory new-corpus-directory)                                                             :name :wild                                                             :type "opnd-m")))         (list-of-old-c1d-file-names (directory (make-pathname :directory (pathname-directory old-small-c1d-directory)                                                               :name :wild                                                               :type "c1d")))         (list-of-old-large-corpus-opnd-m-files (directory (make-pathname :directory (pathname-directory old-large-corpus-directory)                                                                          :name :wild                                                                          :type "opnd-m"))))    (sort (remove-if #'null (mapcar #'(lambda (new-opnd-m-file-name)                                        (let* ((old-large-corpus-file (first (member new-opnd-m-file-name                                                                                     list-of-old-large-corpus-opnd-m-files                                                                                     :test #'(lambda (p1 p2)                                                                                               (string= (pathname-name p1)                                                                                                        (pathname-name p2)))                                                                                     )))                                               (old-c1d-file (first (member new-opnd-m-file-name                                                                            list-of-old-c1d-file-names                                                                            :test #'(lambda (p1 p2)                                                                                      (string= (pathname-name p1)                                                                                               (pathname-name p2)))                                                                            ))))                                          (if (and old-large-corpus-file                                                   old-c1d-file                                                   (opnd-files-equal-p new-opnd-m-file-name                                                                       old-large-corpus-file))                                            new-opnd-m-file-name)))                                    list-of-new-opnd-m-files))          #'(lambda (x y)              (string< (pathname-name x) (pathname-name y))))))(defun remove-errors-in-f1-from-f2 (&key (f1 (choose-file-dialog :button-string "f1"))                                         (f2 (choose-file-dialog :button-string "f2"))                                         (output-directory (choose-directory-dialog :button-string "Output"))                                         (output-file-type "errdif"))  (let* ((f1-dataset (sort-by-onset (read-dataset f1)))         (f2-dataset (sort-by-onset (read-dataset f2)))         (output-file-name (make-pathname :directory (pathname-directory output-directory)                                          :name (pathname-name f1)                                          :type output-file-type)))    (with-open-file (output-stream                     output-file-name                     :direction :output                     :if-exists :rename-and-delete)      (pprint (mapcar #'(lambda (dp1 dp2)                          (if (and (member 'error dp1)                                   (member 'error dp2)                                   (opndv-datapoint-equal-p (butlast dp1)                                                            (butlast dp2)))                            (remove 'error dp2)                            dp2))                      f1-dataset                      f2-dataset)              output-stream))))#|(setf list-of-unchanged-files      '(#P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgcant000905m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgcant002003m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgcant004407m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgcant004902m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgcant012201m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgcant013606m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgcant015303m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgcant016503m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgchoral027601m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgchoral030201m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgchoral032701m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgchoral035201m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgchoral037701m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgchoral040201m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgchoral042701m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgkeybdwtc-i085202m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgkeybdwtc-i086501m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgkeybdwtc-ii087801m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgkeybdwtc-ii089002m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachbgorch105102m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:bachrasmusinvent078201m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:beetbhsymno103m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:beetbhsymno104m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0101m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0102m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0103m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0104m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0201m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0202m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0203m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0204m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0302m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0303m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0304m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0401m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0402m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0403m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0404m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0501m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0502m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0504m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0601m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0602m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0603m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0604m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0701m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0702m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0703m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0801m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0802m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0803m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0804m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n0902m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n1001m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n1003m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n1004m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n1101m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n1201m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop1n1204m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0101m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0103m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0104m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0202m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0302m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0303m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0402m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0404m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0501m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0503m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0504m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0602m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0702m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0703m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0801m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0802m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0804m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0901m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n0903m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n1001m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n1003m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n1004m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n1102m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:corellchrytrioop2n1103m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelarnoldsemele31m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchryarioda10m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchryarioda37m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchryarioda81m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchrymessia1-22cm.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchrymessia2-15m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchrymessia3-04m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchryorchop201b01m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchryorchop20503m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchryorchop20904m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchryorchop30504m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchryorchop50303m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchryorchop50604m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchrysusann16m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchrysusann34m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelchrysusann59m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelhicksclori27m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelhicksjudasm19m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelhicksott02m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelhicksott38m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:handelhicksott69m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:haydnbhsyms-00102m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:haydndoverquartop54n203m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:haydndoverquartop55n101m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:haydndoverquartop55n302m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:haydndoverquartop64n102m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:haydndoverquartop64n202m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:haydndoversyms-09902m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:haydndoversyms-10004m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:haydndoversyms-10202m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:haydndoversyms-10302m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:mozartbhconck45903m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:mozartbhconck62202m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:mozartbhduosk42302m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:mozartbhduosk42402m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:mozartbhqrtetsk08003m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:mozartbhqrtetsk15602m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:mozartbhqrtetsk15802m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:mozartbhqrtetsk16002m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:mozartbhsymk50401m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_40102m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_40103m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_40202m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_40203m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_40302m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_40303m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_40402m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_40403m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_40503m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_40603m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_40704m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_40804m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_40904m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_41004m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_41104m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemabrusse1734_41204m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdebgerman04m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdebgerman05m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdebgerman09m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdebgerman13m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdebgerman19m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdebgerman22m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdebgerman26m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdebgerman30m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdebgerman34m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu1012m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu1021m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu1025m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu1051m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu1083m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu1092m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu1103m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu2015m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu2031m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu2062m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu2081m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu3013m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu3034m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu3052m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu3074m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:telemamagdeborpheu3082m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivalddoverop30102m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivalddoverop30401m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivalddoverop8011m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivalddoverop8032m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivalddoverop8041m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivalddoverop8063m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivalddoverop8092m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivalddoverop8113m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivalddoverop8122m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivaldleceneop100204m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivaldleceneop100401m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivaldleceneop100603m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivaldleceneop3032m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivaldleceneop3062m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivaldleceneop3091m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivaldleceneop3121m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivaldleceneop8023m.opnd-m" #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:opnd-m:vivaldleceneop8061m.opnd-m"))(setf list-of-unchanged-file-names (mapcar #'pathname-name list-of-unchanged-files))(setf list-of-directories (directory (make-pathname :directory (pathname-directory (choose-directory-dialog :button-string "PARENT"))                                                    :name "c*"                                                    :type :wild)                                     :files nil                                     :directories t))(mapcar #'(lambda (dir)            (let* ((list-of-files-in-this-dir (directory (make-pathname :directory (pathname-directory dir)                                                                        :name :wild                                                                        :type :wild))))              (mapcar #'(lambda (file)                          (unless (member file                                          list-of-unchanged-files                                          :test #'(lambda (p1 p2)                                                    (string= (pathname-name p1)                                                             (pathname-name p2)))                                          )                            (delete-file file)))                      list-of-files-in-this-dir)))        list-of-directories)Now we have to create an input directory for each of the non-empty directories(setf list-of-corpus-files (directory (make-pathname :directory)))(mapcar #'(lambda (dir)            (let* ((list-of-files-to-move ))))        list-of-directories)LIST OF DELETED FILES((#P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:bachbgcant000201m.c1d"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:bachbgcant000503m.c1d" NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:bachbgcant004104m.c1d" NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:bachbgcant021311m.c1d" NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:bachbgvocal023208m.c1d" NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:beetbhconcpiano01m.c1d"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:beetbhconcviolin02m.c1d"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:beetbhsymno101m.c1d" NIL NIL NIL NIL NIL NIL NIL NIL  NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:corellchrytrioop1n0301m.c1d" NIL NIL NIL NIL  NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:corellchrytrioop1n0503m.c1d" NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:corellchrytrioop1n0901m.c1d" NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:corellchrytrioop1n0904m.c1d" NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:corellchrytrioop1n1102m.c1d"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:corellchrytrioop1n1104m.c1d" NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:corellchrytrioop2n0203m.c1d" NIL NIL NIL NIL NIL NIL  NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:corellchrytrioop2n0603m.c1d" NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:handelarnoldsemele52m.c1d"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:handelarnoldsemele72m.c1d" NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:handelchryarioda56m.c1d" NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:handelhicksclori06m.c1d" NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:telemamagdebgerman01dm.c1d" NIL NIL NIL NIL NIL NIL  NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:telemamagdebgerman39m.c1d" NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:telemamagdeborpheu1042m.c1d" NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c1d:vivalddawsonop30703m.c1d" NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL) NIL (#2P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:.DS_Store"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:bachbgcant000201m.c3a"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:bachbgcant000503m.c3a" NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:bachbgcant004104m.c3a" NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:bachbgcant021311m.c3a" NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:bachbgvocal023208m.c3a" NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:beetbhconcpiano01m.c3a"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:beetbhconcviolin02m.c3a"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:beetbhsymno101m.c3a" NIL NIL NIL NIL NIL NIL NIL NIL  NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:corellchrytrioop1n0301m.c3a" NIL NIL NIL NIL  NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:corellchrytrioop1n0503m.c3a" NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:corellchrytrioop1n0901m.c3a" NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:corellchrytrioop1n0904m.c3a" NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:corellchrytrioop1n1102m.c3a"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:corellchrytrioop1n1104m.c3a" NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:corellchrytrioop2n0203m.c3a" NIL NIL NIL NIL NIL NIL  NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:corellchrytrioop2n0603m.c3a" NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:handelarnoldsemele52m.c3a"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:handelarnoldsemele72m.c3a" NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:handelchryarioda56m.c3a" NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:handelhicksclori06m.c3a" NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:telemamagdebgerman01dm.c3a" NIL NIL NIL NIL NIL NIL  NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:telemamagdebgerman39m.c3a" NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:telemamagdeborpheu1042m.c3a" NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3a:vivalddawsonop30703m.c3a" NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL) (#2P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:.DS_Store"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:bachbgcant000201m.c3b"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:bachbgcant000503m.c3b" NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:bachbgcant004104m.c3b" NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:bachbgcant021311m.c3b" NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:bachbgvocal023208m.c3b" NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:beetbhconcpiano01m.c3b"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:beetbhconcviolin02m.c3b"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:beetbhsymno101m.c3b" NIL NIL NIL NIL NIL NIL NIL NIL  NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:corellchrytrioop1n0301m.c3b" NIL NIL NIL NIL  NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:corellchrytrioop1n0503m.c3b" NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:corellchrytrioop1n0901m.c3b" NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:corellchrytrioop1n0904m.c3b" NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:corellchrytrioop1n1102m.c3b"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:corellchrytrioop1n1104m.c3b" NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:corellchrytrioop2n0203m.c3b" NIL NIL NIL NIL NIL NIL  NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:corellchrytrioop2n0603m.c3b" NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:handelarnoldsemele52m.c3b"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:handelarnoldsemele72m.c3b" NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:handelchryarioda56m.c3b" NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:handelhicksclori06m.c3b" NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:telemamagdebgerman01dm.c3b" NIL NIL NIL NIL NIL NIL  NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:telemamagdebgerman39m.c3b" NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:telemamagdeborpheu1042m.c3b" NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3b:vivalddawsonop30703m.c3b" NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL) NIL (#2P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:.DS_Store"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:bachbgcant000201m.c3d"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:bachbgcant000503m.c3d" NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:bachbgcant004104m.c3d" NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:bachbgcant021311m.c3d" NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:bachbgvocal023208m.c3d" NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:beetbhconcpiano01m.c3d"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:beetbhconcviolin02m.c3d"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:beetbhsymno101m.c3d" NIL NIL NIL NIL NIL NIL NIL NIL  NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:corellchrytrioop1n0301m.c3d" NIL NIL NIL NIL  NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:corellchrytrioop1n0503m.c3d" NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:corellchrytrioop1n0901m.c3d" NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:corellchrytrioop1n0904m.c3d" NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:corellchrytrioop1n1102m.c3d"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:corellchrytrioop1n1104m.c3d" NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:corellchrytrioop2n0203m.c3d" NIL NIL NIL NIL NIL NIL  NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:corellchrytrioop2n0603m.c3d" NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:handelarnoldsemele52m.c3d"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:handelarnoldsemele72m.c3d" NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:handelchryarioda56m.c3d" NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:handelhicksclori06m.c3d" NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:telemamagdebgerman01dm.c3d" NIL NIL NIL NIL NIL NIL  NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:telemamagdebgerman39m.c3d" NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:telemamagdeborpheu1042m.c3d" NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3d:vivalddawsonop30703m.c3d" NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL) (#2P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:.DS_Store"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:bachbgcant000201m.c3e"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:bachbgcant000503m.c3e" NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:bachbgcant004104m.c3e" NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:bachbgcant021311m.c3e" NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:bachbgvocal023208m.c3e" NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:beetbhconcpiano01m.c3e"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:beetbhconcviolin02m.c3e"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:beetbhsymno101m.c3e" NIL NIL NIL NIL NIL NIL NIL NIL  NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:corellchrytrioop1n0301m.c3e" NIL NIL NIL NIL  NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:corellchrytrioop1n0503m.c3e" NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:corellchrytrioop1n0901m.c3e" NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:corellchrytrioop1n0904m.c3e" NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:corellchrytrioop1n1102m.c3e"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:corellchrytrioop1n1104m.c3e" NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:corellchrytrioop2n0203m.c3e" NIL NIL NIL NIL NIL NIL  NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:corellchrytrioop2n0603m.c3e" NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:handelarnoldsemele52m.c3e"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:handelarnoldsemele72m.c3e" NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:handelchryarioda56m.c3e" NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:handelhicksclori06m.c3e" NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:telemamagdebgerman01dm.c3e" NIL NIL NIL NIL NIL NIL  NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:telemamagdebgerman39m.c3e" NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:telemamagdeborpheu1042m.c3e" NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3e:vivalddawsonop30703m.c3e" NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL) (#P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:bachbgcant000201m.c3f"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:bachbgcant000503m.c3f" NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:bachbgcant004104m.c3f" NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:bachbgcant021311m.c3f" NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:bachbgvocal023208m.c3f" NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:beetbhconcpiano01m.c3f"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:beetbhconcviolin02m.c3f"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:beetbhsymno101m.c3f" NIL NIL NIL NIL NIL NIL NIL NIL  NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:corellchrytrioop1n0301m.c3f" NIL NIL NIL NIL  NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:corellchrytrioop1n0503m.c3f" NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:corellchrytrioop1n0901m.c3f" NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:corellchrytrioop1n0904m.c3f" NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:corellchrytrioop1n1102m.c3f"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:corellchrytrioop1n1104m.c3f" NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:corellchrytrioop2n0203m.c3f" NIL NIL NIL NIL NIL NIL  NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:corellchrytrioop2n0603m.c3f" NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:handelarnoldsemele52m.c3f"  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:handelarnoldsemele72m.c3f" NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:handelchryarioda56m.c3f" NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:handelhicksclori06m.c3f" NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:telemamagdebgerman01dm.c3f" NIL NIL NIL NIL NIL NIL  NIL NIL NIL #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:telemamagdebgerman39m.c3f" NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:telemamagdeborpheu1042m.c3f" NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL  #P"hd:Users:dave:Documents:Musedata:20040829-small-corpus:c3f:vivalddawsonop30703m.c3f" NIL NIL NIL NIL NIL NIL  NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL) NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)|#(defun create-input-directory (&optional (output-directory (choose-directory-dialog :button-string "OUTPUT"))                                         (corpus-directory (choose-directory-dialog :button-string "CORPUS")))  (let* ((list-of-corpus-files (directory (make-pathname :directory (pathname-directory corpus-directory)                                                         :name :wild                                                         :type "opnd-m")))         (list-of-existing-output-files (directory (make-pathname :directory (pathname-directory output-directory)                                                         :name :wild                                                         :type :wild)))         (list-of-files-to-copy (remove-if #'null                                           (mapcar #'(lambda (corpus-file)                                                       (unless (member corpus-file                                                                       list-of-existing-output-files                                                                       :test #'(lambda (p1 p2)                                                                                 (string= (pathname-name p1)                                                                                          (pathname-name p2))))                                                         corpus-file))                                                   list-of-corpus-files)))         (new-input-directory (append (butlast (pathname-directory output-directory))                                      (list (concatenate 'string (first (last (pathname-directory output-directory)))                                                        "-input")))))    (mapcar #'(lambda (file)                (copy-file file                           (make-pathname :directory new-input-directory                                          :name (pathname-name file)                                          :type (pathname-type file))))            list-of-files-to-copy)))#|(defun melisma-to-event-list (&optional (melisma-file (choose-file-dialog :button-string "MELISMA")))  (let* ((line-as-list-list (with-open-file (melisma-file-stream                                             melisma-file                                             :direction :input)                              (do* ((line-as-list nil)                                    (event-list nil)                                    (line (read-line melisma-file-stream nil nil)                                          (read-line melisma-file-stream nil nil)))                                   ((null line)                                    event-list)                                (setf line-as-list                                      (if (or (char= (char line 0) #\%)                                              (string= line ""))                                        nil                                        (convert-line-to-list line)))                                (if line-as-list                                  (setf event-list                                        (append event-list (list line-as-list))))))))    (mapcar #'(lambda (line-as-list)                (convert-line-as-list-to-event line-as-list))            line-as-list-list)))|##|(defun convert-line-as-list-to-event (line-as-list)  (case (first line-as-list)    (note (make-event :event-type (first line-as-list)                      :onset (second line-as-list)                      :offset (third line-as-list)                      :pitch (fourth line-as-list)))    (beat (make-event :event-type (first line-as-list)                      :onset (second line-as-list)                      :beat-level (third line-as-list)))    (prechord (make-event :event-type (first line-as-list)                          :onset (second line-as-list)))))|#(defun convert-line-to-list (line)  (do* ((l nil)        (item 'a)        (i 0))       ((and (= i (length line))             (null item))        (reverse l))    (multiple-value-setq (item i)      (read-from-string line nil nil :start i))    (if item      (setf l (cons item l)))))#|(defun temp-meter-mel-file (&optional (param-option nil)                                      (melisma-file (choose-file-dialog :button-string "MELISMA"))                                      (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (let* ((output-event-list (temp-meter (melisma-to-event-list melisma-file)                                        param-option))         (output-file-name (make-pathname :directory (pathname-directory output-directory)                                          :name (pathname-name melisma-file)                                          :type (concatenate 'string "tm"                                                        (case param-option                                                          (parameters-file "1")                                                           (params-prechord-file "2")                                                          (t "0"))))))    (with-open-file (output-file-stream                     output-file-name                     :direction :output                     :if-exists :rename-and-delete)      (mapcar #'(lambda (event)                (print-event event output-file-stream))              output-event-list))))|##|(defun batch-temp-meter-mel-file (&optional (param-option nil)                                            (input-type :wild)                                            (input-directory (choose-directory-dialog :button-string "INPUT"))                                            (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (let* ((melisma-file-list (directory (make-pathname :directory (pathname-directory input-directory)                                                      :name :wild                                                      :type input-type))))    (dolist (melisma-file melisma-file-list)      (format t "~%~a..." melisma-file)      (temp-meter-mel-file param-option melisma-file output-directory)      (format t "DONE"))))|##|(defun print-event (event output-stream)  (case (event-event-type event)    (note (format output-stream "Note ~6d ~6d ~3d~%"                  (event-onset event)                  (event-offset event)                  (event-pitch event)))    (beat (format output-stream "Beat ~6d ~2d~%"                  (event-onset event)                  (event-beat-level event)))))|#(defun print-debug-message (s)  (format t (concatenate 'string "~%" s "~%")))(defun batch-opndv2notes (time-factor                         &optional                         (input-directory (choose-directory-dialog :button-string "INPUT"))                         (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (let* ((list-of-opndv-files (directory (make-pathname :directory (pathname-directory input-directory)                                                        :name :wild                                                        :type "opnd-m"))))    (dolist (opndv-file list-of-opndv-files)      (format t "~%~a..." opndv-file)      (opndv2notes time-factor                   opndv-file                   output-directory)      (format t "DONE"))))(defun opndv2notes (time-factor                    &optional (opndv-file (choose-file-dialog :button-string "OPNDV"))                    (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (let* ((opndv-dataset (read-dataset opndv-file))         (sorted-opndv-dataset (sort-by-onset opndv-dataset))         (list-of-lines-as-lists (mapcar #'(lambda (opndv-datapoint)                                             (opndv-datapoint-to-line-as-list opndv-datapoint                                                                              time-factor))                                         sorted-opndv-dataset))         (output-file-name (make-pathname :directory (pathname-directory output-directory)                                          :name (pathname-name opndv-file)                                          :type (concatenate 'string "n"                                                             (format nil "~d" time-factor)))))    (with-open-file (output-file-stream                     output-file-name                     :direction :output                     :if-exists :rename-and-delete)      (dolist (line-as-list list-of-lines-as-lists)        (format output-file-stream "Note ~6d ~6d ~3d~%"                (second line-as-list)                (third line-as-list)                (fourth line-as-list))))))(defun opndv-datapoint-to-line-as-list (opndv-datapoint                                        time-factor)  (list 'note        (* (first opndv-datapoint) time-factor)        (+ (* (first opndv-datapoint) time-factor)           (* (third opndv-datapoint) time-factor))        (+ 21 (first (pn2p (second opndv-datapoint))))))(defun read-file-as-string (&optional (text-file (choose-file-dialog :button-string "TEXT")))  (let ((text ""))    (with-open-file (text-stream                     text-file                     )      (do* ((c (read-char text-stream nil nil)               (read-char text-stream nil nil)))           ((null c)            text)        (setf text (concatenate 'string text (string c)))))))(defun write-string-to-file (s file-name)  (with-open-file (file-stream                   file-name                   :direction :output)    (format file-stream "~a" s)))(defun string-to-char-list (s)  (let ((l nil))    (dotimes (i (length s) (reverse l))      (setf l (cons (char s i) l)))))(defun mac2unix (&optional (mac-file (choose-file-dialog :button-string "MAC"))                           (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (convert-mac-file-to-unix-file mac-file output-directory))(defun convert-mac-file-to-unix-file (&optional (mac-file (choose-file-dialog :button-string "MAC"))                                                (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (with-open-file (mac-stream                   mac-file                   :direction :input)    (with-open-file (unix-stream                     (make-pathname :directory (pathname-directory output-directory)                                    :name (pathname-name mac-file)                                    :type (pathname-type mac-file))                     :direction :output                     :if-exists :rename-and-delete)      (do* ((l (read-line mac-stream nil nil)               (read-line mac-stream nil nil)))           ((null l))        (write-string (concatenate 'string l (string #\Linefeed))                      unix-stream)))))(defun batch-mac2unix (&optional (mac-file-type :wild)                                 (mac-file-directory (choose-directory-dialog :button-string "MAC"))                                 (unix-file-directory (choose-directory-dialog :button-string "UNIX")))  (batch-convert-mac-file-to-unix-file mac-file-type                                       mac-file-directory                                       unix-file-directory))(defun batch-convert-mac-file-to-unix-file (&optional (mac-file-type :wild)                                                      (mac-file-directory (choose-directory-dialog :button-string "MAC"))                                                      (unix-file-directory (choose-directory-dialog :button-string "UNIX")))  (let* ((mac-file-list (directory (make-pathname :directory (pathname-directory mac-file-directory)                                                  :name :wild                                                  :type mac-file-type))))    (dolist (mac-file mac-file-list)      (format t "~%~a..." mac-file)      (convert-mac-file-to-unix-file mac-file unix-file-directory)      (format t "DONE"))))#|COMPUTING TIMING INFORMATION FOR CAMBOUROPOULOS EXPERIMENTS===========================================================Each file has the file type "lisp", begins with a capital Cand lives in the Results directory.Each file contains a single list(t1 t2 t3 ...)where each tn is a list whose format is either(algorithm file-name running-time cme-time gc-time)or(algorithm file-name running-time cme-time)All times are in integer numbers of milliseconds.The net running time for each input-file and each algorithm is equal torunning-time - cme-time - gc-timeSince gc-time may not exist, this can be calculated using the following form(- (third tn)   (fourth tn)   (if (= (list-length tn) 5)     (fifth tn)     0))We need to construct a matrix in which each column corresponds to an algorithm andeach row corresponds to an input-file. The entry in each cell gives the net running timein milliseconds of the input-file for that row for the algorithm in that column.|#(defun construct-net-times-matrix (&optional (input-file-type "lisp")                                             (list-of-input-file-prefices (list "C"))                                             (input-directory (choose-directory-dialog :button-string "INPUT"))                                             )  (let* ((list-of-input-files (apply #'append (mapcar #'(lambda (input-file-prefix)                                                          (directory (make-pathname :directory (pathname-directory input-directory)                                                                                    :name (concatenate 'string input-file-prefix "*")                                                                                    :type input-file-type)))                                                      list-of-input-file-prefices)))         (list-of-input-datasets (mapcar #'read-dataset list-of-input-files))         (unsorted-list-of-time-datapoints (apply #'append list-of-input-datasets))         (sorted-list-of-time-datapoints (sort unsorted-list-of-time-datapoints                                               #'(lambda (t1 t2)                                                   (or (string< (string (first t1))                                                                (string (first t2)))                                                       (and (string= (string (first t1))                                                                     (string (first t2)))                                                            (string< (string (second t1))                                                                     (string (second t2))))))))         (list-of-corpus-file-names (directory (make-pathname :directory (pathname-directory                                                                          (choose-directory-dialog :button-string "CORPUS"))                                                             :name :wild                                                             :type "opnd-m")))         (sorted-list-of-name-filename-size-triples (sort (mapcar #'(lambda (filename)                                                                      (list (string-upcase (pathname-name filename))                                                                            filename                                                                            (list-length (read-dataset filename))))                                                                  list-of-corpus-file-names)                                                          #'(lambda (trip1 trip2)                                                              (string< (first trip1)                                                                       (first trip2)))))         (sorted-list-of-algorithms (sort (mapcar #'string-upcase (remove-duplicates                                                                    (mapcar #'first sorted-list-of-time-datapoints)))                                          #'string<))         (sorted-list-of-corpus-files (mapcar #'first sorted-list-of-name-filename-size-triples))         (net-time-array (make-array (list (list-length sorted-list-of-name-filename-size-triples)                                           (list-length sorted-list-of-algorithms))                                     :initial-element nil)))    (dolist (time-datapoint sorted-list-of-time-datapoints net-time-array)      (setf (aref net-time-array                   (position (string (second time-datapoint))                            sorted-list-of-corpus-files                            :test #'string=)                  (position (string (first time-datapoint))                            sorted-list-of-algorithms                            :test #'string=))            (- (third time-datapoint)               (fourth time-datapoint)               (if (= (list-length time-datapoint) 5)                 (fifth time-datapoint)                 0))))    (format t "~%")    (dolist (algorithm sorted-list-of-algorithms)      (format t (concatenate 'string                              (string #\Tab)                             "~a")              algorithm))    (dotimes (corpus-file-index              (list-length sorted-list-of-corpus-files))      (format t (concatenate 'string                             "~%~a"                              (string #\Tab))              (elt sorted-list-of-corpus-files corpus-file-index))      (dotimes (algorithm-index                (list-length sorted-list-of-algorithms))        (format t (concatenate 'string                                "~d"                               (string #\Tab))                (aref net-time-array corpus-file-index algorithm-index))))        ;Now output average speeds in notes per second for each algorithm    (format t (concatenate 'string                           "~%Algorithm" (string #\Tab)                           "Time" (string #\Tab)                           "No. notes" (string #\Tab)                           "No. files" (string #\Tab)                           "Speed (notes/sec)"))    (dolist (algorithm sorted-list-of-algorithms)      (let* ((total-time 0)             (total-number-of-notes 0)             (total-number-of-files 0))        (dolist (triple sorted-list-of-name-filename-size-triples)          (let* ((time nil))            (if (setf time (aref net-time-array                                  (position (first triple)                                           sorted-list-of-corpus-files)                                 (position algorithm sorted-list-of-algorithms)))              (setf total-time (+ total-time time)                    total-number-of-notes (+ total-number-of-notes                                             (third triple))                    total-number-of-files (1+ total-number-of-files)))))        (format t (concatenate 'string                               "~%~a" (string #\Tab)                               "~d" (string #\Tab)                               "~d" (string #\Tab)                               "~d" (string #\Tab)                               "~3,3f")                algorithm                total-time                total-number-of-notes                total-number-of-files                (* 1000 (/ total-number-of-notes total-time)))))    ))(defun print-file-name-and-size (&optional (file-prefix "")                                           (corpus-directory (choose-directory-dialog :button-string "CORPUS")))  (let* ((size-name-pair-list (note-file-pair-list file-prefix corpus-directory))         (sorted-name-size-pair-list (sort (mapcar #'(lambda (size-name-pair)                                                       (list (pathname-name (second size-name-pair))                                                             (first size-name-pair)))                                                   size-name-pair-list)                                           #'string<                                           :key #'first)))    (dolist (name-size-pair sorted-name-size-pair-list)      (format t (concatenate 'string                             "~%~a" (string #\Tab) "~d")              (first name-size-pair)              (second name-size-pair)))))#|Following function reads a set of .res files and outputs two tables, one showing numbers of note errors,the other showing numbers of pin errors.|#(defstruct res  composer  algorithm  number-of-files  total-number-of-notes  total-number-of-note-errors  total-number-of-pins  total-number-of-pin-errors  total-percent-correct-notes  total-percent-correct-pins  ner  )(defun print-note-and-pin-errors (&optional (res-file-prefix "")                                            (res-file-directory (choose-directory-dialog :button-string "RES")))  (let* ((list-of-res-files (directory (make-pathname :directory (pathname-directory res-file-directory)                                                      :name (concatenate 'string res-file-prefix "*")                                                      :type "res")))         (list-of-res-records (let* ((lod nil))                                (dolist (res-file list-of-res-files lod)                                                                    (with-open-file (res-stream                                                   res-file                                                   :direction :input)                                    (do* ((l (read-line res-stream nil nil)                                             (read-line res-stream nil nil))                                          (composer nil)                                          (algorithm nil)                                          (total-number-of-notes nil)                                          (total-number-of-pins nil)                                          (total-number-of-note-errors nil)                                          (total-number-of-pin-errors nil)                                          (total-percent-correct-notes nil)                                          (total-percent-correct-pins nil)                                          (number-of-files nil))                                         ((null l)                                          (setf lod                                                (cons (make-res :composer composer                                                                :algorithm algorithm                                                                :number-of-files number-of-files                                                                :total-number-of-notes total-number-of-notes                                                                :total-number-of-note-errors total-number-of-note-errors                                                                :total-number-of-pins total-number-of-pins                                                                :total-number-of-pin-errors total-number-of-pin-errors                                                                :total-percent-correct-notes total-percent-correct-notes                                                                :total-percent-correct-pins total-percent-correct-pins                                                                )                                                      lod)))                                                                            (cond ((and (>= (length l) (length "FILE PREFIX:"))                                                  (string= "FILE PREFIX:"                                                           l                                                           :start2 0 :end2 (length "FILE PREFIX:")))                                             (setf composer                                                   (read-from-string l nil nil :start (length "FILE PREFIX:"))))                                                                                        ((and (>= (length l) (length "COMPUTED FILE SUFFIX:"))                                                  (string= "COMPUTED FILE SUFFIX:"                                                           l                                                           :start2 0 :end2 (length "COMPUTED FILE SUFFIX:")))                                             (setf algorithm                                                   (read-from-string l nil nil :start (length "COMPUTED FILE SUFFIX:"))))                                                                                        ((and (>= (length l) (length "NUMBER OF FILES:"))                                                  (string= "NUMBER OF FILES:"                                                           l                                                           :start2 0 :end2 (length "NUMBER OF FILES:")))                                             (setf number-of-files                                                   (read-from-string l nil nil :start (length "NUMBER OF FILES:"))))                                                                                        ((and (>= (length l) (length "TOTAL NUMBER OF NOTES:"))                                                  (string= "TOTAL NUMBER OF NOTES:"                                                           l                                                           :start2 0 :end2 (length "TOTAL NUMBER OF NOTES:")))                                             (setf total-number-of-notes                                                   (read-from-string l nil nil :start (length "TOTAL NUMBER OF NOTES:"))))                                                                                        ((and (>= (length l) (length "TOTAL NUMBER OF NOTE ERRORS:"))                                                  (string= "TOTAL NUMBER OF NOTE ERRORS:"                                                           l                                                           :start2 0 :end2 (length "TOTAL NUMBER OF NOTE ERRORS:")))                                             (setf total-number-of-note-errors                                                   (read-from-string l nil nil :start (length "TOTAL NUMBER OF NOTE ERRORS:"))))                                                                                        ((and (>= (length l) (length "TOTAL NUMBER OF PINS:"))                                                  (string= "TOTAL NUMBER OF PINS:"                                                           l                                                           :start2 0 :end2 (length "TOTAL NUMBER OF PINS:")))                                             (setf total-number-of-pins                                                   (read-from-string l nil nil :start (length "TOTAL NUMBER OF PINS:"))))                                                                                        ((and (>= (length l) (length "TOTAL NUMBER OF PIN ERRORS:"))                                                  (string= "TOTAL NUMBER OF PIN ERRORS:"                                                           l                                                           :start2 0 :end2 (length "TOTAL NUMBER OF PIN ERRORS:")))                                             (setf total-number-of-pin-errors                                                   (read-from-string l nil nil :start (length "TOTAL NUMBER OF PIN ERRORS:"))))                                                                                        ((and (>= (length l) (length "TOTAL % NOTES SPELT CORRECTLY:"))                                                  (string= "TOTAL % NOTES SPELT CORRECTLY:"                                                           l                                                           :start2 0 :end2 (length "TOTAL % NOTES SPELT CORRECTLY:")))                                             (setf total-percent-correct-notes                                                   (read-from-string l nil nil :start (length "TOTAL % NOTES SPELT CORRECTLY:") :end (1- (length l)))))                                                                                        ((and (>= (length l) (length "TOTAL % PINS SPELT CORRECTLY:"))                                                  (string= "TOTAL % PINS SPELT CORRECTLY:"                                                           l                                                           :start2 0 :end2 (length "TOTAL % PINS SPELT CORRECTLY:")))                                             (setf total-percent-correct-pins                                                   (read-from-string l nil nil :start (length "TOTAL % PINS SPELT CORRECTLY:") :end (1- (length l)))))))))))         (sorted-list-of-res-records (sort list-of-res-records                                           #'(lambda (r1 r2)                                               (or (string< (string (res-algorithm r1))                                                            (string (res-algorithm r2)))                                                   (and (string= (string (res-algorithm r1))                                                                 (string (res-algorithm r2)))                                                        (or (null (res-composer r2))                                                            (and (string< (string (res-composer r1))                                                                          (string (res-composer r2)))                                                                 (res-composer r1))))))))         (list-of-composers (sort (remove-duplicates (mapcar #'res-composer sorted-list-of-res-records))                                  #'(lambda (c1 c2)                                      (or (null c2)                                          (and (string< (string c1)                                                        (string c2))                                               c1))))))    ;Output a table showing numbers of note errors    (format t "~%NUMBER OF NOTE ERRORS~%=====================~%")    (dolist (composer list-of-composers)      (format t (concatenate 'string (string #\Tab) "~a") (if composer                                                            (case composer                                                              (beet 'beethoven)                                                              (corell 'corelli)                                                              (telema 'telemann)                                                              (vivald 'vivaldi)                                                              (t composer))                                                            'complete)))    (dolist (res-record sorted-list-of-res-records)      (if (eq (res-composer res-record) (first list-of-composers))        (format t "~%~a" (res-algorithm res-record)))      (format t (concatenate 'string (string #\Tab) "~d") (res-total-number-of-note-errors res-record)))        ;Output a table showing numbers of PIN errors    (format t "~%~%NUMBER OF PIN ERRORS~%====================~%")    (dolist (composer list-of-composers)      (format t (concatenate 'string (string #\Tab) "~a") (if composer                                                            (case composer                                                              (beet 'beethoven)                                                              (corell 'corelli)                                                              (telema 'telemann)                                                              (vivald 'vivaldi)                                                              (t composer))                                                            'complete)))    (dolist (res-record sorted-list-of-res-records)      (if (eq (res-composer res-record) (first list-of-composers))        (format t "~%~a" (res-algorithm res-record)))      (format t (concatenate 'string (string #\Tab) "~d") (res-total-number-of-pin-errors res-record)))        ;Output a table showing percentage notes spelt correctly    (format t "~%~%TOTAL % NOTES SPELT CORRECTLY~%=============================~%")    (dolist (composer list-of-composers)      (format t (concatenate 'string (string #\Tab) "~a") (if composer                                                            (case composer                                                              (beet 'beethoven)                                                              (corell 'corelli)                                                              (telema 'telemann)                                                              (vivald 'vivaldi)                                                              (t composer))                                                            'complete)))    (dolist (res-record sorted-list-of-res-records)      (if (eq (res-composer res-record) (first list-of-composers))        (format t "~%~a" (res-algorithm res-record)))      (format t (concatenate 'string (string #\Tab) "~3,2f") (res-total-percent-correct-notes res-record)))        ;Output a table showing percentage PINS spelt correctly    (format t "~%~%TOTAL % PINS SPELT CORRECTLY~%============================~%")    (dolist (composer list-of-composers)      (format t (concatenate 'string (string #\Tab) "~a") (if composer                                                            (case composer                                                              (beet 'beethoven)                                                              (corell 'corelli)                                                              (telema 'telemann)                                                              (vivald 'vivaldi)                                                              (t composer))                                                            'complete)))    (dolist (res-record sorted-list-of-res-records)      (if (eq (res-composer res-record) (first list-of-composers))        (format t "~%~a" (res-algorithm res-record)))      (format t (concatenate 'string (string #\Tab) "~3,2f") (res-total-percent-correct-pins res-record)))        ))#|Dietterich email: suggests that within a single piece, a given pitch class always has the same pitch name class.|#(defun multiple-spellings-for-one-pc-within-movement (&optional                                                      (corpus-directory (choose-directory-dialog :button-string "OPND-M")))  (let* ((list-of-corpus-files (directory (make-pathname :directory (pathname-directory corpus-directory)                                                         :name :wild                                                         :type "opnd-m")))         (number-of-files-with-multiple-spellings 0))    (dolist (file-name list-of-corpus-files)      (let* ((opnd-dataset (read-dataset file-name))             (set-of-pitches (remove-duplicates (mapcar #'pn2p (mapcar #'second opnd-dataset))                                                :test #'equalp))             (morph-set-list (let* ((l nil)) (dotimes (i 12 l) (setf l (cons nil l)))))             (index -1)             (list-of-multiple-spellings nil))        (dolist (p set-of-pitches)          (pushnew (mod (elt p 1) 7)                   (elt morph-set-list (mod (elt p 0) 12))                   ))        (setf list-of-multiple-spellings                  (remove-if #'null (mapcar #'(lambda (morph-set)                                                (setf index (1+ index))                                                (if (> (list-length morph-set) 1)                                                  (list index morph-set)))                                            morph-set-list)))        (if list-of-multiple-spellings (setf number-of-files-with-multiple-spellings                                             (1+ number-of-files-with-multiple-spellings )))        (format t "~%~a: ~a" (pathname-name file-name) list-of-multiple-spellings)))    (format t "~%Number of files with multiple spellings = ~d~%Percentage of files with multiple spellings = ~,2f"            number-of-files-with-multiple-spellings            (* 100.0 (/ number-of-files-with-multiple-spellings (list-length list-of-corpus-files))))))(defun batch-rename-files (old-file-type                           new-file-type                           &optional                            (dir (choose-directory-dialog :button-string "DIR")))  (let* ((list-of-old-files (directory (make-pathname :directory (pathname-directory dir)                                                      :name :wild                                                      :type old-file-type)))         (list-of-new-file-names (mapcar #'(lambda (old-file-name)                                             (make-pathname :directory (pathname-directory dir)                                                            :name (pathname-name old-file-name)                                                            :type new-file-type))                                         list-of-old-files)))    (mapcar #'rename-file list-of-old-files list-of-new-file-names)))(defun batch-rename-filenames (old-file-type                               new-file-type                               &optional                                (dir (choose-directory-dialog :button-string "DIR"))                               &key                               (old-file-prefix "")                               (new-file-prefix "")                               (old-file-suffix "")                               (new-file-suffix ""))  (let* ((list-of-old-files (directory (make-pathname :directory (pathname-directory dir)                                                      :name :wild                                                      :type old-file-type)))         (list-of-new-file-names (mapcar #'(lambda (old-file-name)                                             (make-pathname :directory (pathname-directory dir)                                                            :name (let* ((old-name (pathname-name old-file-name))                                                                         (old-name-without-suffix (subseq old-name 0 (- (length old-name)                                                                                                                        (length old-file-suffix))))                                                                         (old-name-without-suffix-and-prefix (subseq old-name-without-suffix                                                                                                                     (length old-file-prefix))))                                                                    (concatenate 'string                                                                                  new-file-prefix                                                                                 old-name-without-suffix-and-prefix                                                                                 new-file-suffix))                                                            :type new-file-type))                                         list-of-old-files)))    (mapcar #'rename-file list-of-old-files list-of-new-file-names)))(defun unix2mac (&optional (unix-file-name (choose-file-dialog :button-string "UNIX"))                           (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (let* ((unix-file-string (with-open-file (unix-file-stream                                            unix-file-name)                             (read-line unix-file-stream)))         (mac-file-string (substitute #\Newline #\Linefeed unix-file-string))         (output-file-name (make-pathname :directory (pathname-directory output-directory)                                          :name (pathname-name unix-file-name)                                          :type (concatenate 'string (pathname-type unix-file-name) "m"))))    (with-open-file (output-file-stream                     output-file-name                     :direction :output                     :if-exists :rename-and-delete)      (format output-file-stream mac-file-string))    output-file-name))(defun batch-unix2mac (&optional (unix-file-type :wild)                                 (input-directory (choose-directory-dialog :button-string "Unix Dir"))                                 (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (let* ((list-of-unix-files (directory (make-pathname :directory (pathname-directory input-directory)                                                       :name :wild                                                       :type unix-file-type))))    (mapcar #'(lambda (unix-file)                (format t "~%~a..." (pathname-name unix-file))                (unix2mac unix-file output-directory)                (format t "DONE"))            list-of-unix-files)))(defun print-results-for-algorithm (test-corpus-file-suffix                                    computed-file-suffix                                    &optional                                    (test-corpus-directory (choose-directory-dialog :button-string test-corpus-file-suffix))                                    (computed-file-directory (choose-directory-dialog :button-string computed-file-suffix))                                    (results-directory (choose-directory-dialog :button-string "RESULTS")))  (mapcar #'(lambda (composer)              (print-results test-corpus-file-suffix                             computed-file-suffix                             composer                             test-corpus-directory                             computed-file-directory                              results-directory))          '("" "bach" "beet" "corell" "handel" "haydn" "mozart" "telema" "vivald")))#|results-for-diss================This function prints the results required in a format for the dissertation.|#(defun results-for-diss (&key (res-file-directory (choose-directory-dialog :button-string "RES"))                              (list-of-algs nil)                              (list-of-excluded-algs nil)                              (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (let* ((output-file-name (make-pathname :directory (pathname-directory output-directory)                                          :name (apply #'concatenate 'string                                                        (append (if list-of-algs                                                                  (mapcar #'(lambda (alg)                                                                             (concatenate 'string                                                                                           (string-downcase alg)                                                                                          "-"))                                                                          list-of-algs)                                                                 (list "all-"))                                                               (if list-of-excluded-algs                                                                 (cons "ex-"                                                                       (mapcar #'(lambda (alg)                                                                                   (concatenate 'string                                                                                                 (string-downcase alg)                                                                                                "-"))                                                                               list-of-excluded-algs)))                                                               (list "results")))                                          :type "tex"))         (r-input-file (make-pathname :directory (pathname-directory output-directory)                                      :name (apply #'concatenate 'string                                                    (append (list "r-in")                                                           (if list-of-algs                                                              (mapcar #'(lambda (alg)                                                                         (concatenate 'string                                                                                       "-"                                                                                      (string-downcase alg)))                                                                     list-of-algs)                                                             (list "-all"))                                                           (if list-of-excluded-algs                                                             (cons "-ex"                                                                   (mapcar #'(lambda (alg)                                                                               (concatenate 'string                                                                                             "-"                                                                                            (string-downcase alg)))                                                                           list-of-excluded-algs)))))                                      :type "r"))         (r-output-tex-file (make-pathname :directory (pathname-directory output-directory)                                           :name (apply #'concatenate 'string                                                         (append (list "r-out")                                                                (if list-of-algs                                                                   (mapcar #'(lambda (alg)                                                                              (concatenate 'string                                                                                            "-"                                                                                           (string-downcase alg)))                                                                          list-of-algs)                                                                  (list "-all"))                                                                (if list-of-excluded-algs                                                                  (cons "-ex"                                                                        (mapcar #'(lambda (alg)                                                                                    (concatenate 'string                                                                                                  "-"                                                                                                 (string-downcase alg)))                                                                                list-of-excluded-algs)))))                                           :type "tex"))         (list-of-res-files (if (not list-of-algs)                              (directory (make-pathname :directory (pathname-directory res-file-directory)                                                        :name :wild                                                        :type "res"))                              (apply #'append                                     (mapcar #'(lambda (alg)                                                 (directory (make-pathname :directory (pathname-directory res-file-directory)                                                                           :name (concatenate 'string                                                                                              "opnd-m-"                                                                                              (string alg)                                                                                              "*")                                                                           :type "res")))                                             list-of-algs))))         (list-of-excluded-res-files (apply #'append                                            (mapcar #'(lambda (alg)                                                        (directory (make-pathname :directory (pathname-directory res-file-directory)                                                                                  :name (concatenate 'string                                                                                                     "opnd-m-"                                                                                                     (string alg)                                                                                                     "*")                                                                                  :type "res")))                                                    list-of-excluded-algs)))         (list-of-res-files (set-difference list-of-res-files list-of-excluded-res-files                                            :test #'equalp))         (list-of-res-records (let* ((lod nil))                                (dolist (res-file list-of-res-files lod)                                  (with-open-file (res-stream                                                   res-file                                                   :direction :input)                                    (do* ((l (read-line res-stream nil nil)                                             (read-line res-stream nil nil))                                          (composer nil)                                          (algorithm nil)                                          (total-number-of-notes nil)                                          (total-number-of-note-errors nil)                                          (total-percent-correct-notes nil))                                         ((null l)                                                                                    (if (string= (format nil "~,2f" total-percent-correct-notes)                                                       (format nil "~,2f" (* 100 (- 1 (/ total-number-of-note-errors total-number-of-notes)))))                                            (setf lod                                                  (cons (make-res :composer composer                                                                  :algorithm algorithm                                                                  :total-number-of-notes total-number-of-notes                                                                  :total-number-of-note-errors total-number-of-note-errors                                                                  :total-percent-correct-notes (* 100 (- 1 (/ total-number-of-note-errors total-number-of-notes)))                                                                  :ner (* 100 (/ total-number-of-note-errors total-number-of-notes))                                                                  )                                                        lod))                                            (progn (format t "~%ERROR: Calculated note accuracy not equal to one read from file.")                                                   (abort))))                                      (setf composer (get-value-from-res-file l "FILE PREFIX:" composer))                                      (setf algorithm (get-value-from-res-file l "COMPUTED FILE SUFFIX:" algorithm))                                      (setf total-number-of-notes (get-value-from-res-file l "TOTAL NUMBER OF NOTES:" total-number-of-notes))                                      (setf total-number-of-note-errors (get-value-from-res-file l "TOTAL NUMBER OF NOTE ERRORS:" total-number-of-note-errors))                                      (setf total-percent-correct-notes (get-value-from-res-file l "TOTAL % NOTES SPELT CORRECTLY:" total-percent-correct-notes (1- (length l))))                                      )))))         (sorted-list-of-res-records (sort list-of-res-records                                           #'(lambda (r1 r2)                                               (or (string< (string (res-algorithm r1))                                                            (string (res-algorithm r2)))                                                   (and (string= (string (res-algorithm r1))                                                                 (string (res-algorithm r2)))                                                        (or (null (res-composer r2))                                                            (and (res-composer r1)                                                                 (string< (string (res-composer r1))                                                                          (string (res-composer r2)))                                                                 )))))))         (list-of-algorithm-result-lists (sort                                          (let* ((loarl (list (list (first sorted-list-of-res-records)))))                                            (dolist (res (cdr sorted-list-of-res-records) (reverse (mapcar #'reverse loarl)))                                              (if (eq (res-algorithm res)                                                      (res-algorithm (first (first loarl))))                                                (setf (first loarl)                                                      (cons res (first loarl)))                                                (setf loarl                                                      (cons (list res)                                                            loarl)))))                                          #'<                                          :key #'(lambda (alg-res-list)                                                   (res-total-number-of-note-errors (first (last alg-res-list))))))         (list-of-style-means (mapcar #'(lambda (algorithm-result-list)                                          (mean (mapcar #'res-total-percent-correct-notes (butlast algorithm-result-list))))                                      list-of-algorithm-result-lists))         (list-of-style-sds (mapcar #'(lambda (algorithm-result-list)                                        (standard-deviation (mapcar #'res-total-percent-correct-notes (butlast algorithm-result-list))))                                    list-of-algorithm-result-lists))         (list-of-column-headings (append (list (concatenate 'string (string #\\) "alghd" (string #\Tab)))                                          (mapcar #'(lambda (res-record)                                                      (concatenate 'string                                                                    "&"                                                                   (string #\\)                                                                   (case (res-composer res-record)                                                                     (bach "nahd{Bach}")                                                                     (beet "nahd{Beethoven}")                                                                     (corell "nahd{Corelli}")                                                                     (handel "nahd{Handel}")                                                                     (haydn "nahd{Haydn}")                                                                     (mozart "nahd{Mozart}")                                                                     (telema "nahd{Telemann}")                                                                     (vivald "nahd{Vivaldi}")                                                                     (t "naComplete"))                                                                   (string #\Tab)))                                                  (first list-of-algorithm-result-lists))                                          (list (concatenate 'string "&\\stymeanhd" (string #\Tab))                                                (concatenate 'string "&\\stydephd" (string #\Tab)))))         (column-headings-for-na-table (apply #'concatenate 'string (append list-of-column-headings                                                                            (list "\\\\\\hline"))))         (list-of-column-headings-for-nec-table (append (list (concatenate 'string (string #\\) "necalghd" (string #\Tab)))                                                        (mapcar #'(lambda (res-record)                                                                    (concatenate 'string                                                                                  "&"                                                                                 (string #\\)                                                                                 (case (res-composer res-record)                                                                                   (bach "nechd{Bach}")                                                                                   (beet "nechd{Beethoven}")                                                                                   (corell "nechd{Corelli}")                                                                                   (handel "nechd{Handel}")                                                                                   (haydn "nechd{Haydn}")                                                                                   (mozart "nechd{Mozart}")                                                                                   (telema "nechd{Telemann}")                                                                                   (vivald "nechd{Vivaldi}")                                                                                   (t "necComplete"))                                                                                 (string #\Tab)))                                                                (first list-of-algorithm-result-lists))))         (column-headings-for-nec-table (apply #'concatenate 'string (append list-of-column-headings-for-nec-table                                                                             (list "\\\\"))))         (nnotes-row-for-nec-table (apply #'concatenate 'string                                           (append (list ""                                                        (string #\Tab))                                                  (mapcar #'(lambda (nnotes)                                                              (format nil (concatenate 'string "&(~d)" (string #\Tab)) nnotes))                                                          (mapcar #'res-total-number-of-notes (first list-of-algorithm-result-lists)))                                                  (list "\\\\\\hline"))))         (list-of-rows-for-nec-table (let* ((lor nil))                                       (dolist (alg-res-list list-of-algorithm-result-lists (reverse lor))                                         (setf lor                                               (cons (apply #'concatenate 'string                                                            (append (list (concatenate 'string                                                                                        (string (res-algorithm (first alg-res-list)))                                                                                       (string #\Tab)))                                                                    (mapcar #'(lambda (res)                                                                                (format nil (concatenate 'string                                                                                                         "&~d"                                                                                                         (string #\Tab))                                                                                        (res-total-number-of-note-errors res)))                                                                            alg-res-list)                                                                    (list "\\\\")))                                                     lor)))))         (list-of-rows-for-na-table (mapcar #'(lambda (alg-res-list style-sd style-mean)                                                (apply #'concatenate 'string                                                       (append (list (concatenate 'string                                                                                   (string (res-algorithm (first alg-res-list)))                                                                                  (string #\Tab)))                                                               (mapcar #'(lambda (res)                                                                           (format nil (concatenate 'string                                                                                                    "&~,2f"                                                                                                    (string #\Tab))                                                                                   (res-total-percent-correct-notes res)))                                                                       alg-res-list)                                                               (list (concatenate 'string "&" (format nil "~,2f" style-mean) (string #\Tab))                                                                     (concatenate 'string "&" (format nil "~,2f" style-sd) (string #\Tab))                                                                     "\\\\"))))                                            list-of-algorithm-result-lists                                            list-of-style-sds                                            list-of-style-means))         (rel-diff-table-first-row (apply #'concatenate 'string (append (mapcar #'(lambda (alg-result-list)                                                                                    (concatenate 'string                                                                                                  "&"                                                                                                 (string (res-algorithm (first alg-result-list)))                                                                                                 (string #\Tab)))                                                                                list-of-algorithm-result-lists)                                                                        (list "\\\\\\hline"))))         (list-of-complete-ners (mapcar #'(lambda (algorithm-result-list)                                            (res-ner (first (last algorithm-result-list))))                                        list-of-algorithm-result-lists))         (list-of-algorithms (mapcar #'(lambda (algorithm-result-list)                                         (res-algorithm (first algorithm-result-list)))                                     list-of-algorithm-result-lists))         (list-of-rows-for-rel-diff-table (mapcar #'(lambda (ner1 algorithm)                                                      (apply #'concatenate 'string                                                              (append (list (string algorithm)                                                                           (string #\Tab))                                                                     (mapcar #'(lambda (delta-ner-pr)                                                                                 (format nil (concatenate 'string "&~,2f" (string #\Tab)) delta-ner-pr))                                                                             (mapcar #'(lambda (ner2)                                                                                         (* 100                                                                                            (/ (- ner2 ner1)                                                                                               ner1)))                                                                                     list-of-complete-ners))                                                                     (list "\\\\"))))                                                  list-of-complete-ners                                                  list-of-algorithms))         (label-prefix (append (if list-of-algs                                  (mapcar #'(lambda (alg)                                             (concatenate 'string                                                           (string-downcase alg)                                                          "-"))                                          list-of-algs)                                 (list "all-"))                               (if list-of-excluded-algs                                 (cons "ex-"                                       (mapcar #'(lambda (alg)                                                   (concatenate 'string                                                                 (string-downcase alg)                                                                "-"))                                               list-of-excluded-algs)))))         (nec-table-label (apply #'concatenate 'string                                  (append label-prefix                                         (list "nec-table"))))         (na-table-label (apply #'concatenate 'string                                 (append label-prefix                                        (list "na-table"))))         (prop-diff-table-label (apply #'concatenate 'string                                 (append label-prefix                                        (list "prop-diff-table"))))         (rows-for-r-table (mapcar #'(lambda (algorithm-result-list)                                       (list (string-upcase (res-algorithm (first algorithm-result-list)))                                             (res-ner (find 'corell algorithm-result-list :key #'res-composer))                                             (res-ner (find 'vivald algorithm-result-list :key #'res-composer))                                             (res-ner (find 'telema algorithm-result-list :key #'res-composer))                                             (res-ner (find 'handel algorithm-result-list :key #'res-composer))                                             (res-ner (find 'bach algorithm-result-list :key #'res-composer))                                             (res-ner (find 'haydn algorithm-result-list :key #'res-composer))                                             (res-ner (find 'mozart algorithm-result-list :key #'res-composer))                                             (res-ner (find 'beet algorithm-result-list :key #'res-composer))))                                   list-of-algorithm-result-lists))         (rows-for-r-table (do* ((i 0)                                (j 1))                               ((= j (list-length rows-for-r-table))                                (remove-if #'null rows-for-r-table))                            (if (equalp (cdr (elt rows-for-r-table i))                                        (cdr (elt rows-for-r-table j)))                              (setf (first (elt rows-for-r-table i))                                    (concatenate 'string                                                  (first (elt rows-for-r-table i))                                                 "."                                                 (first (elt rows-for-r-table j)))                                    (elt rows-for-r-table j)                                    nil                                    j                                     (1+ j))                              (setf i j j (1+ i)))))         (max-ner (ceiling (apply #'max (apply #'append (mapcar #'cdr rows-for-r-table))))))        (with-open-file (output-stream                     output-file-name                     :direction :output                     :if-exists :rename-and-delete)      ;OUTPUT NEC and NA TABLES      (format output-stream "~%\\begin{sidewaystable}")      (format output-stream "~%\\footnotesize")      (format output-stream "~%\\begin{center}")      (format output-stream "~%\\begin{tabular}{|l|rrrrrrrr|r|}\\hline~%")      (format output-stream column-headings-for-nec-table )      (format output-stream "~%")      (format output-stream nnotes-row-for-nec-table )      (dolist (row list-of-rows-for-nec-table)        (format output-stream "~%~a" row))      (format output-stream "\\hline~%\\end{tabular}")      (format output-stream "~%\\caption{\\nectablecaption}")      (format output-stream (concatenate 'string                                         "~%\\label{"                                         nec-table-label                                         "}"))      (format output-stream "~%\\end{center}")      (format output-stream "~%\\end{sidewaystable}")                  (format output-stream "~%~%\\begin{sidewaystable}")      (format output-stream "~%\\footnotesize")      (format output-stream "~%\\begin{center}")      (format output-stream "~%\\begin{tabular}{|l|rrrrrrrr|r|r|r|}\\hline~%")      (format output-stream column-headings-for-na-table)      (dolist (row list-of-rows-for-na-table)        (format output-stream "~%~a" row))      (format output-stream "\\hline~%\\end{tabular}")      (format output-stream "~%\\caption{\\natablecaption}")      (format output-stream (concatenate 'string                                         "~%\\label{"                                         na-table-label                                         "}"))      (format output-stream "~%\\end{center}")      (format output-stream "~%\\end{sidewaystable}")            ;OUTPUT REL-DIFF TABLE      (format output-stream "~%~%\\begin{sidewaystable}")      (format output-stream (if (> (list-length list-of-algorithms) 20)                              "~%\\tiny"                              "~%\\footnotesize"))      (format output-stream "~%\\begin{center}")      (format output-stream (concatenate 'string                                         "~%\\begin{tabular}{|l|"                                         (let ((s "")) (dotimes (i (list-length list-of-algorithms) s) (setf s (concatenate 'string s "r"))))                                         "|}\\hline~%"))      (format output-stream rel-diff-table-first-row)      (dolist (row list-of-rows-for-rel-diff-table)        (format output-stream "~%~a" row))      (format output-stream "\\hline~%\\end{tabular}")      (format output-stream "~%\\caption{\\propdifftablecaption}")      (format output-stream               (concatenate 'string                            "~%\\label{"                           prop-diff-table-label                           "}"))      (format output-stream "~%\\end{center}")      (format output-stream "~%\\end{sidewaystable}"))        ;NOW OUTPUT FOR R    (with-open-file (r-in-stream                     r-input-file                     :direction :output                     :if-exists :rename-and-delete)      (progn (format r-in-stream "~%rm(list = ls())")             (format  r-in-stream  "~%WD<-getwd()")             (format r-in-stream "~%setwd(\"~a\")" (substitute #\/ #\: (subseq (format nil "~a" output-directory) 2 (1- (length (format nil "~a" output-directory))))))             (format r-in-stream "~%oldpar <- par(no.readonly = TRUE)")             (format r-in-stream "~%composers=c(\"Core\",\"Viva\",\"Tele\",\"Hand\",\"Bach\",\"Hayd\",\"Moza\",\"Beet\")")             (dolist (r rows-for-r-table)               (format r-in-stream "~%~%\#Start of output for ~a" (first r))               (format r-in-stream "~%postscript(\"r-out-~a.ps\")" (substitute #\- #\. (string-downcase (first r))))               (format r-in-stream "~%par(pty=\"s\")")               (format r-in-stream "~%~a=c(~a" (first r) (second r))               (dolist (i (cddr r))                 (format r-in-stream ", ~a" i))               (format r-in-stream ")")               (format r-in-stream "~%plot(~a, type=\"b\", main=~s, ylab=\"NER(%)\", xlab=\"Composer\", axes=FALSE, ylim=c(0,~d))"                        (first r)                       (let* ((line-as-list (convert-line-to-list (substitute #\Space #\. (first r))))                              (s (string (first line-as-list))))                         (dolist (i (cdr line-as-list) s)                           (setf s (concatenate 'string                                                s                                                ", "                                                (string i)))))                       max-ner)               (format r-in-stream "~%axis(side=1,at=1:8,labels=composers)")               (format r-in-stream "~%axis(side=2)")               (format r-in-stream "~%box()")               (format r-in-stream "~%dev.off()")               (format r-in-stream "~%\#End of output for ~a" (first r)))             (format r-in-stream "~%par(oldpar)")             (format r-in-stream "~%setwd(WD)")             (format r-in-stream "~%rm(list = ls())")))        (with-open-file (r-output-tex-stream                     r-output-tex-file                     :direction :output                     :if-exists :rename-and-delete)      (progn (format r-output-tex-stream "~%\\begin{figure}")             (format r-output-tex-stream "~%\\begin{center}")             (dotimes (i (list-length rows-for-r-table))               (if (and (> i 0)                        (zerop (mod i 6)))                 (progn (format r-output-tex-stream "~%\\caption{\\routcaption}")                        (format r-output-tex-stream                                 "~%\\label{~aner-composer-graphs-~d}"                                (apply #'concatenate 'string label-prefix)                                (/ i 6))                        (format r-output-tex-stream "~%\\end{center}")                        (format r-output-tex-stream "~%\\end{figure}")                        (format r-output-tex-stream "~%~%\\begin{figure}")                        (format r-output-tex-stream "~%\\begin{center}"))                 (if (and (> i 0)                          (zerop (mod i 2)))                   (format r-output-tex-stream "~%\\vskip.2in")))               (format r-output-tex-stream                        "~%\\includegraphics\[width=.4\\textwidth\]{r-out-~a.jpg}"                       (substitute #\- #\. (string-downcase (first (elt rows-for-r-table i)))))               )             (format r-output-tex-stream "~%\\caption{\\routcaption}")             (format r-output-tex-stream                      "~%\\label{~a-ner-composer-graphs-~d}"                     (apply #'concatenate 'string label-prefix)                     (ceiling (list-length rows-for-r-table) 6))             (format r-output-tex-stream "~%\\end{center}")             (format r-output-tex-stream "~%\\end{figure}")))            (format t "~%FILE WRITTEN: ~a" output-file-name)    ))#|%Corelli		17 Feb 1653%Vivaldi		 4 Mar 1678%Telemann		14 Mar 1681%Handel			23 Feb 1685%Bach			21 Mar 1685%Haydn			31 Mar 1732%Mozart			27 Jan 1756%Beethoven		17 Dec 1770|#(defun get-value-from-res-file (l label variable &optional (end (length l)))  (if (and (not variable)           (>= (length l) (length label))           (string= label                    l                    :start2 0 :end2 (length label)))    (read-from-string l nil nil :start (length label) :end end)    variable))(defun find-errors-in-f1-but-not-f2 (&key (correct-opndv-file (choose-file-dialog :button-string "Correct"))                                          (f1 (choose-file-dialog :button-string "f1"))                                          (f2 (choose-file-dialog :button-string "f2")))  (let* ((correct-dataset (sort-by-onset (read-dataset correct-opndv-file)))         (f1-dataset (sort-by-onset (read-dataset f1)))         (f2-dataset (sort-by-onset (read-dataset f2)))         (errors-in-f1 (mapcar #'(lambda (correct-dp f1-dp)                                   (if (not (opndv-datapoint-equal-p correct-dp f1-dp))                                     (list correct-dp f1-dp)))                               correct-dataset f1-dataset))         (number-of-errors-in-f1 (- (list-length errors-in-f1)                                    (count nil errors-in-f1)))         (errors-in-f2 (mapcar #'(lambda (correct-dp f2-dp)                                   (if (not (opndv-datapoint-equal-p correct-dp f2-dp))                                     (list correct-dp f2-dp)))                               correct-dataset f2-dataset))         (number-of-errors-in-f2 (- (list-length errors-in-f2)                                    (count nil errors-in-f2)))         (errors-in-f1-but-not-f2 (mapcar #'(lambda (f1-error f2-error)                                              (if (and f1-error                                                       (null f2-error))                                                f1-error))                                          errors-in-f1                                          errors-in-f2))         (number-of-errors-in-f1-but-not-f2 (- (list-length errors-in-f1-but-not-f2)                                               (count nil errors-in-f1-but-not-f2)))         (errors-in-f2-but-not-f1 (mapcar #'(lambda (f2-error f1-error)                                              (if (and f2-error                                                       (null f1-error))                                                f2-error))                                          errors-in-f2                                          errors-in-f1))         (number-of-errors-in-f2-but-not-f1 (- (list-length errors-in-f2-but-not-f1)                                               (count nil errors-in-f2-but-not-f1)))         (different-errors-in-f1-and-f2 (mapcar #'(lambda (f1-error f2-error)                                                    (if (and f1-error                                                             f2-error                                                             (not (opndv-datapoint-equal-p (second f1-error)                                                                                           (second f2-error))))                                                      (list f1-error f2-error)))                                                errors-in-f1                                                errors-in-f2))         (number-of-different-errors (- (list-length different-errors-in-f1-and-f2)                                        (count nil different-errors-in-f1-and-f2))))    (format t "~%Correct file: ~a" correct-opndv-file)    (format t "~%f1: ~a" f1)    (format t "~%f2: ~a" f2)    (format t "~%Number of errors in f1 = ~d" number-of-errors-in-f1)    (format t "~%Number of errors in f2 = ~d" number-of-errors-in-f2)    (format t "~%Number of errors in f1 but not f2 = ~d" number-of-errors-in-f1-but-not-f2)    (format t "~%Number of errors in f2 but not f1 = ~d" number-of-errors-in-f2-but-not-f1)    (format t "~%Number of different errors in f1 and f2 = ~d" number-of-different-errors)    (format t "~%Errors in f1 but not f2:")    (pprint errors-in-f1-but-not-f2)    (format t "~%Errors in f2 but not f1:")    (pprint errors-in-f2-but-not-f1)    (format t "~%Different errors in f1 and f2:")    (pprint different-errors-in-f1-and-f2)))(defun opndv-datapoint-equal-p (dp1 dp2)  (and (= (first dp1)          (first dp2))       (pitch-name-equal-p (second dp1)                           (second dp2))       (= (third dp1)          (third dp2))       (= (fourth dp1)          (fourth dp2))))(defun get-number-of-errors (&key (correct-file (choose-file-dialog :button-string "Correct"))                                  (incorrect-file (choose-file-dialog :button-string "Incorrect")))  (let* ((correct-dataset (sort-by-onset (read-dataset correct-file)))         (incorrect-dataset (sort-by-onset (read-dataset incorrect-file)))         (result (count nil (mapcar #'opndv-datapoint-equal-p correct-dataset incorrect-dataset))))    (format t "~%~a~%contains ~d errors."             incorrect-file             result)    result))(defun batch-compare-number-of-errors (file-type-1                                        file-type-2                                       &key (dir1 (choose-directory-dialog :button-string file-type-1))                                            (dir2 (choose-directory-dialog :button-string file-type-2))                                            (correct-dir (choose-directory-dialog :button-string "Correct"))                                            (file-prefix "")                                            (correct-file-type "opnd-m"))  (let* ((list-of-files-from-dir1 (directory (make-pathname :directory (pathname-directory dir1)                                                            :name (concatenate 'string file-prefix "*")                                                            :type file-type-1)))         (list-of-files-from-dir2 (directory (make-pathname :directory (pathname-directory dir2)                                                            :name (concatenate 'string file-prefix "*")                                                            :type file-type-2)))         (list-of-correct-files (directory (make-pathname :directory (pathname-directory correct-dir)                                                          :name (concatenate 'string file-prefix "*")                                                          :type correct-file-type)))         (file1-errors nil)         (file2-errors nil)         (results (mapcar #'(lambda (correct-file file-name1 file-name2)                              (if (and (string= (pathname-name file-name1)                                                (pathname-name file-name2))                                       (string= (pathname-name correct-file)                                                (pathname-name file-name1)))                                (list (pathname-name file-name1)                                    (setf file1-errors (get-number-of-errors :correct-file correct-file                                                                             :incorrect-file file-name1))                                    (setf file2-errors (get-number-of-errors :correct-file correct-file                                                                             :incorrect-file file-name2))                                    (- file2-errors file1-errors))                                (progn (format t "~%ERROR: File names not compatible.")                                       (abort))))                          list-of-correct-files                          list-of-files-from-dir1                          list-of-files-from-dir2))         (totals (list (apply #'+ (mapcar #'second results))                       (apply #'+ (mapcar #'third results))                       (apply #'+ (mapcar #'fourth results)))))    (format t             "~%Mvt			~a			~a			~a"            file-type-1            file-type-2            (concatenate 'string file-type-2 " - " file-type-1))    (dolist (r results)      (format t               "~%~a			~d			~d			~d"              (first r)              (second r)              (third r)              (fourth r)))    (format t            "~%Totals			~d			~d			~d"            (first totals)            (second totals)            (third totals))))#|(setf alg-list '(C1AC1DCO))(setf speed-list '(8.8088.6501.305	))(setf alg-speed-pair-list-as-input      (mapcar #'list alg-list speed-list))|#(defun speed-comparison-table (alg-speed-pair-list-as-input)  (let* ((alg-speed-pair-list (sort alg-speed-pair-list-as-input                                    #'string<                                    :key #'(lambda (x) (string (first x)))))         (comparison-table (let* ((sct nil))                             (dotimes (i (list-length alg-speed-pair-list) (reverse sct))                               (setf sct (cons (let* ((row nil))                                                 (dotimes (j (list-length alg-speed-pair-list) (reverse row))                                                   (setf row (cons (list (first (elt alg-speed-pair-list i))                                                                         (first (elt alg-speed-pair-list j))                                                                         (* 100 (/ (- (second (elt alg-speed-pair-list j))                                                                                      (second (elt alg-speed-pair-list i)))                                                                                   (second (elt alg-speed-pair-list i)))))                                                                   row))))                                               sct))))))    (progn (format t "~%	")           (dolist (alg (mapcar #'first alg-speed-pair-list))             (format t "&~a	" alg))           (format t "\\\\")           (dolist (row comparison-table)             (format t "~%~a	" (first (first row)))             (dolist (alg-speed-pair row)               (format t "&~,2f	" (third alg-speed-pair)))             (format t "\\\\")))))(defun pn2pnc (pn-as-input)  (let* ((pn (string pn-as-input)))    (string-right-trim (list #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\-)                       pn)))(defun find-enharmonic-changes (&optional (range 20)                                          (opndv-file (choose-file-dialog :button-string "OPNDV")))  (let* ((sorted-opndv-dataset (sort-by-onset (read-dataset opndv-file)))         (number-of-notes (list-length sorted-opndv-dataset))         (enharmonic-changes (do* ((i 0 (1+ i))                                   (ec nil))                                  ((= i number-of-notes)                                   (reverse ec))                               (do* ((j (1- i) (1- j))                                     (found nil))                                    ((or (< j 0)                                         (< j (- i range))                                         (setf found                                               (let* ((pn1 (second (elt sorted-opndv-dataset i)))                                                      (pn2 (second (elt sorted-opndv-dataset j)))                                                      (c1 (mod (first (pn2p pn1)) 12))                                                      (c2 (mod (first (pn2p pn2)) 12))                                                      (pnc1 (pn2pnc pn1))                                                      (pnc2 (pn2pnc pn2)))                                                 (and (= c1 c2)                                                      (string/= (string-upcase pnc1) (string-upcase pnc2))))))                                     (if found                                        (setf ec                                             (cons (list (elt sorted-opndv-dataset i)                                                         (elt sorted-opndv-dataset j))                                                   ec))))))))    (if enharmonic-changes       (progn (format t "~%~%~a" opndv-file)             (pprint enharmonic-changes)             t))))(defun batch-find-enharmonic-changes (&optional (range 20)                                                (input-dir (choose-directory-dialog :button-string "INPUT"))                                                (input-type "opnd-m"))  (let* ((list-of-files (directory (make-pathname :directory (pathname-directory input-dir)                                                  :name :wild                                                  :type input-type))))    (mapcar #'(lambda (input-file)                (find-enharmonic-changes range input-file))            list-of-files)))(defun find-file-in-directory (&key                                (search-directory (choose-directory-dialog :button-string "SEARCH"))                               (name :wild)                               (type :wild))  (let* ((list-of-files-in-this-directory (directory (make-pathname :directory (pathname-directory search-directory)                                                                    :name name                                                                    :type type                                                                    )))         (list-of-directories-in-this-directory (directory (make-pathname :directory (pathname-directory search-directory)                                                                          :name :wild                                                                          :type :wild)                                                           :directories t                                                           :files nil))         (list-of-files-in-subdirectories (apply #'append (mapcar #'(lambda (dir)                                                                     (find-file-in-directory :search-directory dir                                                                                             :name name                                                                                             :type type))                                                                 list-of-directories-in-this-directory))))    (append list-of-files-in-this-directory            list-of-files-in-subdirectories)))(defun haydn100test ()  (let* ((root-directory (choose-directory-dialog :button-string "ROOT"))         (list-of-computed-files (find-file-in-directory :name "haydndoversyms-10004m"                                                          :search-directory root-directory))         (original-spelling (sort-by-onset (read-dataset (choose-file-dialog :button-string "ORIGINAL"))))         (original-spelling-rd2 (mapcar #'copy-list original-spelling))         (original-spelling-fd2 (mapcar #'copy-list original-spelling))         (modified-spelling (sort-by-onset (read-dataset (choose-file-dialog :button-string "MODIFIED"))))         (modified-spelling-rd2 (mapcar #'copy-list modified-spelling))         (modified-spelling-fd2 (mapcar #'copy-list modified-spelling))         (number-of-notes (list-length original-spelling))         (computed-dataset-as-read-in nil))    (dolist (note original-spelling-rd2)      (setf (second note)            (pn-tran (second note) "rd2")))    (dolist (note original-spelling-fd2)      (setf (second note)            (pn-tran (second note) "fd2")))    (dolist (note modified-spelling-rd2)      (setf (second note)            (pn-tran (second note) "rd2")))    (dolist (note modified-spelling-fd2)      (setf (second note)            (pn-tran (second note) "fd2")))    (dolist (computed-file list-of-computed-files)      (setf computed-dataset-as-read-in (read-dataset computed-file))      (if (and (listp computed-dataset-as-read-in)               (listp (first computed-dataset-as-read-in))               (stringp (second (first computed-dataset-as-read-in)))               (= (list-length computed-dataset-as-read-in)                  number-of-notes))        (let* ((computed-dataset (sort-by-onset computed-dataset-as-read-in))               (errors-orig (count nil (mapcar #'pn= (mapcar #'second computed-dataset) (mapcar #'second original-spelling))))               (errors-orig-rd2 (count nil (mapcar #'pn= (mapcar #'second computed-dataset) (mapcar #'second original-spelling-rd2))))               (errors-orig-fd2 (count nil (mapcar #'pn= (mapcar #'second computed-dataset) (mapcar #'second original-spelling-fd2))))               (errors-mod (count nil (mapcar #'pn= (mapcar #'second computed-dataset) (mapcar #'second modified-spelling))))               (errors-mod-rd2 (count nil (mapcar #'pn= (mapcar #'second computed-dataset) (mapcar #'second modified-spelling-rd2))))               (errors-mod-fd2 (count nil (mapcar #'pn= (mapcar #'second computed-dataset) (mapcar #'second modified-spelling-fd2))))               (nec-for-original (min errors-orig errors-orig-rd2 errors-orig-fd2))               (nec-for-modified (min errors-mod errors-mod-rd2 errors-mod-fd2))               (na-for-original (* 100.0 (/ (- number-of-notes nec-for-original) number-of-notes)))               (na-for-modified (* 100.0 (/ (- number-of-notes nec-for-modified) number-of-notes))))          (format t "FILE NAME: ~aNEC (orig, mod): ~8d~8dNA% (orig, mod): ~8,3f~8,3f"                  computed-file                  nec-for-original nec-for-modified                  na-for-original na-for-modified))))))#|;Need necs for haydn and complete for modified version of haydndoversyms-10004 for Temperley.(let* ((algorithms '(MH2PX2MHX2MH	MH2PMH2PX4MHX4MHD2MH2PD2MHX6MH2PX6MHD4MH2PD4))       (haydn-orig-necs '(3229325231053110357335634413439340664065856212170))       (complete-orig-necs '(432543524388439249298325107291414917178260413383449821))       (complete-number-of-notes 195972)       (haydn-number-of-notes 24490)       (haydn100-orig-necs '(298029802978297829922996337233943421342243894410))       (haydn100-mod-necs '(18 18 9 9 48 55 618 652 917 918 2426 2449))       (haydn-mod-necs (mapcar #'(lambda (haydn-orig-nec                                          haydn100-orig-nec                                          haydn100-mod-nec)                                   (+ (- haydn-orig-nec haydn100-orig-nec)                                      haydn100-mod-nec))                               haydn-orig-necs                               haydn100-orig-necs                               haydn100-mod-necs))       (complete-mod-necs (mapcar #'(lambda (complete-orig-nec                                             haydn100-orig-nec                                             haydn100-mod-nec)                                      (+ haydn100-mod-nec                                         (- complete-orig-nec haydn100-orig-nec)))                                  complete-orig-necs                                  haydn100-orig-necs                                  haydn100-mod-necs))       (haydn-mod-nas (mapcar #'(lambda (haydn-mod-nec)                                  (/ (- haydn-number-of-notes haydn-mod-nec)                                     haydn-number-of-notes))                              haydn-mod-necs))       (complete-mod-nas (mapcar #'(lambda (complete-mod-nec)                                     (/ (- complete-number-of-notes complete-mod-nec)                                        complete-number-of-notes))                                 complete-mod-necs)))  (mapcar #'(lambda (haydn-mod-na)              (format t "~%~,2f" (* 100 haydn-mod-na)))          haydn-mod-nas)  (format t "~%")  (mapcar #'(lambda (complete-mod-na)              (format t "~%~,2f" (* 100 complete-mod-na)))          complete-mod-nas)  )(mapcar #'(lambda (mean)            (format t "~%~,2f" mean))        (mapcar #'standard-deviation '((99.88			96.67				99.98			99.93			98.91	99.31			99.89				99.87)   (99.87			96.61				99.98			99.91			98.82	99.33			99.91				99.89)   (99.90			96.16				99.99			99.94			99.44	99.48			99.89				99.39)   (99.88			96.12				99.99			99.93			99.42	99.43			99.89				99.52)   (99.69			96.77				99.95			99.86			97.43	98.77			99.63				99.79)   (94.79			89.49				99.97			99.12			97.46	98.86			98.56				99.78)   (99.41			90.20				98.73			98.73			93.23	95.96			98.02				93.15)   (92.04			90.34				94.80			98.69			93.26	96.07			94.89				93.35)   (85.37			69.76				99.95			98.56			93.62	98.79			98.33				95.72)   (85.72			76.57				99.91			99.82			93.63	57.21			99.42				91.64)   (95.27			60.87				91.44			92.71			73.05	87.07			90.22				79.25)   (84.06			48.23				85.37			86.10			58.31	81.65			88.82				72.07))))|#(defun run-alg-and-print-results (ALGORITHM                                  OPNDV-SORTER                                  OPNDV-TO-INPUT-CONVERTER                                  OUTPUT-TO-OPNDV-CONVERTER                                  INPUT-FILE-SUFFIX                                  OUTPUT-FILE-SUFFIX                                  &optional                                  (INPUT-DIRECTORY (choose-directory-dialog :button-string "INPUT DIR"))                                  (OUTPUT-DIRECTORY (choose-directory-dialog :button-string "OUTPUT DIR"))                                  (results-directory (choose-directory-dialog :button-string "RESULTS DIR")))  (run-algorithm ALGORITHM                  OPNDV-SORTER                 OPNDV-TO-INPUT-CONVERTER                 OUTPUT-TO-OPNDV-CONVERTER                 INPUT-FILE-SUFFIX                 OUTPUT-FILE-SUFFIX                 INPUT-DIRECTORY                 OUTPUT-DIRECTORY)  (mapcar #'(lambda (composer)              (print-results input-file-suffix                             output-file-suffix                             composer                             input-directory                             output-directory                             results-directory))          '("" ;"bach" "beet" "corell" "handel" "haydn" "mozart" "telema" "vivald"            )))(defun print-all-results (output-type)  (let (output-directory input-directory results-directory)    (setf output-directory (choose-directory-dialog :button-string "OUTPUT"))    (setf input-directory (choose-directory-dialog :button-string "INPUT"))    (setf results-directory (choose-directory-dialog :button-string "RESULTS"))    (mapcar #'(lambda (composer)                (print-results  "opnd-m" output-type composer input-directory output-directory results-directory))            '("" "bach" "beet" "corell" "handel" "haydn" "mozart" "telema" "vivald"))))