;ps-dphil-temperley.lisp(defun batch-compute-temp-input-files (&optional                                       (input-opnd-m-directory (choose-directory-dialog :button-string "OPND IN"))                                       (input-notes-directory (choose-directory-dialog :button-string "NTS IN"))                                       (new-opnd-m-output-directory (choose-directory-dialog :button-string "OPND OUT"))                                       (new-notes-output-directory (choose-directory-dialog :button-string "NTS OUT")))  (let* ((list-of-opnd-m-input-files (directory (make-pathname :directory (pathname-directory input-opnd-m-directory)                                                               :name :wild                                                               :type "opnd-m")))         (list-of-notes-input-files (directory (make-pathname :directory (pathname-directory input-notes-directory)                                                              :name :wild                                                              :type "nts2"))))    (mapcar #'(lambda (opnd-m-file                       notes-file)                (compute-temp-input-files opnd-m-file                                          notes-file                                          new-opnd-m-output-directory                                          new-notes-output-directory))            list-of-opnd-m-input-files            list-of-notes-input-files)))(defun compute-temp-input-files (&optional (opnd-m-file (choose-file-dialog :button-string "OPND-M"))                                           (notes-file (choose-file-dialog :button-string "NOTES"))                                           (new-opnd-m-output-directory (choose-directory-dialog :button-string "New OPND-M"))                                           (new-notes-output-directory (choose-directory-dialog :button-string "New NOTES")))  (format t "~%~%INPUT OPND-M FILE: ~a" opnd-m-file)  (format t "~%INPUT NOTES FILE: ~a" notes-file)  (let* ((opnd-m-dataset (read-dataset opnd-m-file))         (note-string-list (remove-if-not #'(lambda (s)                                              (and (>= (length s) 4)                                                   (string= "Note"                                                            (subseq s 0 4))))                                          (with-open-file (notes-stream                                                           notes-file)                                            (do* ((sl nil)                                                  (line (read-line notes-stream nil nil)                                                        (read-line notes-stream nil nil)))                                                 ((null line)                                                  (reverse sl)                                                  )                                              (setf sl                                                    (cons (string-right-trim '(#\Space)                                                                             (if (eq #\Linefeed (char line 0)) (subseq line 1) line))                                                          sl))))))         (note-item-list (mapcar #'(lambda (s)                                     (do* ((next-start-pos 0)                                           (note-item nil)                                           (element nil))                                          ((>= next-start-pos (length s))                                           (cdr note-item))                                       (multiple-value-setq (element next-start-pos)                                         (read-from-string s nil nil :start next-start-pos))                                       (setf note-item (append note-item (list element)))))                                 note-string-list))         (sorted-note-item-list (sort (mapcar #'copy-list note-item-list)                                      #'(lambda (ni1 ni2)                                          (vector-less-than-p (list (first ni1)                                                                    (third ni1))                                                              (list (first ni2)                                                                    (third ni2))))))                  (sorted-opnd-m-dataset (sort (mapcar #'copy-list opnd-m-dataset)                                      #'(lambda (opnd-m-datapoint1                                                 opnd-m-datapoint2)                                          (vector-less-than-p (list (first opnd-m-datapoint1)                                                                    (first (pn2p (second opnd-m-datapoint1))))                                                              (list (first opnd-m-datapoint2)                                                                    (first (pn2p (second opnd-m-datapoint2))))))))         (sorted-midi-list-from-notes-file (mapcar #'third sorted-note-item-list))         (sorted-midi-list-from-opnd-m-file (mapcar #'(lambda (opnd-m-datapoint)                                                        (+ 21 (first (pn2p (second opnd-m-datapoint)))))                                                    sorted-opnd-m-dataset))         (dummy (if (equalp sorted-midi-list-from-notes-file                            sorted-midi-list-from-opnd-m-file)                  (format t "~%MIDI lists equal")                  (progn (format t "~%ERROR: MIDI lists not equal.")                         (abort))))         (list-of-onset-ratios (remove-if #'null (mapcar #'(lambda (note-onset opnd-m-onset)                                                             (unless (or (zerop note-onset)                                                                         (zerop opnd-m-onset))                                                               (* 1.0 (/ note-onset opnd-m-onset))))                                                         (mapcar #'first sorted-note-item-list)                                                         (mapcar #'first sorted-opnd-m-dataset))))         (mean-onset-ratio (let ((m (mean list-of-onset-ratios)))                             (format t "~%Mean onset ratio = ~,3f" m)                             m))         ;(sd-of-onset-ratios (let ((sd (standard-deviation list-of-onset-ratios)))         ;                      (format t "~%SD of onset ratios = ~,3f" sd)         ;                      sd))         (new-onsets (mapcar #'(lambda (old-onset)                                            (* 35 (round (/ (* mean-onset-ratio old-onset)                                                            35))))                                        (mapcar #'first sorted-opnd-m-dataset)))         (new-durations (mapcar #'(lambda (old-duration)                                               (* 35 (round (/ (* mean-onset-ratio old-duration)                                                               35))))                                           (mapcar #'third sorted-opnd-m-dataset)))         (new-offsets (mapcar #'+ new-durations new-onsets))         (new-list-of-note-strings (mapcar #'(lambda (onset offset midi)                                               (format nil "~%Note ~d ~d ~d" onset offset midi))                                           new-onsets                                           new-offsets                                           sorted-midi-list-from-notes-file))         (new-opnd-m-dataset (mapcar #'(lambda (new-onset new-duration opnd-m-datapoint)                                         (list new-onset                                               (second opnd-m-datapoint)                                               new-duration                                               (fourth opnd-m-datapoint)))                                     new-onsets                                     new-durations                                     sorted-opnd-m-dataset))         (new-notes-file (make-pathname :directory (pathname-directory new-notes-output-directory)                                               :name (pathname-name notes-file)                                               :type "nts"))         (new-opnd-m-file (make-pathname :directory (pathname-directory new-opnd-m-output-directory)                                                :name (pathname-name opnd-m-file)                                                :type "opnd-m")))    dummy    (with-open-file (new-notes-file-stream                     new-notes-file                     :direction :output                     :if-exists :rename-and-delete)      (mapcar #'(lambda (s)                  (format new-notes-file-stream s))              new-list-of-note-strings))    (with-open-file (new-opnd-m-file-stream                     new-opnd-m-file                     :direction :output                     :if-exists :rename-and-delete)      (pprint new-opnd-m-dataset new-opnd-m-file-stream))))(defun batch-multiply-onsets-and-durations (factor                                            &optional                                            (quantize nil)                                            (input-opnd-directory (choose-directory-dialog :button-string "OPND"))                                            (output-notes-directory (choose-directory-dialog :button-string "NOTES OUT"))                                            (output-opnd-directory (choose-directory-dialog :button-string "OPND OUT")))  (let* ((list-of-opnd-files (directory (make-pathname :directory (pathname-directory input-opnd-directory)                                                       :name :wild                                                       :type "opnd-m"))))    (mapcar #'(lambda (input-opnd-file)                (multiply-onsets-and-durations factor                                               quantize                                               input-opnd-file                                               output-notes-directory                                               output-opnd-directory))            list-of-opnd-files)))(defun multiply-onsets-and-durations (factor                                       &optional                                       (quantize nil)                                      (input-opnd-file (choose-file-dialog :button-string "OPND"))                                      (output-notes-directory (choose-directory-dialog :button-string "NOTES OUT"))                                      (output-opnd-directory (choose-directory-dialog :button-string "OPND OUT")))  (format t "~%~a..." (pathname-name input-opnd-file))  (let* ((sorted-input-opnd (sort-by-onset (read-dataset input-opnd-file)))         (new-onsets (mapcar #'(lambda (old-onset)                                 (if (not quantize)                                   (round (* factor old-onset))                                   (* 35 (round (/ (* factor old-onset)                                                   35)))))                             (mapcar #'first sorted-input-opnd)))         (new-durations (mapcar #'(lambda (old-duration)                                    (if (not quantize)                                      (round (* factor old-duration))                                      (* 35 (round (/ (* factor old-duration)                                                      35)))))                                (mapcar #'third sorted-input-opnd)))         (new-offsets (mapcar #'+ new-durations new-onsets))         (midi-list (mapcar #'pn2midi (mapcar #'second sorted-input-opnd)))         (new-list-of-note-strings (mapcar #'(lambda (onset offset midi)                                               (format nil "~%Note ~d ~d ~d" onset offset midi))                                           new-onsets                                           new-offsets                                           midi-list))         (output-opnd (mapcar #'(lambda (new-onset new-duration opnd-datapoint)                                  (list new-onset                                        (second opnd-datapoint)                                        new-duration                                        (fourth opnd-datapoint)))                              new-onsets                              new-durations                              sorted-input-opnd))         (new-notes-file (make-pathname :directory (pathname-directory output-notes-directory)                                               :name (pathname-name input-opnd-file)                                               :type "nts"))         (new-opnd-m-file (make-pathname :directory (pathname-directory output-opnd-directory)                                         :name (pathname-name input-opnd-file)                                         :type "opnd-m")))    (with-open-file (new-notes-file-stream                     new-notes-file                     :direction :output                     :if-exists :rename-and-delete)      (mapcar #'(lambda (s)                  (format new-notes-file-stream s))              new-list-of-note-strings))    (with-open-file (new-opnd-m-file-stream                     new-opnd-m-file                     :direction :output                     :if-exists :rename-and-delete)      (pprint output-opnd new-opnd-m-file-stream))    (format t "DONE")))(defun pn2midi (pn)  (if pn    (+ 21 (first (pn2p pn)))))#|Need to determine if number of nils in an output OPNDV file is equal to difference between number of TPCNote records in the nts file and number of datapoints in the input file.mh is OKmh2p: OKmhx5: OKmh2px5: OKmh…5: OK|#(defun compare-nils-with-missing-notes (&optional                                        (output-notes-file (choose-file-dialog :button-string "NOTES OUT"))                                        (input-opnd-file (choose-file-dialog :button-string "OPND IN"))                                        (output-opnd-file (choose-file-dialog :button-string "OPND OUT")))  (let* ((output-opnd (read-dataset output-opnd-file))         (input-opnd (read-dataset input-opnd-file))         (number-of-nils (count nil (mapcar #'second output-opnd)))         (number-of-datapoints-in-input-opnd (list-length input-opnd))         (number-of-datapoints-in-output-opnd (list-length output-opnd))         (tpc-string-list (remove-if-not #'(lambda (s)                                             (and (>= (length s) 7)                                                  (string= "TPCNote"                                                           (subseq s 0 7))))                                         (with-open-file (notes-stream                                                          output-notes-file)                                           (do* ((sl nil)                                                 (line (read-line notes-stream nil nil)                                                       (read-line notes-stream nil nil)))                                                ((null line)                                                 (reverse sl)                                                 )                                             (setf sl                                                   (cons (string-right-trim '(#\Space)                                                                            (if (eq #\Linefeed (char line 0)) (subseq line 1) line))                                                         sl))))))         (number-of-tpcnote-records (list-length tpc-string-list))         (number-of-missing-notes (- number-of-datapoints-in-input-opnd number-of-tpcnote-records)))    (format t "~%~a" (pathname-name input-opnd-file))    (format t "~%Number of nils = ~d" number-of-nils)    (format t "~%Number of TPCNote records in output file = ~d" number-of-tpcnote-records)    (format t "~%Number of datapoints in output OPND file = ~d" number-of-datapoints-in-output-opnd)    (format t "~%Number of datapoints in input OPND file = ~d" number-of-datapoints-in-input-opnd)    (format t "~%Number of missing notes = ~d" number-of-missing-notes)    (format t "~%Number of missing notes = number of nils: ~a" (= number-of-missing-notes number-of-nils))    (format t "~%~%")    (list (pathname-name input-opnd-file)          (= number-of-missing-notes number-of-nils)))) (defun batch-compare-nils-with-missing-notes (output-opnd-type                                              output-notes-type                                              &optional                                              (output-notes-directory (choose-directory-dialog :button-string "NOTES OUT"))                                              (input-opnd-directory (choose-directory-dialog :button-string "OPND IN"))                                              (output-opnd-directory (choose-directory-dialog :button-string "OPND OUT")))  (let* ((list-of-output-notes-files (directory (make-pathname :directory (pathname-directory output-notes-directory)                                                               :name :wild                                                               :type output-notes-type)))         (list-of-input-opnd-files (directory (make-pathname :directory (pathname-directory input-opnd-directory)                                                             :name :wild                                                             :type "opnd-m")))         (list-of-output-opnd-files (directory (make-pathname :directory (pathname-directory output-opnd-directory)                                                               :name :wild                                                               :type output-opnd-type))))    (mapcar #'(lambda (output-notes-file                       input-opnd-file                       output-opnd-file)                (if (and (string= (pathname-name output-notes-file)                                  (pathname-name output-opnd-file))                         (string= (pathname-name output-notes-file)                                  (pathname-name input-opnd-file)))                  (compare-nils-with-missing-notes output-notes-file                                                   input-opnd-file                                                   output-opnd-file)                  (progn (format t "~%ERROR: File names don't match.")                         (format t "~%Output notes file: ~a" output-notes-file)                         (format t "~%Input opnd file: ~a" input-opnd-file)                         (format t "~%Output opnd file: ~a" output-opnd-file)                         (abort))))            list-of-output-notes-files            list-of-input-opnd-files            list-of-output-opnd-files))  )(defun batch-compare-nts-with-orig-opnd-m (notes-file-type                                           orig-opnd-m-file-type                                           &optional                                           (notes-directory (choose-directory-dialog :button-string "nts"))                                           (opnd-m-directory (choose-directory-dialog :button-string "opnd-m")))  (let* ((list-of-nts-files (directory (make-pathname :directory (pathname-directory notes-directory)                                                      :name :wild                                                      :type notes-file-type)))         (list-of-opnd-m-files (directory (make-pathname :directory (pathname-directory opnd-m-directory)                                                         :name :wild                                                         :type orig-opnd-m-file-type))))    (mapcar #'compare-nts-with-orig-opnd-m            list-of-nts-files            list-of-opnd-m-files)))(defun compare-nts-with-orig-opnd-m (&optional (notes-file (choose-file-dialog :button-string "nts"))                                               (opnd-m-file (choose-file-dialog :button-string "opnd-m")))  (let* ((opnd-m-dataset (read-dataset opnd-m-file))         (note-string-list (remove-if-not #'(lambda (s)                                              (and (>= (length s) 4)                                                   (string= "Note"                                                            (subseq s 0 4))))                                          (with-open-file (notes-stream                                                           notes-file)                                            (do* ((sl nil)                                                  (line (read-line notes-stream nil nil)                                                        (read-line notes-stream nil nil)))                                                 ((null line)                                                  (reverse sl)                                                  )                                              (setf sl                                                    (cons (string-right-trim '(#\Space)                                                                             (if (eq #\Linefeed (char line 0)) (subseq line 1) line))                                                          sl))))))         (note-item-list (mapcar #'(lambda (s)                                     (do* ((next-start-pos 0)                                           (note-item nil)                                           (element nil))                                          ((>= next-start-pos (length s))                                           (cdr note-item))                                       (multiple-value-setq (element next-start-pos)                                         (read-from-string s nil nil :start next-start-pos))                                       (setf note-item (append note-item (list element)))))                                 note-string-list))         (sorted-note-item-list (sort (mapcar #'copy-list note-item-list)                                      #'(lambda (ni1 ni2)                                          (vector-less-than-p (list (first ni1)                                                                    (third ni1))                                                              (list (first ni2)                                                                    (third ni2))))))         (sorted-opnd-m-dataset (sort (mapcar #'copy-list opnd-m-dataset)                                      #'(lambda (opnd-m-datapoint1                                                 opnd-m-datapoint2)                                          (vector-less-than-p (list (first opnd-m-datapoint1)                                                                    (first (pn2p (second opnd-m-datapoint1))))                                                              (list (first opnd-m-datapoint2)                                                                    (first (pn2p (second opnd-m-datapoint2))))))))         (sorted-midi-list-from-notes-file (mapcar #'third sorted-note-item-list))         (sorted-midi-list-from-opnd-m-file (mapcar #'(lambda (opnd-m-datapoint)                                                        (+ 21 (first (pn2p (second opnd-m-datapoint)))))                                                    sorted-opnd-m-dataset)))    (equalp sorted-midi-list-from-notes-file            sorted-midi-list-from-opnd-m-file)))(defun batch-create-opnd-m-from-nts (notes-file-type                                     orig-opnd-m-file-type                                     &optional                                     (notes-directory (choose-directory-dialog :button-string "nts"))                                     (opnd-m-directory (choose-directory-dialog :button-string "opnd-m"))                                     (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (let* ((list-of-nts-files (directory (make-pathname :directory (pathname-directory notes-directory)                                                      :name :wild                                                      :type notes-file-type)))         (list-of-opnd-m-files (directory (make-pathname :directory (pathname-directory opnd-m-directory)                                                         :name :wild                                                         :type orig-opnd-m-file-type))))    (mapcar #'(lambda (notes-file                       opnd-m-file)                (if (string= (pathname-name notes-file)                             (pathname-name opnd-m-file))                  (progn (format t "~%~a..." (pathname-name notes-file))                         (create-opnd-m-from-nts notes-file                                                 opnd-m-file                                                 output-directory)                         (format t "DONE"))                  (progn (format t "~%File names not compatible.")                         (abort))))            list-of-nts-files            list-of-opnd-m-files)))(defun create-opnd-m-from-nts (&optional (notes-file (choose-file-dialog :button-string "nts"))                                         (opnd-m-file (choose-file-dialog :button-string "opnd-m"))                                         (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (let* ((opnd-m-dataset (read-dataset opnd-m-file))         (note-string-list (remove-if-not #'(lambda (s)                                              (and (>= (length s) 4)                                                   (string= "Note"                                                            (subseq s 0 4))))                                          (with-open-file (notes-stream                                                           notes-file)                                            (do* ((sl nil)                                                  (line (read-line notes-stream nil nil)                                                        (read-line notes-stream nil nil)))                                                 ((null line)                                                  (reverse sl)                                                  )                                              (setf sl                                                    (cons (string-right-trim '(#\Space)                                                                             (if (eq #\Linefeed (char line 0)) (subseq line 1) line))                                                          sl))))))         (note-item-list (mapcar #'(lambda (s)                                     (do* ((next-start-pos 0)                                           (note-item nil)                                           (element nil))                                          ((>= next-start-pos (length s))                                           (cdr note-item))                                       (multiple-value-setq (element next-start-pos)                                         (read-from-string s nil nil :start next-start-pos))                                       (setf note-item (append note-item (list element)))))                                 note-string-list))         (sorted-note-item-list (sort (mapcar #'copy-list note-item-list)                                      #'(lambda (ni1 ni2)                                          (vector-less-than-p (list (first ni1)                                                                    (third ni1))                                                              (list (first ni2)                                                                    (third ni2))))))         (sorted-opnd-m-dataset (sort (mapcar #'copy-list opnd-m-dataset)                                      #'(lambda (opnd-m-datapoint1                                                 opnd-m-datapoint2)                                          (vector-less-than-p (list (first opnd-m-datapoint1)                                                                    (first (pn2p (second opnd-m-datapoint1))))                                                              (list (first opnd-m-datapoint2)                                                                    (first (pn2p (second opnd-m-datapoint2))))))))         (sorted-midi-list-from-notes-file (mapcar #'third sorted-note-item-list))         (sorted-midi-list-from-opnd-m-file (mapcar #'(lambda (opnd-m-datapoint)                                                        (+ 21 (first (pn2p (second opnd-m-datapoint)))))                                                    sorted-opnd-m-dataset))         (initial-opnd-m-onset (apply #'min (mapcar #'first sorted-opnd-m-dataset)))         (initial-note-onset (apply #'min (mapcar #'first sorted-note-item-list))))    (dolist (note-item sorted-note-item-list)      (setf (first note-item) (- (first note-item) initial-note-onset)            (second note-item) (- (second note-item) initial-note-onset)))    (dolist (opnd-dp sorted-opnd-m-dataset)      (setf (first opnd-dp) (- (first opnd-dp) initial-opnd-m-onset)))    (if (equalp sorted-midi-list-from-notes-file                sorted-midi-list-from-opnd-m-file)      (let* ((new-opnd-m (mapcar #'(lambda (original-opnd-datapoint                                            note-item)                                     (list (first note-item)                                           (second original-opnd-datapoint)                                           (- (second note-item) (first note-item))                                           (fourth original-opnd-datapoint)))                                 sorted-opnd-m-dataset                                 sorted-note-item-list))             (new-opnd-file-name (make-pathname :directory (pathname-directory output-directory)                                                :name (pathname-name opnd-m-file)                                                :type "opnd-m")))        (with-open-file (new-opnd-stream                         new-opnd-file-name                         :direction :output                         :if-exists :rename-and-delete)          (pprint new-opnd-m new-opnd-stream)))      (format t "~%ERROR: MIDI lists not equal."))    ))(defun batch-compare-opndv-files-2 (opndv1-file-type                                    opndv2-file-type                                    &key                                    (opndv-directory-1 (choose-directory-dialog :button-string opndv1-file-type))                                    (opndv-directory-2 (choose-directory-dialog :button-string opndv2-file-type))                                    (verbose nil)                                    (file-prefix nil))  (let* ((opndv-file-list-1 (directory (make-pathname :directory (pathname-directory opndv-directory-1)                                                      :name (if file-prefix                                                              (concatenate 'string file-prefix "*")                                                              :wild)                                                      :type opndv1-file-type)))         (opndv-file-list-2 (directory (make-pathname :directory (pathname-directory opndv-directory-2)                                                      :name (if file-prefix                                                              (concatenate 'string file-prefix "*")                                                              :wild)                                                      :type opndv2-file-type))))    (mapcar #'(lambda (opndv-file1 opndv-file2)                (compare-opndv-files-2 opndv-file1 opndv-file2 :verbose verbose))             opndv-file-list-1            opndv-file-list-2)))(defun compare-opndv-files-2 (&optional                               (opndv-file-1 (choose-file-dialog :button-string "OPNDV1"))                              (opndv-file-2 (choose-file-dialog :button-string "OPNDV2"))                              &key                              (verbose nil))  (let* ((opndv1 (sort-by-onset (read-dataset opndv-file-1)))         (opndv2 (sort-by-onset (read-dataset opndv-file-2)))         (midi-list-1 (mapcar #'pn2midi (mapcar #'second opndv1)))         (midi-list-2 (mapcar #'pn2midi (mapcar #'second opndv2)))         (onset-list-1 (mapcar #'first opndv1))         (onset-list-2 (mapcar #'first opndv2)))    (cond ((equalp opndv1 opndv2)           (if verbose              (progn (format t "~%FILE 1: ~a" opndv-file-1)                    (format t "~%FILE 2: ~a" opndv-file-2)                    (format t "~%OPNDVs equal.~%")))           t)          ((and (equalp onset-list-1 onset-list-2)                (equalp midi-list-1 midi-list-2))           (format t "~%FILE 1: ~a" opndv-file-1)           (format t "~%FILE 2: ~a" opndv-file-2)           (format t "~%Onset and MIDI lists equal.~%" )           'onset-and-midi)          ((equalp midi-list-1 midi-list-2)           (format t "~%FILE 1: ~a" opndv-file-1)           (format t "~%FILE 2: ~a" opndv-file-2)           (format t "~%MIDI lists equal.~%")           'midi)          (t (format t "~%FILE 1: ~a" opndv-file-1)             (format t "~%FILE 2: ~a" opndv-file-2)             (format t "~%NOT EQUAL.~%")             nil))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; My own implementations of Temperley's pitch spelling algorithm#|Implementing TPR1=================``TPR 1 (Pitch Variance Rule). Prefer to label nearby events so that theyare close together on the line of fifths." (p.125)``Note that the rule applies to {\em nearby\/} events. If one measure containsa B$\sharp$ followed by an E$\sharp$, there is great pressure to spell the second event as E$\sharp$ rather than F; if the two events are widelyseparated in time, the pressure is much less." (p.125)So the effect of a note should decrease as it gets further away from the notebeing spelt.This suggests the possibility of using notes that follow and precede the notecurrently being spelt.``Any TPC representation has a ``center-of-gravity" (COG), a mean position of allthe events of the passage on the line of fifths; a spelling of all the pitch-eventsis preferred which minimizes the line-of-fifths distance between each event and thecenter of gravity. In statistical terms, a representation is sought which minimizesthe variance among events on the line of fifths. The COG is constantly being updated;the COG at any moment is a weighted average of all previous events, with more recentevents affecting it more. This ensures that the pressure for events to be located close [p.125]together on the line of fifths is greatest for events that are close together in time.One important parameter to be set here is the ``decay" value of the COG, determininghow quickly the pressure to locate two events close together decays as the events getfurther apart in time. Roughly speaking, it seems that the pressure is significant for intervalsof a few seconds, but decays for longer intervals." (p.126)Alternatively, could use relative time units rather than absolute ones.``We arbitrarily limit the possible spellings for pitches to a range of four cycles on the lineof fifths." (p.132)``To solve this problem, we make a heuristic assumption that the spellings of simultaneous pitches arealways within a twelve-step ``window" on the line of fifths. That is, we assume that A$\flat$ and G$\sharp$will never be present simultaneously---an assumption that seems to be virtually always correct in practice."(p.~132)``To apply the pitch variance rule (TPR 1), we calculate the pitch COGat each segment of the analysis. This involves taking the mean line-of-fifths position of all previous events, given their spellings in theanalysis. Events are weighted for their length; they are also weightedfor their recency according to an exponential function, as discussedabove."(p.~132)``Given the COG for a particular segment, we calculate the line-of-fifthsdistance of each pitch from the COG. Summing these distances for all pitcheswithin the segment provides a measure of their closeness to previous pitches;summing these scores for all segments gives a measure of the closeness of allevents in the piece to one another."(pp.~132--133)Input=====Assume input is a list of triples (o m d) in which each triple gives theonset o, the MIDI note number m, and the duration d of a note or sequenceof tied notes.Assume that the input is sorted so that the voices are interleaved (i.e., use sort-by-onset).Output======List of quadruples, (o m d t) where t is the tonal pitch class of the notein the input represented by (o m d). The order of the notes in the outputcorresponds to the order of the notes in the input.tpr1 function=============Tries to stick as close as possible to description in book, without using metricalstructure and without using absolute time values.For each note, calculates the COG of all previous notes, weighted for duration andrecency, then spells the current note so that it is as close as possible to thisCOG.Pitches limited to a range of 4 cycles on the line of fifths---which four cycles? From -24 to 34 in harmony program (that's actually 5 cycles!)Decay function for influence of previous notes is exponential.Spellings of simultaneous notes must be within 12-note region on LOF.Can spell all notes in a chord together so that they are all as close to the COGup to the previous chord, or can spell notes one at a time, updating COG for each note.In dm-tpr1-a, let's spell notes a chord at a time, rather than a note at a time.Interesting to know range of pitch names in test corpus on line of fifths.How do we initialize COG? Assume that it's D (i.e., TPC = 4). This agrees withfootnote 5, Chapter 5. Also agrees with Chew and Chen's initialization.How do we decide spelling when pitch name is 6 away from COG on LOF?This should be a switch parameter.Sum of recency weights when computing COGs must be one.Sum of duration weights must be 1.Spelling of notes within a particular chord bound to be within a 12-note windowbecause they are always within 6 of the current COG.Algorithm is O(n^2) because have to recalculate all weightings for all previous notesfor each new chord.|#(defun tpcmidi2pn (tpc midi-note)  (let* ((chromatic-pitch (compute-chromatic-pitch midi-note))         (morph (compute-morph tpc))         (inflection (compute-inflection tpc))         (morphetic-pitch (compute-morphetic-pitch chromatic-pitch morph inflection)))    (p-pn (list chromatic-pitch                morphetic-pitch))))(defun opndv2omdlist (sorted-opndv)  (mapcar #'(lambda (opndv-datapoint)              (list (first opndv-datapoint)                    (+ 21 (elt (pn2p (elt opndv-datapoint 1)) 0))                    (third opndv-datapoint)))          sorted-opndv))(defun omdtlist2opndv (sorted-omd-list                       output-omdt-list                       sorted-input-opndv-dataset)  (let* ((output-pitch-names-p1 (mapcar #'tpcmidi2pn                                         (mapcar #'fourth output-omdt-list)                                        (mapcar #'second sorted-omd-list)))         (output-pitch-names-rd2 (mapcar #'(lambda (pitch-name)                                             (pn-tran pitch-name "rd2"))                                         output-pitch-names-p1))         (output-pitch-names-fd2 (mapcar #'(lambda (pitch-name)                                             (pn-tran pitch-name "fd2"))                                         output-pitch-names-p1))         (input-pitch-names (mapcar #'second sorted-input-opndv-dataset))         (error-number-list (list                              ;number of errors for p1                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-p1))                             ;number of errors for rd2                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-rd2))                             ;number of errors for fd2                             (count nil (mapcar #'pitch-name-equal-p input-pitch-names output-pitch-names-fd2))                             ))         (pitch-names (elt                        (list output-pitch-names-p1                             output-pitch-names-rd2                             output-pitch-names-fd2)                       (position (apply #'min error-number-list)                                 error-number-list))))    (mapcar #'(lambda (opndv-datapoint pitch-name)                (append (list (first opndv-datapoint))                        (list pitch-name)                        (cddr opndv-datapoint)))            sorted-input-opndv-dataset            pitch-names)))(defun tpr1 (sorted-omd-list              cog2note-eq-six-option             recency-decay-function             max-tpc             min-tpc             &key             (window-size nil)             (for-temperley nil)             (meredith-tpr-1 nil))  (let (chord-list         number-of-chords        omdt-list-for-this-chord        output-omdt-list)    (setf chord-list (omd-list-to-chord-list sorted-omd-list))    (setf number-of-chords (list-length chord-list))    (setf output-omdt-list nil)    (dotimes (i number-of-chords)      (setf omdt-list-for-this-chord (spell-chord (elt chord-list i)                                                  output-omdt-list                                                  cog2note-eq-six-option                                                  recency-decay-function                                                  max-tpc                                                  min-tpc                                                  window-size                                                  for-temperley                                                  meredith-tpr-1))      (setf output-omdt-list            (append output-omdt-list                    omdt-list-for-this-chord)))    output-omdt-list))(defun spell-chord (chord                     omdt-list                    cog2note-eq-six-option                    recency-decay-function                    max-tpc                    min-tpc                    window-size                    for-temperley                    meredith-tpr-1)  (let (cog         tpc        omdt-for-this-omd        omdt-list-for-this-chord)    (setf cog (compute-cog chord                            omdt-list                           recency-decay-function                           window-size))    (if meredith-tpr-1       (setf cog (- cog 2)))    (setf omdt-list-for-this-chord nil)    (dotimes (i (list-length chord))      (setf tpc (compute-tpc (second (elt chord i))                             cog                             cog2note-eq-six-option                             max-tpc                             min-tpc))      (setf omdt-for-this-omd (append (elt chord i)                                      (if for-temperley (list cog))                                      (list tpc)))      (setf omdt-list-for-this-chord            (append omdt-list-for-this-chord                    (list omdt-for-this-omd))))    omdt-list-for-this-chord))(defun compute-tpc (midi-note-number                     cog                    cog2note-eq-six-option                    max-tpc                    min-tpc)  (let (tpc-class        cog-tpc-class        cog2note-lof-displacement        tpc)    (setf tpc-class (midi2tpc-class midi-note-number))    (setf cog-tpc-class (mod cog 12))    (setf cog2note-lof-displacement (- tpc-class cog-tpc-class))    (if (> cog2note-lof-displacement 6)      (setf tpc (round (- (+ cog cog2note-lof-displacement) 12)))      (if (< -6 cog2note-lof-displacement 6)        (setf tpc (round (+ cog cog2note-lof-displacement)))        (if (< cog2note-lof-displacement -6)          (setf tpc (round (+ (+ cog cog2note-lof-displacement) 12)))          (setf tpc (compute-tpc-for-cog2note-lof-disp-eq-six cog cog2note-eq-six-option)))))    (do ()        ((>= tpc min-tpc))      (setf tpc (+ 12 tpc)))    (do ()        ((<= tpc max-tpc))      (setf tpc (- tpc 12)))    tpc))(defun compute-tpc-for-cog2note-lof-disp-eq-six (cog cog2note-eq-six-option)  (if (eq cog2note-eq-six-option 'sharp)    (round (+ cog 6))    (if (eq cog2note-eq-six-option 'flat)      (round (- cog 6)))))(defun midi2tpc-class (midi)  (npc2tpc-class (mod midi 12)))(defun npc2tpc-class (npc)  (mod (+ 2 (* 7 npc)) 12))(defun compute-cog (chord                     omdt-list                    recency-decay-function                    window-size)  (let (cog        this-onset        recency-weights        duration-weights        n ;w        tpcs        window        win-start)    (if (null omdt-list)      (setf cog 4)      (if (eq recency-decay-function              'exponential)        (progn          (setf n (list-length omdt-list))          (setf this-onset (first (first chord)))          (if window-size            (setf win-start (max 0 (- n window-size))                  window (subseq omdt-list win-start))            (setf window omdt-list))          ;(setf w (list-length window))          (setf recency-weights (mapcar #'(lambda (omdt)                                            (/ 1 (- this-onset (first omdt))))                                        window))          (setf duration-weights (mapcar #'third window))          (setf tpcs (mapcar #'fourth window))          ;cog is weighted average of preceding tpcs (see http:/rkb.home.cern.ch/rkb/AN16pp/node296.html)          (setf cog (/ (apply #'+ (mapcar #'* tpcs duration-weights recency-weights))                       (apply #'+ (mapcar #'* duration-weights recency-weights))))          )))    cog))(defun omd-list-to-chord-list (omd-list)  (let (number-of-omds        chord-list)    (setf number-of-omds (list-length omd-list))    (setf chord-list nil)    (do* ((i 1 (1+ i))          (current-chord (list (first omd-list))))         ((= i number-of-omds)          (setf chord-list                (append chord-list                        (list current-chord))))      (if (= (first (first current-chord))             (first (elt omd-list i)))        (setf current-chord              (append current-chord                      (list (elt omd-list i))))        (progn           (setf chord-list                 (append chord-list                        (list current-chord)))          (setf current-chord                (list (elt omd-list i))))))    chord-list))(defun tpr1a (sorted-omd-list)  (tpr1 sorted-omd-list        'sharp        'exponential        34        -24))(defun tpr1a-m (sorted-omd-list)  (tpr1  sorted-omd-list        'sharp        'exponential        34        -24        :meredith-tpr-1 t))(defun tpr1b (sorted-omd-list)  (tpr1 sorted-omd-list        'sharp        'exponential        34        -24        :window-size 100))(defun tpr1c (sorted-omd-list)  (tpr1 sorted-omd-list        'sharp        'exponential        34        -24        :window-size 1000))(defun tpr1c-m (sorted-omd-list)  (tpr1 sorted-omd-list        'sharp        'exponential        34        -24        :window-size 1000        :meredith-tpr-1 t))(defun tpr1d (sorted-omd-list)  (tpr1 sorted-omd-list        'flat        'exponential        '34        '-24))(defun generate-parameter-files (&optional (parameter-directory (choose-directory-dialog :button-string "Parameters")))  (let* (parameters-file-name         i)    (setf i 0)    (dolist (pruning-cutoff (list 5 10))      (dolist (tpc-var-factor (list 0.3 3.0))        (dolist (har-var-factor (list 0.3 3.0))          (dolist (odp-linear-factor (list 1.0 3.0))            (dolist (odp-quadratic-factor (list 1.0 3.0))              (dolist (odp-constant (list 1.0 3.0))                (dolist (compat-factor (list 1.0 3.0))                  (dolist (sbp-weight (list 1.0 5.0))                    (dolist (sbp-constant (list 1.0 5.0))                      (dolist (half-life (list .5 3.0))                        (dolist (voice-leading-penalty (list .5 3))                          (dolist (voice-leading-time (list .5 1))                            (setf i (1+ i))                            (setf parameters-file-name                                  (make-pathname :directory (pathname-directory parameter-directory)                                                 :name (concatenate 'string                                                                    "params"                                                                    (format nil "~4,'0d" i))                                                 ))                            (with-open-file (parameters-stream                                             parameters-file-name                                             :direction :output)                              (format parameters-stream "verbosity=0pruning_cutoff = ~,1fcompat_values = -5.0 -5.0 -10.0 1.0 -3.0 -10.0 5.0 3.0 -10.0 -10.0 2.0 -10.0tpc_var_factor = ~,1fhar_var_factor = ~,1fodp_linear_factor = ~,1fodp_quadratic_factor = ~,1fodp_constant = ~,1fcompat_factor = ~,1fsbp_weight = ~,1fsbp_constant = ~,1fhalf_life = ~,1fvoice_leading_penalty = ~,1fvoice_leading_time = ~,1f"                                      pruning-cutoff                                      tpc-var-factor                                      har-var-factor                                      odp-linear-factor                                      odp-quadratic-factor                                      odp-constant                                      compat-factor                                      sbp-weight                                      sbp-constant                                      half-life                                      voice-leading-penalty                                      voice-leading-time))))))))))))))))#|(setf params-directory (choose-directory-dialog :button-string "Params"))(setf old-filename-list      (directory (make-pathname :directory (pathname-directory params-directory)                                :name "params*"))      dummy nil)(setf new-filename-list      (mapcar #'(lambda (old-filename)                  (make-pathname :directory (pathname-directory params-directory)                                 :name (substitute #\0 #\Space (pathname-name old-filename))))              old-filename-list)      dummy nil)(mapcar #'rename-file old-filename-list new-filename-list)(pathname-type (choose-file-dialog))Converting paramsXXXX.u.outm files to OPNDV files(setf original-opnd-m-file (choose-file-dialog))(setf output-directory (choose-directory-dialog))(setf list-of-notes-files (directory (make-pathname :directory (pathname-directory (choose-directory-dialog))                                                    :name "params3601*"                                                    :type "outm"))      dummy nil)(mapcar #'(lambda (notes-file)            (notes2opndv "outo"                         notes-file                         original-opnd-m-file                         output-directory))        list-of-notes-files)             |#(defstruct param-file-settings  param-file-name  number-of-errors  pruning_cutoff  tpc_var_factor  har_var_factor  odp_linear_factor  odp_quadratic_factor  odp_constant  compat_factor  sbp_weight  sbp_constant  half_life  voice_leading_penalty  voice_leading_time)(defun print-parameters (&optional (number-of-results nil)                                   (parameters-results (choose-file-dialog :button-string "Para Errs"))                                   (param-file-directory (choose-directory-dialog :button-string "Para Dir"))                                   )  (let* ((haydn-test-errors (read-dataset parameters-results))         (sorted-haydn-test-errors (sort haydn-test-errors #'< :key #'second))         (sorted-haydn-test-errors (if (null number-of-results)                                     sorted-haydn-test-errors                                     (subseq sorted-haydn-test-errors 0 number-of-results)))         (col-headings (list 'FN        ;'param-file-name                             'NOE 	;'number-of-errors                             'PRC	;'pruning_cutoff                             'tvf	;'tpc_var_factor                             'hvf	;'har_var_factor                             'olf	;'odp_linear_factor                             'oqf	;'odp_quadratic_factor                             'oc	;'odp_constant                             'cf	;'compat_factor                             'sw	;'sbp_weight                             'sc	;'sbp_constant                             'hl	;'half_life                             'vlp	;'voice_leading_penalty                             'vlt	;'voice_leading_time                             ))         (list-of-parameter-file-settings (mapcar #'(lambda (param-result)                                                      (let* ((param-file (make-pathname :directory (pathname-directory param-file-directory)                                                                                        :name (string (first param-result))                                                                                        :type :UNSPECIFIC))                                                             (param-file-settings (with-open-file (param-file-stream                                                                                                   param-file                                                                                                   :direction :input)                                                                                    (do* ((l (read-line param-file-stream nil nil)                                                                                             (read-line param-file-stream nil nil))                                                                                          (this-param-file-settings (make-param-file-settings))                                                                                          (this-param nil))                                                                                         ((null l)                                                                                          (copy-param-file-settings this-param-file-settings))                                                                                      (setf l (substitute #\Space #\= l))                                                                                      (setf this-param (convert-line-to-list l))                                                                                      (case (first this-param)                                                                                        (pruning_cutoff (setf (param-file-settings-pruning_cutoff this-param-file-settings)                                                                                                              (second this-param)))                                                                                        (tpc_var_factor (setf (param-file-settings-tpc_var_factor this-param-file-settings)                                                                                                              (second this-param)))                                                                                        (har_var_factor (setf (param-file-settings-har_var_factor this-param-file-settings)                                                                                                              (second this-param)))                                                                                        (odp_linear_factor (setf (param-file-settings-odp_linear_factor this-param-file-settings)                                                                                                              (second this-param)))                                                                                        (odp_quadratic_factor (setf (param-file-settings-odp_quadratic_factor this-param-file-settings)                                                                                                              (second this-param)))                                                                                        (odp_constant (setf (param-file-settings-odp_constant this-param-file-settings)                                                                                                              (second this-param)))                                                                                        (compat_factor (setf (param-file-settings-compat_factor this-param-file-settings)                                                                                                              (second this-param)))                                                                                        (sbp_weight (setf (param-file-settings-sbp_weight this-param-file-settings)                                                                                                              (second this-param)))                                                                                        (sbp_constant (setf (param-file-settings-sbp_constant this-param-file-settings)                                                                                                              (second this-param)))                                                                                        (half_life (setf (param-file-settings-half_life this-param-file-settings)                                                                                                              (second this-param)))                                                                                        (voice_leading_penalty (setf (param-file-settings-voice_leading_penalty this-param-file-settings)                                                                                                              (second this-param)))                                                                                        (voice_leading_time (setf (param-file-settings-voice_leading_time this-param-file-settings)                                                                                                              (second this-param)))))))                                                             )                                                        (setf (param-file-settings-param-file-name param-file-settings)                                                              (first param-result)                                                              (param-file-settings-number-of-errors param-file-settings)                                                              (second param-result))                                                        param-file-settings                                                        ))                                                  sorted-haydn-test-errors)))    (format t "~a		" (first col-headings))    (mapcar #'(lambda (col-heading)                (format t "~a	" col-heading))            (cdr col-headings))    (format t "~%")    (mapcar #'(lambda (parameter-file-settings)                (format t "~a	" (param-file-settings-param-file-name parameter-file-settings))                (format t "~a	" (param-file-settings-number-of-errors parameter-file-settings))                (format t "~a	" (param-file-settings-pruning_cutoff parameter-file-settings))                (format t "~a	" (param-file-settings-tpc_var_factor parameter-file-settings))                (format t "~a	" (param-file-settings-har_var_factor parameter-file-settings))                (format t "~a	" (param-file-settings-odp_linear_factor parameter-file-settings))                (format t "~a	" (param-file-settings-odp_quadratic_factor parameter-file-settings))                (format t "~a	" (param-file-settings-odp_constant parameter-file-settings))                (format t "~a	" (param-file-settings-compat_factor parameter-file-settings))                (format t "~a	" (param-file-settings-sbp_weight parameter-file-settings))                (format t "~a	" (param-file-settings-sbp_constant parameter-file-settings))                (format t "~a	" (param-file-settings-half_life parameter-file-settings))                (format t "~a	" (param-file-settings-voice_leading_penalty parameter-file-settings))                (format t "~a	" (param-file-settings-voice_leading_time parameter-file-settings))                (format t "~%"))            list-of-parameter-file-settings)    list-of-parameter-file-settings))(defun print-list-of-param-settings (list-of-parameter-file-settings)  (let* ((col-headings (list 'FN        ;'param-file-name                             'NOE 	;'number-of-errors                             'PRC	;'pruning_cutoff                             'tvf	;'tpc_var_factor                             'hvf	;'har_var_factor                             'olf	;'odp_linear_factor                             'oqf	;'odp_quadratic_factor                             'oc	;'odp_constant                             'cf	;'compat_factor                             'sw	;'sbp_weight                             'sc	;'sbp_constant                             'hl	;'half_life                             'vlp	;'voice_leading_penalty                             'vlt	;'voice_leading_time                             )))    (format t "~a		" (first col-headings))    (mapcar #'(lambda (col-heading)                (format t "~a	" col-heading))            (cdr col-headings))    (format t "~%")    (mapcar #'(lambda (parameter-file-settings)                (format t "~a	" (param-file-settings-param-file-name parameter-file-settings))                (format t "~a	" (param-file-settings-number-of-errors parameter-file-settings))                (format t "~a	" (param-file-settings-pruning_cutoff parameter-file-settings))                (format t "~a	" (param-file-settings-tpc_var_factor parameter-file-settings))                (format t "~a	" (param-file-settings-har_var_factor parameter-file-settings))                (format t "~a	" (param-file-settings-odp_linear_factor parameter-file-settings))                (format t "~a	" (param-file-settings-odp_quadratic_factor parameter-file-settings))                (format t "~a	" (param-file-settings-odp_constant parameter-file-settings))                (format t "~a	" (param-file-settings-compat_factor parameter-file-settings))                (format t "~a	" (param-file-settings-sbp_weight parameter-file-settings))                (format t "~a	" (param-file-settings-sbp_constant parameter-file-settings))                (format t "~a	" (param-file-settings-half_life parameter-file-settings))                (format t "~a	" (param-file-settings-voice_leading_penalty parameter-file-settings))                (format t "~a	" (param-file-settings-voice_leading_time parameter-file-settings))                (format t "~%"))            list-of-parameter-file-settings)))#|(setf list-of-73s (remove-if-not #'(lambda (param-settings)                                     (and (= (param-file-settings-number-of-errors param-settings) 73)))                                 list-of-parameter-settings))(setf list-of-hyp-73s (remove-if-not #'(lambda (param-settings)                                     (and (= (param-file-settings-pruning_cutoff param-settings) 10)                                          (= (param-file-settings-tpc_var_factor param-settings) 3)                                          (= (param-file-settings-har_var_factor param-settings) 3)                                          (= (param-file-settings-odp_quadratic_factor param-settings) 1)                                          (= (param-file-settings-odp_constant param-settings) 1)                                          (= (param-file-settings-compat_factor param-settings) 1)                                          (= (param-file-settings-sbp_weight param-settings) 5)                                          (= (param-file-settings-sbp_constant param-settings) 1)                                          (= (param-file-settings-half_life param-settings) .5)))                                 list-of-parameter-settings))(setf list-of-73-74s (remove-if-not #'(lambda (param-settings)                                     (and (<= (param-file-settings-number-of-errors param-settings) 74)))                                 list-of-parameter-settings))(setf list-of-low-errors (remove-if-not #'(lambda (param-settings)                                            (and (<= (param-file-settings-number-of-errors param-settings) 113)))                                        list-of-parameter-settings))(setf list-of-hyp-low-errors (remove-if-not #'(lambda (param-settings)                                            (and (= (param-file-settings-half_life param-settings) 0.5)                                                 (= (param-file-settings-tpc_var_factor param-settings) 3)))                                        list-of-parameter-settings))|#(defun temperley (sorted-omd-list                  &key                  (window-size 20)                  (min-tpc nil)                  (max-tpc nil)                  (list-of-weights '(1 1 1))                  (adjust-null-tpc3s nil)                  (use-tpr1-function nil)                  (cog2note-eq-six-option 'flat)                  (recency-decay-function 'exponential))  (let* ((number-of-notes (list-length sorted-omd-list))                  ; First we implement TPR 1 as simply as possible         ; Calculate average position on line of fifths         ; of all notes in preceding window.         ; In simplest version, start with COG = 4 (D) and then calculate         ; average of (up to) n preceding notes.         ; Spell each note so that it is as close as possible to the COG.         ; If it is six away, spell it so that it is six less than the COG         ; as this is only 4 below the tonic (i.e., minor third above tonic).         ; This process generates a suggested TPC for each note in the piece.         ; This process returns a list of omdct1 datapoints. Each omdct1 datapoint         ; has the format         ; (onset midi duration cog tpc1).                  (omdct1-list (if use-tpr1-function                        (tpr1 sorted-omd-list                              cog2note-eq-six-option                              recency-decay-function                              max-tpc                              min-tpc                              :window-size window-size                              :for-temperley t)                        (apply-tpr1 sorted-omd-list                                  window-size                                  min-tpc                                  max-tpc                                  number-of-notes)))                  ; Next we apply TPR 2. For each note, n, that is remote from its cog          ; (i.e., 4 or more steps away from it on the line of fifths (p.133))          ; we find out if there is a note, m,         ; such that         ; - the onset of m is the same as the offset of n; and         ; - m and n are 1 semitone apart.         ; If this is the case, a new tpc is suggested for n which is 5 away from          ; that of m.         ; This results in a new list in which element is an omdct1t2 datapoint:         ; (onset midi duration cog tpc1 tpc2)         ; tpc2 is tpc suggested by TPR 2. If TPR 2 does not apply, then tpc2 = tpc1.                  (omdct1t2-list (apply-tpr2 omdct1-list                                    number-of-notes))                  ; Now we have to apply TPR 3.         ; This rule states that we should prefer TPC spellings that result in good         ; harmonic representations (p.131). A good harmonic representation is one that         ; is good as defined by HPR 1 (p.149).         ; The output of this step is a list of omdct1t2t3 datapoints:         ; (onset midi duration cog tpc1 tpc2 tpc3)         ; tpc3 is the tpc suggested by (my implementation of) TPR 3. This may be the same         ; as tpc1 or tpc2                  (omdct1t2t3-list (apply-tpr3 omdct1t2-list                                      number-of-notes                                      adjust-null-tpc3s))                  ; Now we have to decide on the best tpc for each note. This is done by a voting system.         ; Each of the three suggested tpcs for each note is weighted according to the rule weights         ; to give the best tpc for that note.                  (list-of-best-tpcs (compute-best-tpc-for-each-note omdct1t2t3-list                                                            list-of-weights)))    (mapcar #'append            sorted-omd-list            (mapcar #'list list-of-best-tpcs))))(defun compute-best-tpc-for-each-note (omdct1t2t3-list                                       list-of-weights)  (mapcar #'(lambda (t1t2t3)              (let* ((tpc-set (remove-duplicates (copy-list t1t2t3)))                     (score-list (mapcar #'(lambda (tpc-in-set)                                             (apply #'+ (mapcar #'(lambda (tpc-in-note                                                                           weight)                                                                    (if (equalp tpc-in-set tpc-in-note)                                                                      weight                                                                      0))                                                                t1t2t3                                                                list-of-weights)))                                          tpc-set)))                ;(list                  (elt tpc-set (position (apply #'max score-list) score-list))                 ;t1t2t3                 ;tpc-set                 ;score-list)                 ))          (mapcar #'(lambda (omdct1t2t3)                      (last omdct1t2t3 3))                  omdct1t2t3-list)))(defun apply-tpr1 (sorted-omd-list                   window-size                   min-tpc                   max-tpc                   number-of-notes)    ; First we implement TPR 1 as simply as possible  ; Calculate average position on line of fifths  ; of all notes in preceding window.  ; In simplest version, start with COG = 4 (D) and then calculate  ; average of (up to) n preceding notes.  ; Spell each note so that it is as close as possible to the COG.  ; If it is six away, spell it so that it is six less than the COG  ; as this is only 4 below the tonic (i.e., minor third above tonic).  ; If min-tpc and max-tpc are not nil, then tpc must be between them.  ; This process generates a suggested TPC for each note in the piece.  ; This process returns a list of omdct1 datapoints. Each omdct1 datapoint  ; has the format  ; (onset midi duration cog tpc1).    (let* (                  ; First we compute a cog-tpc-list. This list         ; contains ordered pairs, (cog tpc). Each ordered pair         ; gives the cog and tpc suggested by TPR 1 for the note whose omd is         ; in the corresponding position in sorted-omd-list.                  (cog-tpc-list (let* ((ctl nil)                              (cog nil)                              (tpc nil)                              (midi-note-number nil))                         (dotimes (i number-of-notes (reverse ctl))                           (setf midi-note-number (second (elt sorted-omd-list i)))                                                      ; For each note, we first compute the cog which is 4 if it is the first                           ; note. Otherwise, it is the mean of the tpcs of the previous window-size                           ; elements in the cog-tpc-list.                                                      (setf cog (if (zerop i)                                        4                                       (mean (mapcar #'second                                                      (subseq ctl 0 (min window-size (list-length ctl)))))))                                                      ; Now we have to calculate the tpc for this note.                                                      (setf tpc (let (tpc-class                                           cog-tpc-class                                           cog2note-lof-displacement                                           tpc)                                                                              ; First we find the tpc-class corresponding to this midi                                       ; note number. This limits the possible tpcs to a set of                                       ; positions that are 12 steps apart along the line of fifths.                                                                              (setf tpc-class (midi2tpc-class midi-note-number))                                                                              ; Now we find the tpc-class of the cog for this note.                                                                              (setf cog-tpc-class (mod cog 12))                                                                              ; Now we find the displacement from the cog's tpc-class to                                       ; to the tpc-class for this note.                                                                              (setf cog2note-lof-displacement (- tpc-class cog-tpc-class))                                       (if (> cog2note-lof-displacement 6)                                                                                  ; If the displacement from the cog tpc-class to this note's tpc-class                                         ; is greater than 6, then we set the tpc of this note to be 12 less than                                         ; the cog plus the displacement from the cog tpc-class to the note's tpc-class.                                                                                  (setf tpc (round (- (+ cog cog2note-lof-displacement) 12)))                                                                                  ; If the displacement from the cog tpc-class to the note's tpc-class is greater than                                         ; -6 and less than 6, then the tpc is simply the cog plus the displacement from the                                          ; cog tpc-class to the note's tpc-class.                                                                                  (if (< -6 cog2note-lof-displacement 6)                                           (setf tpc (round (+ cog cog2note-lof-displacement)))                                                                                      ; If the displacement from the cog tpc-class to the note's tpc-class is less than -6,                                           ; then we set the tpc of this note to be 12 greater than the cog plus the displacement from                                           ; the cog tpc-class to the note's tpc-class.                                                                                      (if (< cog2note-lof-displacement -6)                                             (setf tpc (round (+ (+ cog cog2note-lof-displacement) 12)))                                                                                          ; Otherwise, the displacement from the cog's tpc-class to the note's tpc-class is 6.                                             ; In this case, the tpc is 6 less than the cog.                                                                                          (setf tpc (round (- cog 6))))))                                                                              ; Now we have to check that the tpc we've calculated lies between min-tpc and max-tpc. If it doesn't                                       ; then we adjust it appropriately.                                                                              (if min-tpc                                         (do ()                                             ((>= tpc min-tpc))                                           (setf tpc (+ 12 tpc))))                                       (if max-tpc                                         (do ()                                             ((<= tpc max-tpc))                                           (setf tpc (- tpc 12))))                                       tpc))                                                      ; Now we just update ctl                                                      (setf ctl (cons (list cog tpc)                                            ctl)))))         )    (mapcar #'append             sorted-omd-list            cog-tpc-list)))(defun apply-tpr2 (omdct1-list                   number-of-notes)    ; Next we apply TPR 2. For each note, n, that is remote from its cog   ; (i.e., 4 or more steps away from it on the line of fifths (p.133))   ; we find out if there is a note, m,  ; such that  ; - the onset of m is the same as the offset of n; and  ; - m and n are 1 semitone apart.  ; If this is the case, a new tpc is suggested for n which is 5 away from   ; that of m.  ; This results in a new list in which element is an omdct1t2 datapoint:  ; (onset midi duration cog tpc1 tpc2)  ; tpc2 is tpc suggested by TPR 2. If TPR 2 does not apply, then tpc2 = tpc1.    (let* ((tpc2-list (let* ((tl nil)                           (cog nil)                           (tpc1 nil)                           (tpc2 nil))                      (dotimes (i number-of-notes (reverse tl))                                                ; For each note, we first determine whether it is remote from its cog:                        (setf cog (fourth (elt omdct1-list i)))                        (setf tpc1 (fifth (elt omdct1-list i)))                        (setf tpc2 tpc1)                        (if (>= (abs (- cog tpc1)) 4)                                                    ; then tpc1 is remote from its cog                          (let* (                                 ; Now we have to find if there is a note that starts as the current note ends                                 ; which is 1 semitone away from the current note.                                                                  (this-note-offset (+ (first (elt omdct1-list i))                                                      (third (elt omdct1-list i))))                                 (this-note-midi (second (elt omdct1-list i)))                                 (found-note (do* ((j (1+ i) (1+ j))                                                   (found-note nil))                                                  ((or found-note                                                       (= j number-of-notes)                                                       (> (first (elt omdct1-list j))                                                          this-note-offset))                                                   found-note)                                               (if (and (= 1 (abs (- this-note-midi                                                                     (second (elt omdct1-list j)))))                                                        (= this-note-offset                                                           (first (elt omdct1-list j))))                                                 (setf found-note (elt omdct1-list j))))))                            (if found-note                              (if (= 1 (- this-note-midi (second found-note)))                                ; Then this-note-midi is 1 semitone above the found-note.                                ; So the tpc2 for this note should be 5 higher than that for the second note:                                (setf tpc2 (- (fifth found-note) 5))                                                                ; Then found-note is one semitone above this-note, so tpc2 is 5 above that of found-note.                                                                 (setf tpc2 (+ (fifth found-note) 5))                                ))))                        (setf tl (cons tpc2 tl))))))    (mapcar #'append            omdct1-list            (mapcar #'list tpc2-list))))(defun apply-tpr3 (omdct1t2-list                   number-of-notes                   &optional                   (adjust-null-tpc3s nil))  ; This function finds the spelling for each chord that results in the  ; `best harmonic representation' in accordance with HPR 1. If the pitch class set for a chord is  ; a subset of a transposition of the sequence u=<0,7,4,3,10,6,1>, then it can  ; be spelt without using any ornamental dissonances.    ; The first job is to find, for each chord, c, the best transposition of  ; u=<0,7,4,3,10,6,1>. We do this by taking the pitch class set of c, pcs(c),  ; and then getting a score for how well pcs(c) matches each of the transpositions  ; of u=<0,7,4,3,10,6,1>. A match with the nth element in u adds (8-n) to the score  ; for that transposition.    (let* ((list-of-all-chord-tone-vectors (let* ((l nil)                                                (all-chord-tone-vector (list 0 7 4 3 10 6 1)))                                           (dotimes (i 12 l)                                             (setf l                                                   (cons (mapcar #'(lambda (pc)                                                                     (mod (+ pc i) 12))                                                                 all-chord-tone-vector)                                                         l)))))         (chord-list (let* ((cl (list (list (copy-list (first omdct1t2-list)))))                            (current-onset (first (first omdct1t2-list))))                       (dolist (omd (cdr omdct1t2-list) (reverse (mapcar #'reverse cl)))                         (if (= (first omd)                                current-onset)                           (setf (first cl)                                 (cons (copy-list omd)                                       (first cl)))                           (setf cl                                 (cons (list (copy-list omd))                                       cl)                                 current-onset                                 (first omd))))))         (pcs-list (mapcar #'(lambda (chord)                               (mapcar #'(lambda (omdct1t2)                                           (mod (second omdct1t2) 12))                                       chord))                           chord-list))         (all-chord-tone-vector-score-lists (mapcar #'(lambda (pcs)                                                        (mapcar #'(lambda (all-chord-tone-vector)                                                                    (apply #'+ (mapcar #'(lambda (pc)                                                                                           (let* ((pos (position pc all-chord-tone-vector)))                                                                                             (if pos                                                                                               (- 7 pos)                                                                                               0)))                                                                                       pcs)))                                                                list-of-all-chord-tone-vectors))                                                    pcs-list))         (best-all-chord-tone-vector-list (mapcar #'(lambda (score-list)                                                      (elt list-of-all-chord-tone-vectors                                                           (position (apply #'max score-list)                                                                     score-list)))                                                  all-chord-tone-vector-score-lists))                  ; Now have to find best mapping of each pc-list onto a tpc-list.         ; For each chord, we take each note in turn and assume that either tpc1 or tpc2 is correct.         ; we then count how many notes in the chord are spelt correctly on this assumption. In order         ; to be spelt correctly, the tpc must be either tpc1 or tpc2.                  ; The following step returns a list of tpc sequences. Each tpc sequence, tpcs, in this list         ; corresponds to the pc sequence, pcs, in the corresponding position in pcs-list. Each tpc in         ; tpcs gives the best tpc for the pc in the corresponding position in pcs.                  (tpcs-list (mapcar #'(lambda (chord                                       pcs                                       best-all-chord-tone-vector)                                (do* ((number-of-notes-in-chord (list-length chord))                                      (best-tpcs nil)                                      (best-score nil)                                      (this-tpcs nil)                                      (score-for-this-tpcs nil)                                      (rel-chord-tone-lof-positions (list 0 1 4 -3 -2 -6 -5))                                      (abs-chord-tone-lof-positions-for-this-existing-tpc nil)                                      (pos-within-best-all-chord-tone-vector nil)                                                                            (note 0 (1+ note)))                                     ((= note number-of-notes-in-chord)                                      best-tpcs)                                  (dolist (existing-tpc (last (elt chord note) 2))                                                                        ; We now assume that existing-tpc is correct and work out what the tpcs of the                                    ; other notes in the chord should be on that assumption.                                                                        ;(pprint (list chord note existing-tpc))                                                                        (setf pos-within-best-all-chord-tone-vector                                          (position (elt pcs note) best-all-chord-tone-vector))                                                                        (if pos-within-best-all-chord-tone-vector                                      (progn (setf abs-chord-tone-lof-positions-for-this-existing-tpc                                                   (mapcar #'(lambda (rel-chord-tone-lof-pos)                                                               (+ existing-tpc                                                                  (- rel-chord-tone-lof-pos                                                                     (elt rel-chord-tone-lof-positions                                                                          pos-within-best-all-chord-tone-vector))))                                                           rel-chord-tone-lof-positions))                                             (setf this-tpcs                                                    (mapcar #'(lambda (pc)                                                               (let ((pos (position pc best-all-chord-tone-vector)))                                                                 (if pos                                                                   (elt abs-chord-tone-lof-positions-for-this-existing-tpc                                                                        pos))))                                                           pcs))                                                                                          ; Now we count how many of the tpcs in this-tpcs agree with the tpcs predicted by                                             ; TPRs 1 and 2.                                                                                          (setf score-for-this-tpcs                                                   (apply #'+                                                          (mapcar #'(lambda (tpc                                                                             omdct1t2)                                                                      (if (member tpc (last omdct1t2 2))                                                                        1 0))                                                                  this-tpcs                                                                  chord)))                                                                                          ; Now we compare score-for-this-tpcs with the best-score. If it is higher, then we reset                                             ; best-score and best-tpcs.                                                                                          (if (or (null best-score)                                                     (> score-for-this-tpcs best-score))                                               (setf best-score score-for-this-tpcs                                                     best-tpcs this-tpcs))))                                                                        )))                            chord-list                            pcs-list                            best-all-chord-tone-vector-list))                  ; Now we make tpcs-list a list of tpcs that corresponds to omdct1t2-list.                  (list-of-tpcs (apply #'append tpcs-list))         (omdct1t2t3-list (mapcar #'append                                  omdct1t2-list                                  (mapcar #'list list-of-tpcs))))    (if adjust-null-tpc3s      (dotimes (i number-of-notes)        (if (null (seventh (elt omdct1t2t3-list i)))          (progn ;(format t "~%Found null tpc3.")                 (setf (seventh (elt omdct1t2t3-list i))                       (sixth (elt omdct1t2t3-list i)))))))    omdct1t2t3-list))(defun temp02 (sorted-omd-list)  (temperley sorted-omd-list             :window-size 50))(defun temp03 (sorted-omd-list)  (temperley sorted-omd-list             :window-size 100))(defun temp04 (sorted-omd-list)  (temperley sorted-omd-list             :window-size 50             :max-tpc 34             :min-tpc -24))(defun temp05 (sorted-omd-list)  (temperley sorted-omd-list             :window-size 50             :list-of-weights '(1 0 0)))(defun temp06 (sorted-omd-list)  (temperley sorted-omd-list             :window-size 50             :list-of-weights '(0 1 0)))(defun temp07 (sorted-omd-list)  (temperley sorted-omd-list             :window-size 50             :list-of-weights '(0 0 1)             :adjust-null-tpc3s t))(defun temp08 (sorted-omd-list)  (temperley sorted-omd-list             :window-size nil             :list-of-weights '(0 1 0)             :use-tpr1-function t             :cog2note-eq-six-option 'sharp             :min-tpc -24             :max-tpc 34))