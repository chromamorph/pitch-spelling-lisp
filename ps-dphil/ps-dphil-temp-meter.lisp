#|ps-dphil-temp-meter.lispStarted: 2 March 2005.This is the Lisp implementation of the final version of the temp-meterprogram described in the dissertation.|#(defstruct measure  score  local-score  one-pip  two-pips-1  two-pips-2  best-beat-count  left-pip  right-pip  )(defstruct note  start  duration  ioi  rioi  effective-length  pitch  )(defstruct pnl-node  note  mark  weight  )(defstruct pip  pnl  score  base  higher-base  best-j  is-beat  is-first-beat  chord  nnotes  )(defstruct bl  score  best-back  pip  )(defvar *max-pitch*)(defvar *tactus-level*)(defvar *highest-level*)(defvar *low-levels*)(defvar *high-levels*)(defvar *number-of-levels*)(defvar *must-use-penalty*)(defvar *not-first-beat-penalty*)(defvar *prechord*)(defvar *number-of-chords*)(defvar *number-of-notes*)(defvar *number-of-pips*)(defvar *pip-array*)(defvar *pip-time*)(defvar *beat-interval-factor*)(defvar *note-factor*)(defvar *tactus-min*)(defvar *tactus-width*)(defvar *tactus-step*)(defvar *tactus-max*)(defvar *beat-slop*)(defvar *meter-change-penalty*)(defvar *raising-change-penalty*)(defvar *duple-bonus*)(defvar *max-effective-length*)(defvar *duration-augmentation*)(defvar *triple-bonus*)(defvar *note-bonus*)(defvar *highest-level-to-compute*)(defvar *lowest-level-to-compute*)(defvar *dummy*)(defvar *measure-array*)(defvar *number-of-measures*)(defvar *note-list*)(defvar *first-beat*)(defvar *min-pip*)(defvar *max-pip*)(defvar *bl-array*)(defvar *number-of-bls*)(defvar *sort-note-list-option*)(defun temp-meter (note-list prechord-list                   pip-time beat-interval-factor note-factor tactus-min tactus-max                   tactus-width tactus-step beat-slop meter-change-penalty                   raising-change-penalty duple-bonus triple-bonus note-bonus                   max-effective-length highest-level lowest-level duration-augmentation                   sort-note-list-option)  (let (level)    (initialize-meter-globals pip-time beat-interval-factor note-factor tactus-min tactus-max                              tactus-width tactus-step beat-slop meter-change-penalty                              raising-change-penalty duple-bonus triple-bonus note-bonus                              max-effective-length highest-level lowest-level duration-augmentation                              sort-note-list-option)    (build-note-list-from-input note-list prechord-list)        (pprint "GOT HERE 1")        (normalize-notes)    (pprint "GOT HERE 2")    (build-pip-array)    (pprint "GOT HERE 3")    (compute-tactus-level)    (pprint "GOT HERE 4")    (setf level *tactus-level*)    (pprint "GOT HERE 5")    (do ()        ((not (> level *lowest-level-to-compute*)))      (compute-lower-level level)      (setf level (1- level)))    (pprint "GOT HERE 6")    (setf level *tactus-level*)    (do ()        ((not (< level *highest-level-to-compute*)))            (format t "~%Level = ~d~%" level)            (compute-higher-level level)      (setf level (+ 1 level)))    (pprint "GOT HERE 7")    (adjust-notes)    (pprint "GOT HERE 8")    (compute-meter-output)))(defun initialize-meter-globals (pip-time beat-interval-factor note-factor tactus-min tactus-max                                 tactus-width tactus-step beat-slop meter-change-penalty                                 raising-change-penalty duple-bonus triple-bonus note-bonus                                 max-effective-length highest-level lowest-level duration-augmentation                                 sort-note-list-option)  (setf *max-pitch* 200)  (setf *tactus-level* 2)  (setf *highest-level* 4)  (setf *low-levels* *tactus-level*)  (setf *high-levels* (- *highest-level* *tactus-level*))  (setf *number-of-levels* (1+ *highest-level*))  (setf *must-use-penalty* 10000.0)  (setf *not-first-beat-penalty* 0.5)  (setf *pip-time* pip-time)  (setf *beat-interval-factor* beat-interval-factor)  (setf *note-factor* note-factor)  (setf *tactus-min* tactus-min)  (setf *tactus-max* tactus-max)  (setf *tactus-width* tactus-width)  (setf *tactus-step* tactus-step)  (setf *beat-slop* beat-slop)  (setf *meter-change-penalty* meter-change-penalty)  (setf *raising-change-penalty* raising-change-penalty)  (setf *duple-bonus* duple-bonus)  (setf *triple-bonus* triple-bonus)  (setf *note-bonus* note-bonus)  (setf *max-effective-length* max-effective-length)  (setf *highest-level-to-compute* (if highest-level                                     highest-level                                     *highest-level*))  (setf *lowest-level-to-compute* (if lowest-level                                    lowest-level                                    0))  (setf *duration-augmentation* (if duration-augmentation                                  duration-augmentation                                  0))  (setf *dummy* (make-pip))  (setf (pip-is-beat *dummy*) (make-list *number-of-levels*))  (setf (pip-is-first-beat *dummy*) (make-list *number-of-levels*))  (setf *first-beat* (make-list *number-of-levels*))  (setf *sort-note-list-option* sort-note-list-option))(defun build-note-list-from-input (note-list prechord-list)  (let (sorted-note-list        new-note        this-offset-time        last-time        j        finished)    (setf *prechord* (copy-list prechord-list))    (setf *number-of-chords* (list-length *prechord*))    (setf *note-list* nil)    (setf sorted-note-list (sort-note-list note-list))    (setf *number-of-notes* (list-length note-list))    (dotimes (i *number-of-notes*)      (setf new-note (make-note))      (setf (note-pitch new-note) (elt (elt sorted-note-list i) 2))      (setf (note-start new-note) (elt (elt sorted-note-list i) 0))      (setf (note-duration new-note) (- (elt (elt sorted-note-list i) 1)                                        (note-start new-note)))      (setf *note-list* (append *note-list* (list new-note))))    (setf last-time (+ (note-start (elt *note-list* 0))                       (note-duration (elt *note-list* 0))))    (do* ((i 1 (1+ i)))         ((= i *number-of-notes*))      (setf this-offset-time (+ (note-start (elt *note-list* i))                                (note-duration (elt *note-list* i))))      (if (> this-offset-time last-time)        (setf last-time this-offset-time)))    (dotimes (i *number-of-notes*)      (if (= i (1- *number-of-notes*))        (progn (setf (note-ioi (elt *note-list* i))                     (note-duration (elt *note-list* i)))               (setf (note-rioi (elt *note-list* i))                     (note-duration (elt *note-list* i))))        (progn           ; Following is modified version of calculating IOI that          ; prevents IOIs from being zero.                     (setf j (1+ i))          (setf finished nil)          (do ()              ((or finished                   (= j *number-of-notes*)))            (if (/= (note-start (elt *note-list* j))                    (note-start (elt *note-list* i)))              (setf (note-ioi (elt *note-list* i))                    (- (note-start (elt *note-list* j))                       (note-start (elt *note-list* i)))                    finished                    t)              (setf j (1+ j))))                    ; Following is modified version of calculating RIOI that          ; prevents RIOIs from being zero.          (setf j (1+ i))          (setf finished nil)          (do ()              ((or finished                   (= j *number-of-notes*)))            (if (and (/= (note-start (elt *note-list* j))                         (note-start (elt *note-list* i)))                     (same-register (note-pitch (elt *note-list* i))                                    (note-pitch (elt *note-list* j))))              (setf finished t)              (setf j (1+ j))))                    (if (= j *number-of-notes*)            (setf (note-rioi (elt *note-list* i))                  (- last-time (note-start (elt *note-list* i))))            (setf (note-rioi (elt *note-list* i))                  (- (note-start (elt *note-list* j))                     (note-start (elt *note-list* i))))))))    (dotimes (i *number-of-notes*)      (setf (note-effective-length (elt *note-list* i))            (max (note-duration (elt *note-list* i))                 (note-rioi (elt *note-list* i))))      (setf (note-effective-length (elt *note-list* i))            (min (* 1000 *max-effective-length*)                 (note-effective-length (elt *note-list* i))))            #|(format t "~%~d: ~12d~12d~12d"               i               (note-effective-length (elt *note-list* i))              (note-duration (elt *note-list* i))              (note-rioi (elt *note-list* i)))|#      )    ))(defun normalize-notes ()  (let (min-time)    (setf min-time (note-start (elt *note-list* 0)))    (do* ((i 1 (1+ i)))         ((= i *number-of-notes*))      (if (< (note-start (elt *note-list* i))             min-time)        (setf min-time (note-start (elt *note-list* i)))))    (dotimes (i *number-of-notes*)      (setf (note-start (elt *note-list* i))            (- (note-start (elt *note-list* i))               min-time)))))(defun build-pip-array ()  (let (last-time        pnl-node        this-offset-time        i)    (setf last-time (+ (note-start (elt *note-list* 0))                       (note-duration (elt *note-list* 0))))    (pprint "GOT HERE 2.1")     (dotimes (i *number-of-notes*)      (setf this-offset-time (+ (note-start (elt *note-list* i))                                (note-duration (elt *note-list* i))))      (if (> this-offset-time last-time)        (setf last-time this-offset-time)))    (setf *number-of-pips* (1+ (quantize last-time)))    (setf *pip-array* (let (pa)                        (dotimes (i *number-of-pips* pa)                          (setf pa (cons (make-pip)                                         pa)))))    (pprint "GOT HERE 2.2")    (dotimes (i *number-of-pips*)      (setf (pip-pnl (elt *pip-array* i))            nil)      (setf (pip-nnotes (elt *pip-array* i))            0)      (setf (pip-is-beat (elt *pip-array* i))            nil)      (setf (pip-is-first-beat (elt *pip-array* i))            nil)      (dotimes (j *number-of-levels*)        (setf (pip-is-beat (elt *pip-array* i))              (append (pip-is-beat (elt *pip-array* i))                      (list nil)))        (setf (pip-is-first-beat (elt *pip-array* i))              (append (pip-is-first-beat (elt *pip-array* i))                      (list nil)))))    (add-chords)    (pprint "GOT HERE 2.3")    (dotimes (k *number-of-notes*)      (setf i (quantize (note-start (elt *note-list* k))))      (setf pnl-node (make-pnl-node))      (setf (pnl-node-note pnl-node) k)      (setf (pnl-node-weight pnl-node) 1.0)      (setf (pip-pnl (elt *pip-array* i))            (cons pnl-node (pip-pnl (elt *pip-array* i))))      (setf (pip-nnotes (elt *pip-array* i))            (1+ (pip-nnotes (elt *pip-array* i)))))    (pprint "GOT HERE 2.4")    (do ((i 1 (1+ i)))        ((= i *number-of-pips*))      (if (and (pip-pnl (elt *pip-array* (1- i)))               (pip-pnl (elt *pip-array* i)))        (progn (setf (pip-pnl (elt *pip-array* (1- i)))                     (append (pip-pnl (elt *pip-array* (1- i)))                             (pip-pnl (elt *pip-array* i))))               (setf (pip-pnl (elt *pip-array* i))                     nil)               (setf (pip-nnotes (elt *pip-array* (1- i)))                     (+ (pip-nnotes (elt *pip-array* (1- i)))                        (pip-nnotes (elt *pip-array* i))))               (setf (pip-nnotes (elt *pip-array* i))                     0))))    (pprint "GOT HERE 2.5")    (dotimes (i *number-of-pips*)      (setf (pip-base (elt *pip-array* i))            (+ (base-score (pip-pnl (elt *pip-array* i))                           nil)               (pip-chord (elt *pip-array* i))))      (setf (pip-higher-base (elt *pip-array* i))            (+ (base-score (pip-pnl (elt *pip-array* i))                           t)               (pip-chord (elt *pip-array* i))))      (setf (pip-score (elt *pip-array* i))            nil))))(defun compute-tactus-level ()  (let (best-min        best-max        best-val        t-min        t-max        first-time        val)    (setf best-min 0)    (setf best-max 0)    (setf best-val 0)    (setf t-min *tactus-min*)    (setf t-max (* *tactus-min* *tactus-width*))    (setf first-time t)    (do ()        ((not (<= t-max *tactus-max*)))      (setf *min-pip* (dquantize t-min 0))      (setf *max-pip* (dquantize t-max 0))      (create-pip-score-arrays)      (compute-tactus-scores)      (setf val (evaluate-solution *tactus-level* nil))            (format t "~%Trying tactus level range [~5d, ~5d]. Score = ~8,3f~%"              (* *pip-time* *min-pip*)              (* *pip-time* *max-pip*)              val)            (if (or first-time              (> val best-val))        (setf best-val val              best-min *min-pip*              best-max *max-pip*))      (free-pip-score-arrays)      (setf t-max (* t-max *tactus-step*))      (setf t-min (* t-min *tactus-step*))      (setf first-time nil))    (setf *min-pip* best-min)    (setf *max-pip* best-max)    (create-pip-score-arrays)    (compute-tactus-scores)    (evaluate-solution *tactus-level* t)    ;(print-beats *tactus-level*)    (free-pip-score-arrays)))(defun compute-lower-level (base-level)  (let (new-level)    (setf new-level (1- base-level))        (format t "~%Computing level ~2d" new-level)        (build-measure-array base-level)    (compute-measure-scores)        (print-measures)        (insert-beats new-level)        (format t "~%Best group scores")    (print-measures)        (setf *measure-array* nil)))(defun compute-higher-level (base-level)  (let (new-level)    (setf new-level (1+ base-level))    (print "GOT HERE 6.1")    (build-bl-array base-level)    (print "GOT HERE 6.2")    (compute-higher-level-scores new-level)    (print "GOT HERE 6.3")    (evaluate-raised-solution new-level t)    (print "GOT HERE 6.4")        (print-raised-beats new-level)        (setf *bl-array* nil)))(defun adjust-notes ()  (let (xp)    (dotimes (pip *number-of-pips*)      (dotimes (note (list-length (pip-pnl (elt *pip-array* pip))))        (setf xp               (+ (quantize (+ (note-start (elt *note-list*                                                (pnl-node-note (elt (pip-pnl (elt *pip-array* pip))                                                                   note))))                              (note-duration (elt *note-list*                                                   (pnl-node-note (elt (pip-pnl (elt *pip-array* pip))                                                                      note))))))                 *duration-augmentation*))        (setf (note-start (elt *note-list*                                (pnl-node-note (elt (pip-pnl (elt *pip-array* pip))                                                   note))))              (* pip *pip-time*))        (if (< xp 0)          (setf xp 0))        (if (>= xp *number-of-pips*)          (setf xp (1- *number-of-pips*)))        (setf (note-duration (elt *note-list*                                   (pnl-node-note (elt (pip-pnl (elt *pip-array* pip))                                                      note))))              (* *pip-time* (- xp pip))))      (setf (pip-pnl (elt *pip-array* pip))            (clean-up-note-list pip)))))(defun compute-meter-output ()  (let (i        beat-list        this-note        onset        offset        midi-note        note-list)    (setf beat-list nil)    (dotimes (p *number-of-pips*)      (setf i (max-level p))      (if (>= i 0)        (setf beat-list (append beat-list (list (list (* p *pip-time*)                                                      i))))))    (setf note-list nil)    (dotimes (p *number-of-pips*)      (dotimes (n (list-length (pip-pnl (elt *pip-array* p))))        (setf this-note (elt *note-list* (pnl-node-note (elt (pip-pnl (elt *pip-array* p))                                                              n))))        (if (/= 0 (note-duration this-note))          (setf onset (note-start this-note)                offset (+ (note-start this-note)                          (note-duration this-note))                midi-note (note-pitch this-note)                note-list (append note-list (list (list onset offset midi-note)))))))    (list note-list beat-list)))(defun same-register (p1 p2)  (<= (abs (- p1 p2)) 9))(defun quantize (time)  (floor (+ (/ time *pip-time*)            0.5)))(defun add-chords ()  (dotimes (i *number-of-pips*)    (setf (pip-chord (elt *pip-array* i))          0))  (dotimes (i *number-of-chords*)    (setf (pip-chord (elt *pip-array* (quantize (elt *prechord* i))))          1)))(defun base-score (pnl higher-base)  (let (total        n        average-length)        (setf total 0)    (setf n 0)    (dotimes (i (list-length pnl))      (setf total            (+ total               (ms-to-sec (note-effective-length (elt *note-list* (pnl-node-note (elt pnl i)))))))      (setf n (1+ n)))    (if (= n 0)      0      (progn (setf average-length (* 1.0 (/ total n)))             (if higher-base               (setf average-length .5))                          #|(format t "~%~6,3f:" total)             (dotimes (i (list-length pnl))               (format t "	~5,3f"                        (note-effective-length (elt *note-list* (pnl-node-note (elt pnl i))))))|#             #|(format t "~%total = ~6,3f, n = ~d, average-length = ~6,3f, base-score returns ~8,3f"                      total n average-length                     (* *note-factor*                        (+ (* (sqrt n) average-length)                           *note-bonus*)))|#                          (* *note-factor*                (+ (* (sqrt n) average-length)                   *note-bonus*))))))(defun dquantize (time round)  (if (= round -1)    (floor (/ time *pip-time*))    (if (= round 1)      (ceiling (/ time *pip-time*))      (floor (+ 0.5 (/ time *pip-time*))))))(defun create-pip-score-arrays ()  (free-pip-score-arrays)  (dotimes (i *number-of-pips*)    (do ((j *min-pip* (1+ j)))        ((> j *max-pip*))      (setf (pip-score (elt *pip-array* i))            (append (pip-score (elt *pip-array* i))                    (list 0))))))(defun compute-tactus-scores ()  (dotimes (pip *number-of-pips*)    (do ((j *min-pip* (1+ j)))        ((> j *max-pip*))      (setf (elt (pip-score (elt *pip-array* pip))                 (- j *min-pip*))            (elt (best-score pip j nil) 0)))))(defun evaluate-solution (level compute-beats)  (let (best         best-j        best-pip        pip        score)    (setf best 0)    (setf best-j -1)    (setf best-pip -1)    (setf pip (1- *number-of-pips*))    (do ()        ((not (and (>= pip (- *number-of-pips* *max-pip*))                   (>= pip 0))))      (do ((j *min-pip* (1+ j)))          ((> j *max-pip*))        (setf score (elt (pip-score (elt *pip-array* pip))                         (- j *min-pip*)))        (if (or (= -1 best-pip)                (< best score))          (setf best score                best-j j                best-pip pip)))      (setf pip (1- pip)))    (if compute-beats      (label-beats best-pip best-j level))    best))(defun free-pip-score-arrays ()  (dotimes (pip *number-of-pips*)    (setf (pip-score (elt *pip-array* pip))          nil)))(defun build-measure-array (base-level)  (let (first-beat-pip        last-beat-pip        n-beats        av-pips-per-beat        first-pseudo-pip        last-pseudo-pip        m)    (setf first-beat-pip 0)    (setf last-beat-pip 0)    (setf (elt (pip-is-beat *dummy*) base-level) nil)    (setf (pip-base *dummy*) 0)    (setf (pip-pnl *dummy*) nil)    (setf n-beats 0)    (dotimes (pip *number-of-pips*)      (if (elt (pip-is-beat (elt *pip-array* pip)) base-level)        (progn (if (= 0 n-beats)                 (setf first-beat-pip pip))               (setf last-beat-pip pip)               (setf n-beats (1+ n-beats)))))    (setf av-pips-per-beat (floor (+ (/ (- last-beat-pip first-beat-pip)                                        (- n-beats 1))                                     0.5)))    (setf first-pseudo-pip first-beat-pip)    (if (> first-pseudo-pip 0)      (progn (setf first-pseudo-pip (- first-pseudo-pip av-pips-per-beat))             (if (>= first-pseudo-pip 0)               (setf first-pseudo-pip -1))))    (setf last-pseudo-pip last-beat-pip)    (if (< last-beat-pip (1- *number-of-pips*))      (progn (setf last-pseudo-pip (+ last-pseudo-pip av-pips-per-beat))             (if (<= last-pseudo-pip (1- *number-of-pips*))               (setf last-pseudo-pip *number-of-pips*))))    (setf *number-of-measures* 0)    (do ((pip (1+ first-pseudo-pip) (1+ pip)))        ((= pip last-pseudo-pip))      (if (elt (pip-is-beat (xpip pip)) base-level)        (setf *number-of-measures*              (1+ *number-of-measures*))))    (setf *number-of-measures*          (1+ *number-of-measures*))    (setf *measure-array*          (let (ma)            (dotimes (i *number-of-measures* ma)              (setf ma                    (cons (make-measure) ma)))))    (dotimes (i *number-of-measures*)      (setf (measure-score (elt *measure-array* i))            (let (s)              (dotimes (j 3 s)                (setf s (cons 0 s)))))      (setf (measure-local-score (elt *measure-array* i))            (let (s)              (dotimes (j 3 s)                (setf s (cons 0 s))))))    (setf m 0)    (setf (measure-left-pip (elt *measure-array* m))          first-pseudo-pip)    (do ((pip (1+ first-pseudo-pip) (1+ pip)))        ((= pip last-pseudo-pip))      (if (elt (pip-is-beat (xpip pip)) base-level)        (progn (setf (measure-right-pip (elt *measure-array* m))                     (setf (measure-left-pip (elt *measure-array* (1+ m)))                           pip))               (setf m (1+ m)))))    (setf (measure-right-pip (elt *measure-array* m))          last-pseudo-pip)    (dotimes (m *number-of-measures*)      (setf (measure-best-beat-count (elt *measure-array* m))            -1))))(defun compute-measure-scores ()  (dotimes (m *number-of-measures*)    (do ((n-beats 1 (1+ n-beats)))        ((= n-beats 3))      (compute-measure-score m n-beats)))  (do ((n-beats 1 (1+ n-beats)))      ((= n-beats 3))    (setf (elt (measure-score (elt *measure-array* 0)) n-beats)          (elt (measure-local-score (elt *measure-array* 0)) n-beats)))  (do ((m 1 (1+ m)))      ((= m *number-of-measures*))    (do ((xb 1 (1+ xb)))        ((= xb 3))      (setf (elt (measure-score (elt *measure-array* m)) xb)            (elt (best-beat-score m xb) 0)))))(defun insert-beats (new-level)  (let (best-score        base-level        m        bb        finished        new-b        score)    (setf best-score 0)    (setf base-level (1+ new-level))    (dotimes (pip *number-of-pips*)      (setf (elt (pip-is-beat (elt *pip-array* pip)) new-level)            (elt (pip-is-beat (elt *pip-array* pip)) base-level)))    (setf m (1- *number-of-measures*))    (setf bb -1)    (do ((n-beats 1 (1+ n-beats)))        ((= n-beats 3))      (setf score (elt (measure-score (elt *measure-array* m)) n-beats))      (if (or (= -1 bb)              (> score best-score))        (progn (setf bb n-beats)               (setf best-score score))))    (setf m (1- *number-of-measures*))    (setf finished nil)    (do ()        ((not (and (not finished)                   (>= m 0))))      (setf (measure-best-beat-count (elt *measure-array* m))            bb)      (if (= bb 1)        (if (or (< (measure-one-pip (elt *measure-array* m)) 0)                (>= (measure-one-pip (elt *measure-array* m)) *number-of-pips*))          (setf (elt (pip-is-beat *dummy*) new-level) t)          (setf (elt (pip-is-beat (elt *pip-array* (measure-one-pip (elt *measure-array* m))))                     new-level)                t))        (progn (if (or (< (measure-two-pips-1 (elt *measure-array* m)) 0)                       (>= (measure-two-pips-1 (elt *measure-array* m)) *number-of-pips*))                 (setf (elt (pip-is-beat *dummy*) new-level) t)                 (setf (elt (pip-is-beat (elt *pip-array* (measure-two-pips-1 (elt *measure-array* m))))                            new-level)                       t))               (if (or (< (measure-two-pips-2 (elt *measure-array* m)) 0)                       (>= (measure-two-pips-2 (elt *measure-array* m)) *number-of-pips*))                 (setf (elt (pip-is-beat *dummy*) new-level) t)                 (setf (elt (pip-is-beat (elt *pip-array* (measure-two-pips-2 (elt *measure-array* m))))                            new-level)                       t))))      (if (= m 0)        (setf finished t)        (progn (setf new-b (elt (best-beat-score m bb) 1))               (setf bb new-b)               (setf m (1- m))))))) (defun build-bl-array (base-level)  (let (i)    (setf *number-of-bls* 0)    (dotimes (pip *number-of-pips*)      (if (elt (pip-is-beat (elt *pip-array* pip)) base-level)        (setf *number-of-bls* (1+ *number-of-bls*))))        (pprint "GOT HERE 6.1.1")    (setf *bl-array*          (let (bla)            (dotimes (j *number-of-bls* bla)              (setf bla                    (cons (make-bl) bla)))))        (pprint "GOT HERE 6.1.2")    (dotimes (i *number-of-bls*)      (setf (bl-score (elt *bl-array* i))            (let (bls)              (dotimes (j 2 bls)                (setf bls (cons 0 bls))))))        (pprint "GOT HERE 6.1.3")    (setf i 0)    (dotimes (pip *number-of-pips*)      (if (elt (pip-is-beat (elt *pip-array* pip)) base-level)        (progn (setf (elt (bl-score (elt *bl-array* i)) 0)                     (setf (elt (bl-score (elt *bl-array* i)) 1)                           0))               (setf (bl-pip (elt *bl-array* i))                     pip)               (setf i (1+ i)))))        (format t "Here's the bl-array after buil-bl-array:")    (pprint (mapcar #'bl-pip *bl-array*))))(defun compute-higher-level-scores (current-level)  (let (score)                (dotimes (beat *number-of-bls*)                        (do ((back 2 (1+ back)))          ((= back 4))        (setf score (elt (best-raising-choice beat back (= current-level                                                           *highest-level*))                         0))        (setf (elt (bl-score (elt *bl-array* beat))                   (- back 2))              score)                ))        (format t "compute-higher-level-scores for current-level = ~d~%" current-level)    (pprint (mapcar #'bl-score *bl-array*))))(defun evaluate-raised-solution (level compute-beats)  (let (best        best-back        best-beat        beat        score        )    (setf best 0)    (setf best-back (setf best-beat -1))    (setf beat (1- *number-of-bls*))    (do ()        ((not (>= beat (- *number-of-bls* 3))))      (do ((back 2 (1+ back)))          ((= back 4))        (setf score (elt (bl-score (elt *bl-array* beat))                         (- back 2)))        (if (or (= best-back -1)                (< best score))          (setf best score                best-back back                best-beat beat)))      (setf beat (1- beat)))    (if compute-beats      (label-raise-beats best-beat best-back level))    best))(defun clean-up-note-list (pip)  (let (new-pnl        p1        p2        mark        dur1        dur2)    (dotimes (i (list-length (pip-pnl (elt *pip-array* pip))))      (setf (pnl-node-mark (elt (pip-pnl (elt *pip-array* pip)) i))            nil))    (dotimes (i (list-length (pip-pnl (elt *pip-array* pip))))      (dotimes (j (list-length (pip-pnl (elt *pip-array* pip))))        (setf p1 (note-pitch (elt *note-list* (pnl-node-note (elt (pip-pnl (elt *pip-array* pip)) i)))))        (setf p2 (note-pitch (elt *note-list* (pnl-node-note (elt (pip-pnl (elt *pip-array* pip)) j)))))        (setf mark (pnl-node-mark (elt (pip-pnl (elt *pip-array* pip)) j)))        (setf dur1 (note-duration (elt *note-list* (pnl-node-note (elt (pip-pnl (elt *pip-array* pip)) i)))))        (setf dur2 (note-duration (elt *note-list* (pnl-node-note (elt (pip-pnl (elt *pip-array* pip)) j)))))        (if (and (= p1 p2)                 (not mark)                 (/= i j)                 (>= dur2 dur1))          (setf (pnl-node-mark (elt (pip-pnl (elt *pip-array* pip)) i))                t))))    (setf new-pnl nil)    (dotimes (i (list-length (pip-pnl (elt *pip-array* pip))))      (if (not (pnl-node-mark (elt (pip-pnl (elt *pip-array* pip)) i)))        (setf new-pnl              (cons (elt (pip-pnl (elt *pip-array* pip)) i)                    new-pnl))))    new-pnl))(defun max-level (p)  (let (i        finished)    (setf i (1- *number-of-levels*))    (setf finished nil)    (do ()        ((not (and (>= i 0)                   (not finished))))      (if (elt (pip-is-beat (elt *pip-array* p)) i)        (setf finished t)        (setf i (1- i))))    i))(defun ms-to-sec (x)  (/ x 1000))(defun best-score (pip j use-higher-base)  (let (base        max        best-k        score)    (if use-higher-base      (setf base (pip-higher-base (elt *pip-array* pip)))      (setf base (pip-base (elt *pip-array* pip))))    (if (< (- pip j) 0)      (progn                #|(if (= (* pip *pip-time*) 3010)          (progn (format t "~%~%pip * pip_time = ~5d" (* pip *pip-time*))                 (format t "~%base = ~6,3f" base)                 (format t "~%ms_to_sec((tactus_min+tactus_max)/2) = ~6,3f"                         (ms-to-sec (/ (+ *tactus-min* *tactus-max*)                                   2)))                 (format t "~%best-score returns ~6,3f"                         (* base                            (sqrt (ms-to-sec (/ (+ *tactus-min* *tactus-max*)                                                2)))))))|#                (list (* base               (sqrt (ms-to-sec (/ (+ *tactus-min* *tactus-max*)                                   2))))            -1))      (progn (setf max 0)             (setf best-k -1)             (do ((k *min-pip* (1+ k)))                 ((> k *max-pip*))               (if (< (- pip j k) 0)                 (setf score (+ (elt (pip-score (elt *pip-array* (- pip j)))                                     (- k *min-pip*))                                (* base                                    (sqrt (ms-to-sec (/ (* (+ j j) *pip-time*)                                                       2))))))                 (setf score (+ (elt (pip-score (elt *pip-array* (- pip j)))                                     (- k *min-pip*))                                (- (deviation-penalty (* k *pip-time*) (* j *pip-time*)))                                (* base                                    (sqrt (ms-to-sec (/ (* (+ j k) *pip-time*)                                                       2)))))))               #|(if (= 3010 (* pip *pip-time*))                 (progn (format t "~%pip*pip_time = ~5d" (* pip *pip-time*))                        (format t "~%score = ~6,3f" score)                        (format t "~%pip_array[pip-j].score[nscore(k)] = ~6,3f"                                (elt (pip-score (elt *pip-array* (- pip j)))                                     (- k *min-pip*)))                        (format t "~%base = ~6,3f" base)                        (format t "~%sqrt(ms_to_sec((j+j)*pip_time)/2) = ~6,3f"                                (sqrt (ms-to-sec (/ (* (+ j j) *pip-time*)                                                       2))))                        (format t "~%(deviation-penalty (* k *pip-time*) (* j *pip-time*)) = ~6,3f"                                (deviation-penalty (* k *pip-time*) (* j *pip-time*)))                        (format t "~%(sqrt (ms-to-sec (/ (* (+ j k) *pip-time*) 2))) = ~6,3f"                                (sqrt (ms-to-sec (/ (* (+ j k) *pip-time*)                                                       2)))))                                  )|#                              (if (or (= -1 best-k)                       (< max score))                 (setf max score                       best-k k)))             (list max best-k)))))(defun label-beats (pip j level)  (do ((finished nil)       (k nil))      (finished)    (setf (elt (pip-is-beat (elt *pip-array* pip))               level)          t)    (setf (pip-best-j (elt *pip-array* pip))          j)    (if (< (- pip j) 0)      (setf (elt *first-beat* level) pip            finished t)      (setf k (elt (best-score pip j (= level *highest-level*)) 1)            pip (- pip j)            j k))))(defun xpip (pip)  (if (or (< pip 0)          (>= pip *number-of-pips*))    *dummy*    (elt *pip-array* pip)))(defun compute-measure-score (m n-beats)  (let (bp1        bp2        b-score        left        right        score        first        dev-pen-1        dev-pen-2)    (setf bp1 0          bp2 0          b-score 0          left (measure-left-pip (elt *measure-array* m))          right (measure-right-pip (elt *measure-array* m)))    (if (= n-beats 1)      (progn (setf first t)             (do ((pip1 (1+ left) (1+ pip1)))                 ((= pip1 right))               (setf score                     (+ (pip-base (xpip pip1))                        *duple-bonus*                        (- (deviation-penalty (* (- pip1 left) *pip-time*)                                              (* (- right pip1) *pip-time*)))))               (if (or first                       (> score b-score))                 (setf first nil                       bp1 pip1                       b-score score)))             (setf (measure-one-pip (elt *measure-array* m))                   bp1)             (if first               (setf (measure-one-pip (elt *measure-array* m))                     left)))      (progn (setf first t)             (do ((pip1 (1+ left) (1+ pip1)))                 ((= pip1 right))               (do ((pip2 (1+ pip1) (1+ pip2)))                   ((= pip2 right))                 (setf dev-pen-1 (deviation-penalty (* (- pip1 left) *pip-time*)                                                    (* (- pip2 pip1) *pip-time*)))                 (setf dev-pen-2 (deviation-penalty (* (- pip2 pip1) *pip-time*)                                                    (* (- right pip2) *pip-time*)))                 (setf score (+ (pip-base (xpip pip1))                                (pip-base (xpip pip2))                                (- dev-pen-1)                                (- dev-pen-2)))                 (if (or first (> score b-score))                   (setf first nil                         bp1 pip1                         bp2 pip2                         b-score score))))             (setf (measure-two-pips-1 (elt *measure-array* m))                   bp1)             (setf (measure-two-pips-2 (elt *measure-array* m))                   bp2)             (if first               (setf (measure-two-pips-1 (elt *measure-array* m))                     left                     (measure-two-pips-2 (elt *measure-array* m))                     left))))    (setf (elt (measure-local-score (elt *measure-array* m)) n-beats)          b-score)))(defun best-beat-score (m xb)  (let (best-y        best-score        score)    (setf best-y -1          best-score 0)    (do ((yb 1 (1+ yb)))        ((= yb 3))      (setf score 0)      (if (/= xb yb)        (setf score (- score *meter-change-penalty*)))      (setf score (+ score                     (elt (measure-local-score (elt *measure-array* m))                          xb)                     (elt (measure-score (elt *measure-array* (- m 1)))                          yb)))      (if (or (= -1 best-y)              (> score best-score))        (setf best-y yb              best-score score)))    (list best-score best-y)))(defun best-raising-choice (base-beat back use-higher-base)  (let (base        score        best-score        choice)    (if use-higher-base      (setf base (pip-higher-base (elt *pip-array* (bl-pip (elt *bl-array* base-beat)))))      (setf base (pip-base (elt *pip-array* (bl-pip (elt *bl-array* base-beat))))))    (if (< (- base-beat back) 0)      (progn (if (elt (pip-is-first-beat (elt *pip-array* (bl-pip (elt *bl-array* base-beat)))) 3)               (setf base (+ base .5)))             (list base -1))      (progn (setf best-score 0)             (do ((try 2 (1+ try)))                 ((= try 4))               (setf score (+ (* (+ 1 (* (- try 2) (1- *triple-bonus*)))                                 base)                              (elt (bl-score (elt *bl-array* (- base-beat back)))                                   (- try 2))))               (if (/= try back)                 (setf score (- score *raising-change-penalty*)))               (if (and (= try 2)                        (< best-score score))                 (setf best-score score                       choice try)))             (list best-score choice)))))(defun label-raise-beats (beat back level)  (let (k        finished)    (setf finished nil)    (do ()        (finished)      (setf (elt (pip-is-beat (elt *pip-array* (bl-pip (elt *bl-array* beat)))) level)            t)      (setf (bl-best-back (elt *bl-array* beat))            back)      (if (< (- beat back) 0)        (setf (elt (pip-is-first-beat (elt *pip-array* (bl-pip (elt *bl-array* beat)))) level)              t              finished              t)        (setf k (elt (best-raising-choice beat back (= level *highest-level*)) 1)              beat (- beat back)              back k)))))(defun deviation-penalty (x y)  (let (diff)    (setf diff (abs (- x y)))    (if (<= diff *beat-slop*)      0      (* *beat-interval-factor*         (ms-to-sec (- diff *beat-slop*))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun print-beats (level)  (let* (last-beat         delta)    (setf last-beat -1)    (dotimes (pip *number-of-pips*)      (if (elt (pip-is-beat (elt *pip-array* pip)) level)        (progn (if (= last-beat -1)                 (setf delta 0)                 (setf delta (* *pip-time* (- pip last-beat))))               (setf last-beat pip)               (format t "~%Beat at time ~5d (interval = ~5d) (cumulative score = ~6,3f)"                       (* pip *pip-time*)                        delta                       (elt (pip-score (elt *pip-array* pip))                            (- (pip-best-j (elt *pip-array* pip))                               *min-pip*))))))))(defun print-raised-beats (level)  (let (delta         pip)    (format t "Level = ~d" level)    (dotimes (beat *number-of-bls*)      (setf pip (bl-pip (elt *bl-array* beat)))      (if (elt (pip-is-beat (elt *pip-array* pip)) level)        (progn           (if (= 0 beat)            (setf delta 0)            (setf delta (* *pip-time* (- pip (bl-pip (elt *bl-array* (1- beat)))))))          (format t "~%(~d ~5d ~6,3f)"                  (* *pip-time* pip)                  delta                  (elt (bl-score (elt *bl-array* beat))                       (- (bl-best-back (elt *bl-array* beat)) 2))))))))(defun print-measures ()  (let* (mp)    (dotimes (m *number-of-measures*)      (setf mp (elt *measure-array* m))      (if (= -1 (measure-best-beat-count mp))        (format t "~%(~3d ~6d ~6d ~5,2f ~5,3f)"                m                (* *pip-time* (measure-left-pip mp))                (* *pip-time* (measure-right-pip mp))                (elt (measure-local-score mp) 1)                (elt (measure-local-score mp) 2))        (progn          (format t "~%(~3d ~6d ~6d ~2d"                  m                  (* *pip-time* (measure-left-pip mp))                  (* *pip-time* (measure-right-pip mp))                  (1+ (measure-best-beat-count mp)))          (if (= 1 (measure-best-beat-count mp))            (format t " ~6d" (* *pip-time* (measure-one-pip mp)))            (if (= 2 (measure-best-beat-count mp))              (format t " ~6d ~6d"                       (* *pip-time* (measure-two-pips-1 mp))                      (* *pip-time* (measure-two-pips-2 mp)))))          (format t " ~6,2f ~6,2f)"                  (elt (measure-local-score mp)                       (measure-best-beat-count mp))                  (elt (measure-score mp)                       (measure-best-beat-count mp))))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Following are my own functions(defun sort-note-list (note-list)  (sort note-list        (if (eq *sort-note-list-option* 'orig-comp-event)          #'(lambda (on-off-midi-1                     on-off-midi-2)              (< (first on-off-midi-1)                 (first on-off-midi-2)))          #'(lambda (on-off-midi-1                     on-off-midi-2)              (or (< (first on-off-midi-1)                     (first on-off-midi-2))                  (and (= (first on-off-midi-1)                          (first on-off-midi-2))                       (< (third on-off-midi-1)                          (third on-off-midi-2)))                  (and (= (first on-off-midi-1)                          (first on-off-midi-2))                       (= (third on-off-midi-1)                          (third on-off-midi-2))                       (< (second on-off-midi-1)                          (second on-off-midi-2))))))))(defun nts2onoffmidi (&optional (nts-file (choose-file-dialog :button-string "NTS")))  (with-open-file (nts-stream                   nts-file                   :direction :input)    (do ((l (read-line nts-stream nil nil)            (read-line nts-stream nil nil))         (onoffmidi nil))        ((null l)         (reverse onoffmidi))      ;(pprint l)      (if (string/= l "")        (setf onoffmidi              (cons (cdr (convert-line-to-list l))                    onoffmidi))))))(defun temp-meter-output2nts (temp-meter-output                              output-nts-file-name)  (with-open-file (output-stream                   output-nts-file-name                   :direction :output                   :if-exists :rename-and-delete)    (mapcar #'(lambda (beat)                (format output-stream                        "Beat~7d~3d~%"                        (first beat)                        (second beat)))            (second temp-meter-output))    (mapcar #'(lambda (note)                (format output-stream                        "Note~7d~7d~4d~%"                        (first note)                        (second note)                        (third note)))            (first temp-meter-output)))  output-nts-file-name)(defun run-temp-meter (output-file-type                       temp-meter-algorithm                       &optional (input-nts-file (choose-file-dialog :button-string "NTS IN"))                                 (output-directory (choose-directory-dialog :button-string "TM OUT")))  (let* ((note-list (nts2onoffmidi input-nts-file))         (temp-meter-output (funcall temp-meter-algorithm note-list))         (output-nts-file-name (make-pathname :directory (pathname-directory output-directory)                                              :name (pathname-name input-nts-file)                                              :type output-file-type)))    (temp-meter-output2nts temp-meter-output                           output-nts-file-name)))#|temp-meter-1============This function simulates the original meter program with the parameters setas in the parameters file.|#(defun temp-meter-1 (note-list)  (let* ((PRECHORD-LIST nil)         (PIP-TIME 35)         (BEAT-INTERVAL-FACTOR 3.0)         (NOTE-FACTOR 1.0)         (TACTUS-MIN 420)         (TACTUS-MAX 1600)         (TACTUS-WIDTH 1.8)         (TACTUS-STEP 1.1)         (BEAT-SLOP 35)         (METER-CHANGE-PENALTY 0.3)         (RAISING-CHANGE-PENALTY 3.0)         (DUPLE-BONUS 0.2)         (TRIPLE-BONUS 1.4)         (NOTE-BONUS 0.2)         (MAX-EFFECTIVE-LENGTH 1.0)         (HIGHEST-LEVEL nil)         (LOWEST-LEVEL nil)         (DURATION-AUGMENTATION nil)         (SORT-NOTE-LIST-OPTION 'orig-comp-event))    (temp-meter note-list prechord-list                pip-time beat-interval-factor note-factor tactus-min tactus-max                tactus-width tactus-step beat-slop meter-change-penalty                raising-change-penalty duple-bonus triple-bonus note-bonus                max-effective-length highest-level lowest-level duration-augmentation                sort-note-list-option)))#|temp-meter-2============Same as temp-meter-2 except that the note-list is sorted completely|#(defun temp-meter-2 (note-list)  (let* ((PRECHORD-LIST nil)         (PIP-TIME 35)         (BEAT-INTERVAL-FACTOR 3.0)         (NOTE-FACTOR 1.0)         (TACTUS-MIN 420)         (TACTUS-MAX 1600)         (TACTUS-WIDTH 1.8)         (TACTUS-STEP 1.1)         (BEAT-SLOP 35)         (METER-CHANGE-PENALTY 0.3)         (RAISING-CHANGE-PENALTY 3.0)         (DUPLE-BONUS 0.2)         (TRIPLE-BONUS 1.4)         (NOTE-BONUS 0.2)         (MAX-EFFECTIVE-LENGTH 1.0)         (HIGHEST-LEVEL nil)         (LOWEST-LEVEL nil)         (DURATION-AUGMENTATION nil)         (SORT-NOTE-LIST-OPTION 'complete))    (temp-meter note-list prechord-list                pip-time beat-interval-factor note-factor tactus-min tactus-max                tactus-width tactus-step beat-slop meter-change-penalty                raising-change-penalty duple-bonus triple-bonus note-bonus                max-effective-length highest-level lowest-level duration-augmentation                sort-note-list-option)))#|compare-temp-meter-with-orig============================This function takes an nts file output by the temp-meter function andcompares it with the output of the meter program.It generates two lists from each of the notes files being compared:a beat-list anda note-list.It doesn't matter if the notes in the note-list are in a different orderin the two files. In other words, it is a set comparison, not a sequencecomparison.|#(defun compare-temp-meter-with-orig-meter (&optional                                           (temp-meter-output-file (choose-file-dialog :button-string "TM OUT"))                                           (orig-meter-output-file (choose-file-dialog :button-string "MET OUT"))                                           (orig-meter-output-file-mac-directory (choose-directory-dialog :button-string "MAC DIR")))    (let* ((orig-meter-output-file-mac (unix2mac orig-meter-output-file                                               orig-meter-output-file-mac-directory))         (orig-beat-list (with-open-file (orig-meter-output-stream                                          orig-meter-output-file-mac                                          :direction :input)                           (do ((l (read-line orig-meter-output-stream nil nil)                                   (read-line orig-meter-output-stream nil nil))                                (bl nil))                               ((null l)                                (reverse bl))                             (if (string= "Beat" (subseq l 0 4))                               (setf bl                                     (cons l bl))))))         (temp-meter-beat-list (with-open-file (temp-meter-output-stream                                                temp-meter-output-file                                                :direction :input)                                 (do ((l (read-line temp-meter-output-stream nil nil)                                         (read-line temp-meter-output-stream nil nil))                                      (bl nil))                                     ((null l)                                      (reverse bl))                                   (if (string= "Beat" (subseq l 0 4))                                     (setf bl                                           (cons l bl))))))         (orig-note-list (with-open-file (orig-meter-output-stream                                              orig-meter-output-file-mac                                              :direction :input)                               (do ((l (read-line orig-meter-output-stream nil nil)                                       (read-line orig-meter-output-stream nil nil))                                    (nl nil))                                   ((null l)                                    (reverse nl))                                 (if (string= "Note" (subseq l 0 4))                                   (setf nl                                         (cons l nl))))))         (sorted-orig-note-list (sort (copy-list orig-note-list)                                      #'string<))         (temp-meter-note-list (with-open-file (temp-meter-output-stream                                                temp-meter-output-file                                                :direction :input)                                 (do ((l (read-line temp-meter-output-stream nil nil)                                         (read-line temp-meter-output-stream nil nil))                                      (nl nil))                                     ((null l)                                      (reverse nl))                                   (if (string= "Note" (subseq l 0 4))                                     (setf nl                                           (cons l nl))))))         (sorted-temp-meter-note-list (sort (copy-list temp-meter-note-list)                                            #'string<)))    (format t "~%File 1: ~a" temp-meter-output-file)    (format t "~%File 2: ~a" orig-meter-output-file)    (if (equalp  orig-beat-list                 temp-meter-beat-list)      (format t "~%Unsorted beat lists are equalp.")      (format t "~%Unsorted beat lists are NOT equalp."))    (if (equalp orig-note-list                temp-meter-note-list)      (format t "~%Unsorted note lists are equalp.")      (format t "~%Unsorted note lists are NOT equalp"))    (if (equalp sorted-orig-note-list                sorted-temp-meter-note-list)      (progn (format t "~%Sorted note lists are equalp.")             t)      (progn (format t "~%Sorted note lists are NOT equalp.")             nil))    ))(defun run-tm-and-compare-output (output-file-type                                  temp-meter-algorithm                                  &optional                                  (input-nts-file                                   (choose-file-dialog :button-string "NTS INPUT"))                                  (temp-meter-output-directory                                   (choose-directory-dialog :button-string "TM OUT"))                                  (orig-meter-output-directory                                   (choose-directory-dialog :button-string "ORIG OUT"))                                  (orig-meter-output-directory-mac                                   (choose-directory-dialog :button-string "ORIG OUT MAC")))  (let* ((temp-meter-output-file (run-temp-meter output-file-type                                                 temp-meter-algorithm                                                 input-nts-file                                                 temp-meter-output-directory))         (orig-meter-output-file (make-pathname :directory (pathname-directory orig-meter-output-directory)                                                :name (pathname-name temp-meter-output-file)                                                :type "ntsu")))    (compare-temp-meter-with-orig-meter temp-meter-output-file                                        orig-meter-output-file                                        orig-meter-output-directory-mac)))(defun compare-beat-list-note-list-files (&optional                                          (file1 (choose-file-dialog :button-string "File1"))                                          (file2 (choose-file-dialog :button-string "File2")))  (let* ((file1-beat-list (with-open-file (file1-stream                                           file1                                           :direction :input)                            (do ((l (read-line file1-stream nil nil)                                    (read-line file1-stream nil nil))                                 (bl nil))                                ((null l)                                 (reverse bl))                              (if (string= "Beat" (subseq l 0 4))                                (setf bl                                      (cons l bl))))))         (file2-beat-list (with-open-file (file2-stream                                           file2                                           :direction :input)                            (do ((l (read-line file2-stream nil nil)                                    (read-line file2-stream nil nil))                                 (bl nil))                                ((null l)                                 (reverse bl))                              (if (string= "Beat" (subseq l 0 4))                                (setf bl                                      (cons l bl))))))         (file1-note-list (with-open-file (file1-stream                                           file1                                           :direction :input)                            (do ((l (read-line file1-stream nil nil)                                    (read-line file1-stream nil nil))                                 (bl nil))                                ((null l)                                 (reverse bl))                              (if (string= "Note" (subseq l 0 4))                                (setf bl                                      (cons l bl))))))         (file2-note-list (with-open-file (file2-stream                                           file2                                           :direction :input)                            (do ((l (read-line file2-stream nil nil)                                    (read-line file2-stream nil nil))                                 (bl nil))                                ((null l)                                 (reverse bl))                              (if (string= "Note" (subseq l 0 4))                                (setf bl                                      (cons l bl))))))         (sorted-file1-note-list (sort (copy-list file1-note-list) #'string<))         (sorted-file2-note-list (sort (copy-list file2-note-list) #'string<)))    (format t "~%File 1: ~a" file1)    (format t "~%File 2: ~a" file2)    (if (equalp  file1-beat-list                 file2-beat-list)      (format t "~%Unsorted beat lists are equalp.")      (format t "~%Unsorted beat lists are NOT equalp."))    (if (equalp file1-note-list                file2-note-list)      (format t "~%Unsorted note lists are equalp.")      (format t "~%Unsorted note lists are NOT equalp"))    (if (equalp sorted-file1-note-list                sorted-file2-note-list)      (format t "~%Sorted note lists are equalp.")      (format t "~%Sorted note lists are NOT equalp."))    (and (equalp  file1-beat-list                  file2-beat-list)         (equalp sorted-file1-note-list                 sorted-file2-note-list))))