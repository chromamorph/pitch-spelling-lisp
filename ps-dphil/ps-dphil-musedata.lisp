;musedata.lisp;;;;;;;;;;;;;;;musedata-to-opnd.lisp;;;;;;;;;;;;;;;;;;;;;;;Copyright © 2002 by David Meredith. All rights reserved.#|The musedata-to-opnd function reads a musedata score fileand returns an OPND file. The function assumes that themusedata file does not contain transposing instruments.The first stage is to convert the musedata file into a listof records(onset-time tied-note chord-note pitch-name rest voice duration)2003-06-30==========Modification of function to convert to MEF.|#(setf *save-local-symbols* t);(load #P"hd:Users:dave:Documents:Lisp:programs:opnd2opd.lisp");(load #P"hd:Users:dave:Documents:Lisp:programs:opd2midi.lisp");(load #P"hd:Users:dave:Documents:Lisp:programs:mips2asa.lisp")(defvar *file-name* nil) (defvar *musedata-alist-lists* nil)(setf *musedata-alist-lists* nil)(setf *MINIMUM-STACK-OVERFLOW-SIZE*      2048000)(defun parse-musedata (&optional (auto-file-find nil)                                  (use-s-files nil)                                 (musedata-directory (choose-directory-dialog))                                 )  (let* (;Select input files.         ;;;;;;;;;;;;;;;;;;;;         (complete-musedata-file-list (directory (make-pathname :directory (pathname-directory musedata-directory)                                                                :name :wild                                                                :type :wild)))         (complete-musedata-file-name-list (mapcar #'pathname-name                                                   complete-musedata-file-list))         (musedata-file-list          (if auto-file-find            (let* ((filelist (remove-if-not #'(lambda (filename)                                                (if use-s-files                                                  (and (> (length filename) 1)                                                       (eq #\s (char filename 0))                                                       (every #'digit-char-p (subseq filename 1)))                                                  (every #'digit-char-p filename)))                                            complete-musedata-file-name-list))                   (number-list (mapcar #'(lambda (filename)                                            (let* ((i (read-from-string (if use-s-files                                                                          (subseq filename 1)                                                                          filename)                                                                         nil                                                                        nil)))                                              (if (integerp i)                                                i)))                                        filelist))                   (number-list (if (every #'integerp number-list)                                  number-list                                  nil))                   (number-list (sort number-list #'<))                   (comparison-number-list (let* ((cl nil))                                             (dotimes (i (list-length number-list) cl)                                               (setf cl (append cl (list (1+ i))))))))              (if (equalp comparison-number-list number-list)                filelist                (progn (format t "ERROR!! Unable to auto-find musedata file list.~%~%")                       (throw 'throw-tag nil))))            (select-item-from-list complete-musedata-file-name-list                                   :selection-type :disjoint)))         (musedata-file-list          (mapcar #'(lambda (filename)                      (find filename complete-musedata-file-list                            :test #'equalp                            :key #'pathname-name))                  musedata-file-list))                           ;Construct a list of musedata-string-lists, each musedata-string-list containing         ;all the records in one of the files in musedata-file-list. The strings must be         ;ordered within each musedata-string-list in the order in which the records occur in         ;the musedata file. The order in which the musedata-string-lists occur corresponds to         ;the order in which the file names occur in musedata-file-list.                  ;In each musedata-string-list, each element is an a-list containing two conses whose keys         ;are LINE-NUMBER and STRING.         (original-musedata-string-lists          (mapcar #'(lambda (musedata-file-name)                      (with-open-file (musedata-file-stream                                       musedata-file-name)                        (do* ((index 1 (1+ index))                              (msl nil)                              (line (read-line musedata-file-stream nil nil)                                    (read-line musedata-file-stream nil nil)))                             ((null line)                              ;(remove "" msl :test #'equalp)                              ;Can't do this - see, e.g., Record 8 in Mozart K423, Movement 1                              msl                              )                          (setf msl                                (append msl                                        (list (pairlis '(line-number string)                                                       (list index (string-right-trim '(#\Space)                                                                                      (if (eq #\Linefeed (char line 0)) (subseq line 1) line))))))))))                  musedata-file-list))                  ;Remove all comments (both single-line (@) and multi-line (&...&)) and store them in a list of comment-alist-lists, each         ;comment-alist-list containing all the comments in a particular musedata-string-list. Each comment is represented by          ;an a-list containing pairs whose keywords are type, string, line-number.                  ;First we build the comment-alist-lists. This contains Print suggestions, comments and footnotes (i.e., lines that come         ;after a /FINE command).         (comment-alist-lists          (mapcar #'(lambda (musedata-string-list)                      (do* ((footnote-on nil)                            (multi-line-comment-on nil)                            (i 0 (1+ i))                            (comment-alist-list nil)                            (musedata-string nil))                           ((= i (list-length musedata-string-list))                            comment-alist-list)                        (setf musedata-string (val 'string (elt musedata-string-list i)))                        (cond ((and (>= (length musedata-string) 5)                                    (string= "/FINE" (subseq musedata-string 0 5)))                               (setf footnote-on t))                              ((and (>= (length musedata-string) 4)                                    (string= "/END" (subseq musedata-string 0 4)))                               (setf footnote-on nil))                              (footnote-on                               (setf comment-alist-list (append comment-alist-list                                                                (list (acons 'type                                                                             'footnote                                                                             (elt musedata-string-list i))))))                              ((and (null multi-line-comment-on)                                    (> (length musedata-string) 0)                                    (eq #\& (char musedata-string 0)))                               (setf multi-line-comment-on t                                     comment-alist-list (append comment-alist-list                                                                (list (acons 'type                                                                             'comment                                                                             (elt musedata-string-list i))))))                              ((and multi-line-comment-on                                    (> (length musedata-string) 0)                                    (eq #\& (char musedata-string 0)))                               (setf multi-line-comment-on nil                                     comment-alist-list (append comment-alist-list                                                                (list (acons 'type                                                                             'comment                                                                             (elt musedata-string-list i))))))                              (multi-line-comment-on                               (setf comment-alist-list (append comment-alist-list                                                                (list (acons 'type                                                                             'comment                                                                             (elt musedata-string-list i))))))                              ((and (> (length musedata-string) 0)                                    (eq #\@ (char musedata-string 0)))                               (setf comment-alist-list (append comment-alist-list                                                                (list (acons 'type                                                                             'comment                                                                             (elt musedata-string-list i))))))                              ((and (> (length musedata-string) 0)                                    (eq #\P (char musedata-string 0))                                    (eq #\Space (char musedata-string 1)))                               (setf comment-alist-list (append comment-alist-list                                                                (list (acons 'type                                                                             'print-suggestion                                                                             (elt musedata-string-list i))))))                              )))                  original-musedata-string-lists))                  ;...then we remove the comments from musedata-string-lists         (musedata-string-lists          (mapcar #'(lambda (musedata-string-list comment-alist-list)                      (let (msl)                        (dolist (musedata-string musedata-string-list msl)                          (unless (member musedata-string comment-alist-list :test #'equalp)                            (setf msl                                  (append msl (list musedata-string)))))))                  original-musedata-string-lists                  (mapcar #'(lambda (comment-alist-list)                              (mapcar #'cdr comment-alist-list))                          comment-alist-lists)))                  ;Construct a list of musedata-alist-lists, each musedata-alist-list containing         ;all the records in one of the files in musedata-file-list and each record being         ;expressed as an a-list. The ordering of the records in each musedata-alist-list is the         ;same as in the corresponding musedata-string-list.         (file-index -1)         (musedata-alist-lists          (mapcar #'(lambda (musedata-string-list comment-alist-list)                      (setf file-index (1+ file-index))                      (let* ((comment-alist-list-with-file-index (mapcar #'(lambda (comment-alist)                                                                             (acons 'file-index file-index                                                                                    comment-alist))                                                                         comment-alist-list))                             ;(header-strings (reverse (cdr (member-if #'(lambda (s)                         ;                                           (and (string/= (val 'string s) "")                         ;                                                (eq #\$ (char (val 'string s) 0))))                          ;                                       (reverse musedata-string-list)))))                             (position-of-first-attributes-record                                                     (do* ((i 0 (1+ i))                                                           (found nil)                                                           (s nil))                                                          ((or found                                                               (= i (list-length musedata-string-list)))                                                           (if found found                                                               (progn (format t "ERROR! No attributes record found.~%~%")                                                                      (throw 'throw-tag nil))))                                                       (setf s (elt musedata-string-list i))                                                       (if (and (string/= (val 'string s) "")                                                        (eq #\$ (char (val 'string s) 0)))                                                 (setf found i))))                             (header-strings (subseq musedata-string-list 0 position-of-first-attributes-record))                             (data-strings (subseq musedata-string-list position-of-first-attributes-record))                             (attributes-strings (remove-if-not #'(lambda (s)                                                           (and (string/= (val 'string s) "")                                                                (eq #\$ (char (val 'string s) 0))))                                                                data-strings))                             (data-strings (remove-if #'(lambda (s)                                                  (and (string/= (val 'string s) "")                                                       (eq #\$ (char (val 'string s) 0))))                                                      data-strings))                             (header-alist (let (hal                                                 i                                                 next-start-position                                                 next-end-position                                                 header-string                                                 line-number)                                             (dotimes (j 11)                                               ;(pprint j)                                               (setf i (1+ j)                                                     header-string (string-trim '(#\Space) (val 'string (elt header-strings j)))                                                     line-number (val 'line-number (elt header-strings j)))                                               ;(pprint i)                                               ;(pprint header-string)                                               (case i                                                 (4                                                   (setf hal                                                         (cons (pairlis                                                                '(type line-number encoding-date name-of-encoder file-index)                                                                (list                                                                 'encoding                                                                 line-number                                                                 ;encoding-date                                                                 (subseq header-string                                                                         0                                                                         (setf next-start-position                                                                               (position #\Space header-string)))                                                                 ;name-of-encoder                                                                 (subseq header-string                                                                         (1+ next-start-position))                                                                 file-index                                                                 ))                                                               hal)                                                        ))                                                 (5                                                  (setf hal                                                         (cons                                                                (pairlis                                                                '(type line-number work-number movement-number file-index)                                                                (list                                                                 'work-and-movement                                                                 line-number                                                                 (subseq header-string                                                                         (1+ (position #\: header-string))                                                                         (position #\Space header-string))                                                                 (subseq header-string                                                                         (setf next-start-position                                                                               (1+ (position #\: header-string :from-end t)))                                                                         (if (setf next-end-position                                                                                   (position #\Space (subseq header-string                                                                                                             next-start-position)))                                                                           (+ next-start-position next-end-position)                                                                           (length header-string)))                                                                 file-index))                                                               hal)))                                                 (6                                                  (setf hal (cons                                                                    (pairlis                                                                    '(type line-number source file-index)                                                                    (list                                                                     'source                                                                     line-number                                                                     header-string                                                                     file-index))                                                                   hal)))                                                 (7                                                  (setf hal (cons                                                                    (pairlis                                                                    '(type line-number work-title file-index)                                                                    (list                                                                     'work-title                                                                     line-number                                                                     header-string                                                                     file-index))                                                                   hal)))                                                 (8                                                  (setf hal (cons                                                                    (pairlis                                                                    '(type line-number movement-title file-index)                                                                    (list                                                                     'movement-title                                                                     line-number                                                                     header-string                                                                     file-index))                                                                   hal)))                                                 (9                                                  (setf hal (cons                                                                    (pairlis                                                                    '(type line-number name-of-part file-index)                                                                    (list                                                                     'name-of-part                                                                     line-number                                                                     header-string                                                                     file-index))                                                                   hal)))                                                 (11                                                  (setf hal (cons                                                                    (pairlis                                                                    '(type line-number groups file-index)                                                                    (list                                                                     'groups                                                                     line-number                                                                     (do* ((hs (string-trim '(#\Space) header-string))                                                                           p                                                                           group-list                                                                           (start-position (1+ (position #\: hs))                                                                                           (position-if #'(lambda (c)                                                                                                            (neq c #\Space))                                                                                                        hs                                                                                                        :start end-position))                                                                           (end-position (if (and start-position                                                                                                  (< start-position (length hs))                                                                                                  (setf p (position #\Space                                                                                                                    (subseq hs                                                                                                                            (1+ start-position)))))                                                                                           (+ 1 start-position p)                                                                                           (length hs))                                                                                         (if (and start-position                                                                                                  (< start-position (length hs))                                                                                                  (setf p (position #\Space                                                                                                                    (subseq hs                                                                                                                            (1+ start-position)))))                                                                                           (+ 1 start-position p)                                                                                           (length hs))))                                                                          ((or (null start-position)                                                                               (>= start-position (length hs)))                                                                           group-list)                                                                       (setf group-list                                                                             (append group-list                                                                                     (list (string-trim '(#\Space)                                                                                                        (subseq hs                                                                                                                start-position                                                                                                                (min end-position                                                                                                                     (length hs))))))))                                                                     file-index))                                                                   hal)))                                                 (otherwise                                                   (setf hal (cons                                                                     (pairlis                                                                    '(type line-number string file-index)                                                                    (list                                                                     (read-from-string (concatenate 'string "record-" (format nil "~d" i)))                                                                     line-number                                                                     (string-trim '(#\Space) header-string)                                                                     file-index))                                                                   hal)))))                                             (let (group)                                               (dotimes (j (list-length (val 'groups (first (find-alists 'type 'groups hal)))))                                                 (if (< (+ 11 j) (list-length header-strings))                                                   (progn (setf i (+ 11 j)                                                                header-string (string-trim '(#\Space) (val 'string (elt header-strings i)))                                                                line-number (val 'line-number (elt header-strings i))                                                                group (string-trim '(#\Space)                                                                                   (subseq header-string 0 (position #\: header-string))))                                                                                                                    (setf hal                                                                (cons                                                                  (pairlis                                                                  '(type line-number part total file-index)                                                                  (list                                                                   (read-from-string group)                                                                   line-number                                                                   (parse-integer (subseq header-string                                                                                          (+ 4                                                                                             (search "part" header-string :from-end t))                                                                                          (search "of" header-string))                                                                                  :junk-allowed t)                                                                   (parse-integer (subseq header-string                                                                                          (+ 2                                                                                             (search "of" header-string)))                                                                                  :junk-allowed t)                                                                   file-index))                                                                 hal)))                                                   (format t "ERROR! No header string for a group membership.~%~%"))))                                             hal))                             (attributes-alist-list (sort (mapcar #'(lambda (s)                                                                       (let* (aal                                                                             start-pos                                                                             end-pos                                                                             slash-pos                                                                             space-pos                                                                             position-of-colon                                                                             (field-identifiers (list "K" "Q" "T" "C" "X" "S" "I" "D"))                                                                             (attributes-string (val 'string s))                                                                             (attributes-line-number (val 'line-number s)))                                                                        (dolist (field-identifier field-identifiers (acons 'file-index file-index                                                                                                                           (acons 'type 'attributes                                                                                                                                  (acons 'line-number attributes-line-number                                                                                                                                          aal))))                                                                          ;(pprint field-identifier)                                                                          (setf start-pos (search field-identifier attributes-string))                                                                          (setf position-of-colon                                                                                  (if start-pos (position #\: (subseq attributes-string start-pos (min (length attributes-string)                                                                                                                                                       (+ start-pos 3))))))                                                                          (if position-of-colon                                                                            (setf end-pos (+ start-pos                                                                                              position-of-colon))                                                                            (setf start-pos nil))                                                                          (if start-pos                                                                            (setf aal                                                                                  (case (char field-identifier 0)                                                                                    (#\K (acons 'key-signature                                                                                                (parse-integer (subseq attributes-string                                                                                                                       (1+ end-pos)                                                                                                                       (if (setf space-pos                                                                                                                                 (position #\Space                                                                                                                                           (subseq attributes-string                                                                                                                                                   (1+ end-pos))))                                                                                                                         (+ 1 end-pos space-pos)))                                                                                                               )                                                                                                aal))                                                                                    (#\Q (acons 'divisions-per-quarter-note                                                                                                (parse-integer (subseq attributes-string                                                                                                                       (1+ end-pos)                                                                                                                       (if (setf space-pos                                                                                                                                 (position #\Space                                                                                                                                           (subseq attributes-string                                                                                                                                                   (1+ end-pos))))                                                                                                                         (+ 1 end-pos space-pos)))                                                                                                               )                                                                                                aal))                                                                                    (#\T (acons 'time-signature                                                                                                (pairlis                                                                                                  (list 'numerator 'denominator)                                                                                                 (list (parse-integer (subseq attributes-string                                                                                                                              (1+ end-pos)                                                                                                                              (setf slash-pos                                                                                                                                    (+ 1 end-pos                                                                                                                                       (position #\/                                                                                                                                                 (subseq attributes-string                                                                                                                                                         (1+ end-pos)))))))                                                                                                       (parse-integer (subseq attributes-string                                                                                                                              (1+ slash-pos)                                                                                                                              (if (setf space-pos                                                                                                                                        (position #\Space                                                                                                                                                  (subseq attributes-string                                                                                                                                                          (1+ slash-pos))))                                                                                                                                (+ 1 slash-pos space-pos))))))                                                                                                aal))                                                                                    (#\C (acons 'clef                                                                                                (pairlis                                                                                                 '(staff code)                                                                                                 (list (if (= end-pos (1+ start-pos))                                                                                                         1                                                                                                         (parse-integer (subseq attributes-string                                                                                                                                (1+ start-pos)                                                                                                                                end-pos)))                                                                                                       (parse-integer (subseq attributes-string                                                                                                                              (1+ end-pos)                                                                                                                              (if (setf space-pos                                                                                                                                        (position #\Space                                                                                                                                                  (subseq attributes-string                                                                                                                                                          (1+ end-pos))))                                                                                                                                (+ 1 end-pos space-pos)))                                                                                                                      )))                                                                                                aal))                                                                                    (#\X (let* ((x-value (parse-integer (subseq attributes-string                                                                                                                                (1+ end-pos)                                                                                                                                (if (setf space-pos                                                                                                                                          (position #\Space                                                                                                                                                    (subseq attributes-string                                                                                                                                                            (1+ end-pos))))                                                                                                                                  (+ 1 end-pos space-pos)))                                                                                                                        ))                                                                                                (transposing-interval (if (>= (abs x-value) 1000)                                                                                                                        (* (signum x-value)                                                                                                                           (- (abs x-value) 1000))                                                                                                                        x-value))                                                                                                (octave-doubling (if (>= (abs x-value) 1000)                                                                                                                   t nil)))                                                                                           (acons 'octave-doubling                                                                                                  octave-doubling                                                                                                  (acons 'transposing-interval                                                                                                         transposing-interval                                                                                                         aal))))                                                                                    (#\S (acons 'number-of-staves                                                                                                (parse-integer (subseq attributes-string                                                                                                                       (1+ end-pos)                                                                                                                       (if (setf space-pos                                                                                                                                 (position #\Space                                                                                                                                           (subseq attributes-string                                                                                                                                                   (1+ end-pos))))                                                                                                                         (+ 1 end-pos space-pos)))                                                                                                               )                                                                                                aal))                                                                                    (#\I (acons 'number-of-instruments                                                                                                (parse-integer (subseq attributes-string                                                                                                                       (1+ end-pos)                                                                                                                       (if (setf space-pos                                                                                                                                 (position #\Space                                                                                                                                           (subseq attributes-string                                                                                                                                                   (1+ end-pos))))                                                                                                                         (+ 1 end-pos space-pos)                                                                                                                         (length attributes-string)))                                                                                                               )                                                                                                aal))                                                                                    (#\D (acons 'directive                                                                                                (pairlis                                                                                                 '(staff string)                                                                                                 (list                                                                                                   (if (= end-pos (1+ start-pos))                                                                                                    1                                                                                                    (parse-integer (subseq attributes-string                                                                                                                           (1+ start-pos)                                                                                                                           end-pos)))                                                                                                  (subseq attributes-string (1+ end-pos))))                                                                                                aal))))))))                                                                  attributes-strings)                                                          #'<                                                          :key #'(lambda (attribute-alist)                                                                   (val 'line-number attribute-alist))                                                          ))                             (attributes-alist-list (do* ((i 0 (1+ i)))                                                         ((= i (1- (list-length attributes-alist-list)))                                                          attributes-alist-list)                                                      (dolist (key-value-pair (elt attributes-alist-list i))                                                        (unless (member (car key-value-pair)                                                                        (mapcar #'car (elt attributes-alist-list (1+ i))))                                                          (setf (elt attributes-alist-list (1+ i))                                                                (cons key-value-pair (elt attributes-alist-list (1+ i))))))))                                                          (data-alist                              (do* ((last-non-chord-note-duration nil)                                    (dal nil)                                    (musedata-pitch-name nil)                                    (pitch-name nil)                                    (chromatic-pitch nil)                                    (parsed-integer nil)                                    (i 0 (1+ i)))                                   ((= i (list-length data-strings))                                    (reverse dal))                                ;(format t "~%~%~s, line-number: ~d, i: ~d"                                ;        (val 'string (elt data-strings i))                                ;        (val 'line-number (elt data-strings i))                                ;        i)                                ;(read-line t)                                (let* ((line-number (val 'line-number (elt data-strings i)))                                       (attributes-alist (do* ((j 0 (1+ j))                                                               (found nil))                                                              ((or found                                                                   (= j (list-length attributes-alist-list)))                                                               (if found found                                                                   (progn (format t "ERROR! No attributes record found for this data-string:~%Data string: ~a~%Attributes record list: ~a~%~%"                                                                                  (elt data-strings i)                                                                                  attributes-alist-list)                                                                          (throw 'throw-tag nil))))                                                           (if (and (< (val 'line-number (elt attributes-alist-list j)) line-number)                                                                    (or (= j (1- (list-length attributes-alist-list)))                                                                        (< line-number (val 'line-number (elt attributes-alist-list (1+ j))))))                                                             (setf found                                                                   (elt attributes-alist-list j)))))                                                                              (divisions-per-quarter-note (let* ((dpqn nil))                                                                     (if (setf dpqn (val 'divisions-per-quarter-note attributes-alist))                                                                       dpqn                                                                       (do* ((position-of-this-attributes-record (position attributes-alist                                                                                                                            attributes-alist-list))                                                                             (i (1- position-of-this-attributes-record) (1- i))                                                                             (dpqn-found nil))                                                                            ((or (= i -1)                                                                                 dpqn-found)                                                                             (if dpqn-found                                                                                dpqn-found                                                                               (progn (format t "ERROR! divisions-per-quarter-note value not found.~%~%")                                                                                      (throw 'throw-tag nil))))                                                                         (setf dpqn-found (val 'divisions-per-quarter-note (elt attributes-alist-list i)))))))                                       (transposing-interval-in-base-40 (val 'transposing-interval attributes-alist))                                       (transposing-interval-in-base-40 (if transposing-interval-in-base-40                                                                          transposing-interval-in-base-40                                                                          0))                                       (transposing-pitch-interval-name (base-40-interval-pitch-name-interval transposing-interval-in-base-40))                                       (duration nil)                                       (data-string (val 'string (elt data-strings i)))                                                                              (first-char (if (> (length data-string) 0)                                                     (char data-string 0)                                                     #\Null))                                       (second-char (if (> (length data-string) 1)                                                      (char data-string 1)                                                      #\Null))                                       (type-value                                         (case first-char                                          (#\Null 'empty)                                          ((#\A #\B #\C #\D #\E #\F #\G)                                           'note)                                          (#\S 'sound-direction)                                          (#\Space (if (member second-char '(#\A #\B #\C #\D #\E #\F #\G #\r))                                                     'chord-note                                                     'unknown))                                          (#\/ (if (eq #\F second-char)                                                 'fine                                                 'end))                                          (#\a 'append)                                          (#\b 'back)                                          (#\c 'cue-note)                                          (#\f 'figure)                                          (#\g 'grace-note)                                          (#\i 'irest)                                          (#\m 'measure)                                          (#\r 'rest)                                          (#\* 'direction)                                          (otherwise 'unknown)))                                       (rest-of-alist                                        (acons 'file-index file-index                                               (case type-value                                                 ((back irest)                                                  (pairlis                                                   '(line-number duration footnote-flag level-number pass-number                                                     duration-in-quarter-notes )                                                   (list                                                    line-number                                                    ;duration                                                    (setf duration                                                          (if (>= (length data-string) 8)                                                            (parse-integer (subseq data-string 5 8))))                                                    ;footnote-flag                                                    (if (and (>= (length data-string) 13)                                                             (string/= " " (subseq data-string 12 13)))                                                      t nil)                                                    ;level-number                                                    (if (and (>= (length data-string) 14)                                                             (string/= " " (subseq data-string 13 14)))                                                      (parse-integer (subseq data-string 13 14)))                                                    ;pass-number                                                    (if (and (>= (length data-string) 17)                                                             (string/= " " (subseq data-string 16 17)))                                                      (if (setf parsed-integer                                                                 (parse-integer (subseq data-string 16 17) :junk-allowed t))                                                        parsed-integer                                                        (format t "~%~%ENCODING ERROR: Illegal character in column 17 of back or irest line (line no.: ~d).~%FILE: ~s~%~%"                                                                 line-number                                                                (elt musedata-file-list file-index))))                                                    ;duration-in-quarter-notes                                                    (if duration                                                      (/ duration divisions-per-quarter-note))                                                    )))                                                 (measure                                                  (pairlis                                                   '(line-number bar-line bar-number footnote-flag level-number)                                                   (list                                                    line-number                                                    ;bar-line                                                    (cond ((or (< (length data-string) 7)                                                               (string= "easure" (subseq data-string 1 7)))                                                           'regular)                                                          ((string= "dotted" (subseq data-string 1 7))                                                           'dotted)                                                          ((string= "double" (subseq data-string 1 7))                                                           'light-double)                                                          ((string= "heavy1" (subseq data-string 1 7))                                                           'heavy)                                                          ((string= "heavy2" (subseq data-string 1 7))                                                           'light-heavy-double)                                                          ((string= "heavy3" (subseq data-string 1 7))                                                           'heavy-light-double)                                                          ((string= "heavy4" (subseq data-string 1 7))                                                           'heavy-heavy-double)                                                          )                                                    ;bar-number                                                    (let (s)                                                      (if (and (>= (length data-string) 9)                                                               (string/= " " (subseq data-string 8 9)))                                                        (if (every #'digit-char-p                                                                    (setf s (string-right-trim '(#\Space)                                                                                              (subseq data-string 8 (min (length data-string) 12)))))                                                          (parse-integer s)                                                          s)))                                                    ;footnote-flag                                                    (if (and (>= (length data-string) 13)                                                             (string/= " " (subseq data-string 12 13)))                                                      t nil)                                                    ;level-number                                                    (if (and (>= (length data-string) 14)                                                             (string/= " " (subseq data-string 13 14)))                                                      (parse-integer (subseq data-string 13 14)))                                                    )))                                                                                                  (note                                                  (pairlis                                                   '(line-number musedata-pitch-name duration tie note-type dot notated-accidental                                                     time-modification footnote-flag level-number track-number stem-direction                                                     staff-assignment beaming pitch-name chromatic-pitch morphetic-pitch midi-note-number                                                     duration-in-quarter-notes)                                                   (list                                                    line-number                                                    ;musedata-pitch-name                                                    (setf musedata-pitch-name                                                          (read-from-string data-string                                                                            t nil                                                                            :start 0                                                                            :end 5))                                                    ;duration                                                    (setf last-non-chord-note-duration                                                          (setf duration                                                                (read-from-string data-string                                                                                  t nil                                                                                  :start 5                                                                                  :end 8)))                                                    ;tie                                                    (if (eq (char data-string 8)                                                            #\-)                                                      t nil)                                                    ;note-type                                                    (if (>= (length data-string) 17)                                                      (case (char data-string 16)                                                        (#\Space nil)                                                        (#\L 'long)                                                        (#\b 'breve)                                                        (#\w 'whole-note)                                                        (#\h 'half-note)                                                        (#\q 'quarter-note)                                                        (#\e 'eighth-note)                                                        (#\s 'sixteenth-note)                                                        (#\t '32nd-note)                                                        (#\x '64th-note)                                                        (#\y '128th-note)                                                        (#\z '256th-note)))                                                    ;dot                                                    (if (>= (length data-string) 18)                                                      (case (char data-string 17)                                                        (#\Space nil)                                                        (#\. 'single)                                                        (#\: 'double)))                                                    ;notated-accidental                                                    (if (>= (length data-string) 19)                                                      (case (char data-string 18)                                                        (#\Space nil)                                                        (#\# 'sharp)                                                        (#\n 'natural)                                                        (#\f 'flat)                                                        (#\x 'double-sharp)                                                        (#\X 'sharp-sharp)                                                        (#\& 'flat-flat)                                                        (#\S 'natural-sharp)                                                        (#\F 'natural-flat)))                                                    ;time-modification                                                    (if (and (>= (length data-string) 20)                                                             (not (eq #\Space (char data-string 19))))                                                      (let* ((numerator-char (char data-string 19))                                                             (numerator (cond ((and (not (digit-char-p numerator-char))                                                                                    (not (upper-case-p numerator-char)))                                                                               (format t "ERROR! Invalid character in time-modification numerator position~%data-string: ~s~%invalid character: ~a~%line number: ~d~%i: ~d~%"                                                                                       data-string                                                                                       numerator-char                                                                                       line-number                                                                                       i)                                                                               (throw 'throw-tag nil))                                                                              ((digit-char-p numerator-char)                                                                               (parse-integer (string numerator-char)))                                                                              ((upper-case-p numerator-char)                                                                               (+ 10                                                                                  (- (char-code numerator-char)                                                                                     (char-code #\A))))))                                                             (denominator-char (if (>= (length data-string) 22)                                                                                 (char data-string 21)))                                                             (denominator (cond ((or (null denominator-char)                                                                                     (eq #\Space denominator-char))                                                                                 (1- numerator))                                                                                ((char<= #\0 numerator-char #\9)                                                                                 (- (char-code numerator-char)                                                                                    (char-code #\0)))                                                                                ((char<= #\A numerator-char #\Z)                                                                                 (+ 10                                                                                    (- (char-code numerator-char)                                                                                       (char-code #\A)))))))                                                        (pairlis                                                         '(numerator denominator)                                                         (list numerator denominator))))                                                    ;footnote-flag                                                    (if (and (>= (length data-string) 13)                                                             (string/= " " (subseq data-string 12 13)))                                                      t nil)                                                    ;level-number                                                    (if (and (>= (length data-string) 14)                                                             (string/= " " (subseq data-string 13 14)))                                                      (parse-integer (subseq data-string 13 14)))                                                    ;track-number                                                    (if (and (>= (length data-string) 15)                                                             (string/= " " (subseq data-string 14 15)))                                                      (parse-integer (subseq data-string 14 15)))                                                    ;stem-direction                                                    (if (and (>= (length data-string) 23)                                                             (string/= " " (subseq data-string 22 23)))                                                      (case (char data-string 22)                                                        (#\u 'up)                                                        (#\d 'down))                                                      'no-stem)                                                    ;staff-assignment                                                    (if (and (>= (length data-string) 24)                                                             (string/= " " (subseq data-string 23 24)))                                                      (parse-integer (subseq data-string 23 24)))                                                    ;beaming                                                    (let ((beaming (subseq data-string                                                                           (min (length data-string)                                                                                25)                                                                           (min (length data-string)                                                                                31))))                                                      (if (or (string= beaming "")                                                              (every #'(lambda (c) (eq c #\Space)) beaming))                                                        nil                                                        beaming))                                                    ;pitch-name                                                    (setf pitch-name (transpose-pitch-name musedata-pitch-name transposing-pitch-interval-name))                                                    ;chromatic-pitch                                                    (setf chromatic-pitch (pitch-name-chromatic-pitch pitch-name))                                                    ;morphetic-pitch                                                    (pitch-name-morphetic-pitch pitch-name)                                                    ;midi-note-number                                                    (chromatic-pitch-midi-note-number chromatic-pitch)                                                    ;duration-in-quarter-notes                                                    (if duration                                                      (/ duration divisions-per-quarter-note))                                                    )))                                                                                                  (rest                                                  (pairlis                                                   '(line-number duration note-type dot time-modification footnote-flag level-number track-number                                                     stem-direction staff-assignment duration-in-quarter-notes)                                                   (list                                                    line-number                                                    ;duration                                                    (setf duration (read-from-string data-string                                                                                     t nil                                                                                     :start 5                                                                                     :end 8))                                                    ;note-type                                                    (if (>= (length data-string) 17)                                                      (case (char data-string 16)                                                        (#\Space nil)                                                        (#\L 'long)                                                        (#\b 'breve)                                                        (#\w 'whole-note)                                                        (#\h 'half-note)                                                        (#\q 'quarter-note)                                                        (#\e 'eighth-note)                                                        (#\s 'sixteenth-note)                                                        (#\t '32nd-note)                                                        (#\x '64th-note)                                                        (#\y '128th-note)                                                        (#\z '256th-note)))                                                    ;dot                                                    (if (>= (length data-string) 18)                                                      (case (char data-string 17)                                                        (#\Space nil)                                                        (#\. 'single)                                                        (#\: 'double)))                                                    ;time-modification                                                    (if (and (>= (length data-string) 20)                                                             (not (eq #\Space (char data-string 19))))                                                      (let* ((numerator-char (char data-string 19))                                                             (numerator (cond ((char<= #\0 numerator-char #\9)                                                                               (- (char-code numerator-char)                                                                                  (char-code #\0)))                                                                              ((char<= #\A numerator-char #\Z)                                                                               (+ 10                                                                                  (- (char-code numerator-char)                                                                                     (char-code #\A))))))                                                             (denominator-char (if (>= (length data-string) 22)                                                                                 (char data-string 21)))                                                             (denominator (cond ((or (null denominator-char)                                                                                     (eq #\Space denominator-char))                                                                                 (1- numerator))                                                                                ((char<= #\0 numerator-char #\9)                                                                                 (- (char-code numerator-char)                                                                                    (char-code #\0)))                                                                                ((char<= #\A numerator-char #\Z)                                                                                 (+ 10                                                                                    (- (char-code numerator-char)                                                                                       (char-code #\A)))))))                                                        (pairlis                                                         '(numerator denominator)                                                         (list numerator denominator))))                                                    ;footnote-flag                                                    (if (and (>= (length data-string) 13)                                                             (string/= " " (subseq data-string 12 13)))                                                      t nil)                                                    ;level-number                                                    (if (and (>= (length data-string) 14)                                                             (string/= " " (subseq data-string 13 14)))                                                      (parse-integer (subseq data-string 13 14)))                                                    ;track-number                                                    (if (and (>= (length data-string) 15)                                                             (string/= " " (subseq data-string 14 15)))                                                      (parse-integer (subseq data-string 14 15)))                                                    ;stem-direction                                                    (if (and (>= (length data-string) 23)                                                             (string/= " " (subseq data-string 22 23)))                                                      (case (char data-string 22)                                                        (#\u 'up)                                                        (#\d 'down))                                                      'no-stem)                                                    ;staff-assignment                                                    (if (and (>= (length data-string) 24)                                                             (string/= " " (subseq data-string 23 24)))                                                      (parse-integer (subseq data-string 23 24)))                                                    ;duration-in-quarter-notes                                                    (if duration                                                      (/ duration divisions-per-quarter-note))                                                    )))                                                                                                  (chord-note                                                  (pairlis                                                   '(line-number musedata-pitch-name duration tie note-type dot notated-accidental                                                     time-modification footnote-flag level-number track-number stem-direction staff-assignment                                                     beaming pitch-name chromatic-pitch morphetic-pitch midi-note-number                                                     duration-in-quarter-notes)                                                   (list                                                    line-number                                                    ;musedata-pitch-name                                                    (setf musedata-pitch-name                                                          (read-from-string data-string                                                                            t nil                                                                            :start 1                                                                            :end 5))                                                    ;duration                                                    (setf duration (if (read-from-string data-string                                                                                         nil nil                                                                                         :start 5                                                                                         :end 8)                                                                     (read-from-string  data-string                                                                                        nil nil                                                                                        :start 5                                                                                        :end 8)                                                                     last-non-chord-note-duration))                                                    ;tie                                                    (if (eq (char data-string 8)                                                            #\-)                                                      t nil)                                                    ;note-type                                                    (if (>= (length data-string) 17)                                                      (case (char data-string 16)                                                        (#\Space nil)                                                        (#\L 'long)                                                        (#\b 'breve)                                                        (#\w 'whole-note)                                                        (#\h 'half-note)                                                        (#\q 'quarter-note)                                                        (#\e 'eighth-note)                                                        (#\s 'sixteenth-note)                                                        (#\t '32nd-note)                                                        (#\x '64th-note)                                                        (#\y '128th-note)                                                        (#\z '256th-note)))                                                    ;dot                                                    (if (>= (length data-string) 18)                                                      (case (char data-string 17)                                                        (#\Space nil)                                                        (#\. 'single)                                                        (#\: 'double)))                                                    ;notated-accidental                                                    (if (>= (length data-string) 19)                                                      (case (char data-string 18)                                                        (#\Space nil)                                                        (#\# 'sharp)                                                        (#\n 'natural)                                                        (#\f 'flat)                                                        (#\x 'double-sharp)                                                        (#\X 'sharp-sharp)                                                        (#\& 'flat-flat)                                                        (#\S 'natural-sharp)                                                        (#\F 'natural-flat)))                                                    ;time-modification                                                    (if (and (>= (length data-string) 20)                                                             (not (eq #\Space (char data-string 19))))                                                      (let* ((numerator-char (char data-string 19))                                                             (numerator (cond ((char<= #\0 numerator-char #\9)                                                                               (- (char-code numerator-char)                                                                                  (char-code #\0)))                                                                              ((char<= #\A numerator-char #\Z)                                                                               (+ 10                                                                                  (- (char-code numerator-char)                                                                                     (char-code #\A))))))                                                             (denominator-char (if (>= (length data-string) 22)                                                                                 (char data-string 21)))                                                             (denominator (cond ((or (null denominator-char)                                                                                     (eq #\Space denominator-char))                                                                                 (1- numerator))                                                                                ((char<= #\0 numerator-char #\9)                                                                                 (- (char-code numerator-char)                                                                                    (char-code #\0)))                                                                                ((char<= #\A numerator-char #\Z)                                                                                 (+ 10                                                                                    (- (char-code numerator-char)                                                                                       (char-code #\A)))))))                                                        (pairlis                                                         '(numerator denominator)                                                         (list numerator denominator))))                                                    ;footnote-flag                                                    (if (and (>= (length data-string) 13)                                                             (string/= " " (subseq data-string 12 13)))                                                      t nil)                                                    ;level-number                                                    (if (and (>= (length data-string) 14)                                                             (string/= " " (subseq data-string 13 14)))                                                      (parse-integer (subseq data-string 13 14)))                                                    ;track-number                                                    (if (and (>= (length data-string) 15)                                                             (string/= " " (subseq data-string 14 15)))                                                      (parse-integer (subseq data-string 14 15)))                                                    ;stem-direction                                                    (if (and (>= (length data-string) 23)                                                             (string/= " " (subseq data-string 22 23)))                                                      (case (char data-string 22)                                                        (#\u 'up)                                                        (#\d 'down))                                                      'no-stem)                                                    ;staff-assignment                                                    (if (and (>= (length data-string) 24)                                                             (string/= " " (subseq data-string 23 24)))                                                      (parse-integer (subseq data-string 23 24)))                                                    ;beaming                                                    (let ((beaming (subseq data-string                                                                           (min (length data-string)                                                                                25)                                                                           (min (length data-string)                                                                                31))))                                                      (if (or (string= beaming "")                                                              (every #'(lambda (c) (eq c #\Space)) beaming))                                                        nil                                                        beaming))                                                    ;pitch-name                                                    (setf pitch-name (transpose-pitch-name musedata-pitch-name transposing-pitch-interval-name))                                                    ;chromatic-pitch                                                    (setf chromatic-pitch (pitch-name-chromatic-pitch pitch-name))                                                    ;morphetic-pitch                                                    (pitch-name-morphetic-pitch pitch-name)                                                    ;midi-note-number                                                    (chromatic-pitch-midi-note-number chromatic-pitch)                                                    ;duration-in-quarter-notes                                                    (if duration                                                      (/ duration divisions-per-quarter-note))                                                    )))                                                                                                  ((cue-note grace-note)                                                  (pairlis                                                   '(line-number musedata-pitch-name note-or-rest note-type chord-note dot notated-accidental                                                     time-modification footnote-flag level-number track-number stem-direction staff-assignement                                                     beaming pitch-name chromatic-pitch morphetic-pitch midi-note-number)                                                   (if (eq #\Space (char data-string 1))                                                     (list                                                      line-number                                                      ;musedata-pitch-name                                                      (setf musedata-pitch-name                                                            (if (eq #\r (char data-string 2))                                                              nil                                                              (read-from-string data-string                                                                                t nil                                                                                :start 2                                                                                :end 6)))                                                      ;note-or-rest                                                      (if (eq #\r (char data-string 2))                                                        'rest                                                        'note)                                                      ;note-type                                                      (case (char data-string 7)                                                        (#\Space nil)                                                        (#\0 'eighth-note-with-slash)                                                        (#\1 '256th-note)                                                        (#\2 '128th-note)                                                        (#\3 '64th-note)                                                        (#\4 '32nd-note)                                                        (#\5 '16th-note)                                                        (#\6 '8th-note)                                                        (#\7 'quarter-note)                                                        (#\8 'half-note)                                                        (#\9 'whole-note)                                                        (#\A 'breve))                                                      ;chord-note                                                      t                                                      ;dot                                                      (if (>= (length data-string) 18)                                                        (case (char data-string 17)                                                          (#\Space nil)                                                          (#\. 'single)                                                          (#\: 'double)))                                                      ;notated-accidental                                                      (if (>= (length data-string) 19)                                                        (case (char data-string 18)                                                          (#\Space nil)                                                          (#\# 'sharp)                                                          (#\n 'natural)                                                          (#\f 'flat)                                                          (#\x 'double-sharp)                                                          (#\X 'sharp-sharp)                                                          (#\& 'flat-flat)                                                          (#\S 'natural-sharp)                                                          (#\F 'natural-flat)))                                                      ;time-modification                                                      (if (and (>= (length data-string) 20)                                                               (not (eq #\Space (char data-string 19))))                                                        (let* ((numerator-char (char data-string 19))                                                               (numerator (cond ((char<= #\0 numerator-char #\9)                                                                                 (- (char-code numerator-char)                                                                                    (char-code #\0)))                                                                                ((char<= #\A numerator-char #\Z)                                                                                 (+ 10                                                                                    (- (char-code numerator-char)                                                                                       (char-code #\A))))))                                                               (denominator-char (if (>= (length data-string) 22)                                                                                   (char data-string 21)))                                                               (denominator (cond ((or (null denominator-char)                                                                                       (eq #\Space denominator-char))                                                                                   (1- numerator))                                                                                  ((char<= #\0 numerator-char #\9)                                                                                   (- (char-code numerator-char)                                                                                      (char-code #\0)))                                                                                  ((char<= #\A numerator-char #\Z)                                                                                   (+ 10                                                                                      (- (char-code numerator-char)                                                                                         (char-code #\A)))))))                                                          (pairlis                                                           '(numerator denominator)                                                           (list numerator denominator))))                                                      ;footnote-flag                                                      (if (and (>= (length data-string) 13)                                                               (string/= " " (subseq data-string 12 13)))                                                        t nil)                                                      ;level-number                                                      (let* ((s nil))                                                        (if (and (>= (length data-string) 14)                                                                 (string/= " " (setf s (subseq data-string 13 14))))                                                          (if (every #'digit-char-p s)                                                            (parse-integer s)                                                            (progn (format t "WARNING! Could not parse level number in cue note/grace note: ~s (line-number: ~d)"                                                                           data-string line-number)                                                                   s))))                                                      ;track-number                                                      (let* ((s nil))                                                        (if (and (>= (length data-string) 15)                                                                 (string/= " " (setf s (subseq data-string 14 15))))                                                          (if (every #'digit-char-p s)                                                            (parse-integer s)                                                            (progn (format t "WARNING! Could not parse track number in cue note/grace note: ~s (line-number: ~d)"                                                                           data-string line-number)                                                                   s))))                                                      ;stem-direction                                                      (if (and (>= (length data-string) 23)                                                               (string/= " " (subseq data-string 22 23)))                                                        (case (char data-string 22)                                                          (#\u 'up)                                                          (#\d 'down))                                                        'no-stem)                                                      ;staff-assignment                                                      (if (and (>= (length data-string) 24)                                                               (string/= " " (subseq data-string 23 24)))                                                        (parse-integer (subseq data-string 23 24)))                                                      ;beaming                                                      (let ((beaming (subseq data-string                                                                             (min (length data-string)                                                                                  25)                                                                             (min (length data-string)                                                                                  31))))                                                        (if (or (string= beaming "")                                                                (every #'(lambda (c) (eq c #\Space)) beaming))                                                          nil                                                          beaming))                                                      ;pitch-name                                                      (setf pitch-name (if musedata-pitch-name (transpose-pitch-name musedata-pitch-name transposing-pitch-interval-name)))                                                      ;chromatic-pitch                                                      (setf chromatic-pitch (if musedata-pitch-name (pitch-name-chromatic-pitch pitch-name)))                                                      ;morphetic-pitch                                                      (if musedata-pitch-name (pitch-name-morphetic-pitch pitch-name))                                                      ;midi-note-number                                                      (if musedata-pitch-name (chromatic-pitch-midi-note-number chromatic-pitch))                                                      )                                                     (list                                                      line-number                                                      ;musedata-pitch-name                                                      (setf musedata-pitch-name                                                             (if (eq #\r (char data-string 1))                                                              nil                                                              (read-from-string data-string                                                                                t nil                                                                                :start 1                                                                                :end 5)))                                                      ;note-or-rest                                                      (if (eq #\r (char data-string 1))                                                        'rest                                                        'note)                                                      ;note-type                                                      (case (char data-string 7)                                                        (#\Space nil)                                                        (#\0 'eighth-note-with-slash)                                                        (#\1 '256th-note)                                                        (#\2 '128th-note)                                                        (#\3 '64th-note)                                                        (#\4 '32nd-note)                                                        (#\5 '16th-note)                                                        (#\6 '8th-note)                                                        (#\7 'quarter-note)                                                        (#\8 'half-note)                                                        (#\9 'whole-note)                                                        (#\A 'breve))                                                      ;chord-note                                                      nil                                                      ;dot                                                      (if (>= (length data-string) 18)                                                        (case (char data-string 17)                                                          (#\Space nil)                                                          (#\. 'single)                                                          (#\: 'double)))                                                      ;notated-accidental                                                      (if (>= (length data-string) 19)                                                        (case (char data-string 18)                                                          (#\Space nil)                                                          (#\# 'sharp)                                                          (#\n 'natural)                                                          (#\f 'flat)                                                          (#\x 'double-sharp)                                                          (#\X 'sharp-sharp)                                                          (#\& 'flat-flat)                                                          (#\S 'natural-sharp)                                                          (#\F 'natural-flat)))                                                      ;time-modification                                                      (if (and (>= (length data-string) 20)                                                               (not (eq #\Space (char data-string 19))))                                                        (let* ((numerator-char (char data-string 19))                                                               (numerator (cond ((char<= #\0 numerator-char #\9)                                                                                 (- (char-code numerator-char)                                                                                    (char-code #\0)))                                                                                ((char<= #\A numerator-char #\Z)                                                                                 (+ 10                                                                                    (- (char-code numerator-char)                                                                                       (char-code #\A))))))                                                               (denominator-char (if (>= (length data-string) 22)                                                                                   (char data-string 21)))                                                               (denominator (cond ((or (null denominator-char)                                                                                       (eq #\Space denominator-char))                                                                                   (1- numerator))                                                                                  ((char<= #\0 numerator-char #\9)                                                                                   (- (char-code numerator-char)                                                                                      (char-code #\0)))                                                                                  ((char<= #\A numerator-char #\Z)                                                                                   (+ 10                                                                                      (- (char-code numerator-char)                                                                                         (char-code #\A)))))))                                                          (pairlis                                                           '(numerator denominator)                                                           (list numerator denominator))))                                                      ;footnote-flag                                                      (if (and (>= (length data-string) 13)                                                               (string/= " " (subseq data-string 12 13)))                                                        t nil)                                                      ;level-number                                                      (let* ((s nil))                                                        (if (and (>= (length data-string) 14)                                                                 (string/= " " (setf s (subseq data-string 13 14))))                                                          (if (every #'digit-char-p s)                                                            (parse-integer s)                                                            (progn (format t "WARNING! Could note parse level-number in: ~s (line-number: ~d)~%~%"                                                                           data-string line-number)                                                                   s))))                                                      ;track-number                                                      (let* ((s nil))                                                        (if (and (>= (length data-string) 15)                                                                 (string/= " " (setf s (subseq data-string 14 15))))                                                          (if (every #'digit-char-p s)                                                            (parse-integer s)                                                            (progn (format t "WARNING! Could note parse track-number in: ~s (line-number: ~d)~%~%"                                                                           data-string line-number)                                                                   s))))                                                      ;stem-direction                                                      (if (and (>= (length data-string) 23)                                                               (string/= " " (subseq data-string 22 23)))                                                        (case (char data-string 22)                                                          (#\u 'up)                                                          (#\d 'down))                                                        'no-stem)                                                      ;staff-assignment                                                      (if (and (>= (length data-string) 24)                                                               (string/= " " (subseq data-string 23 24)))                                                        (parse-integer (subseq data-string 23 24)))                                                      ;beaming                                                      (let ((beaming (subseq data-string                                                                             (min (length data-string)                                                                                  25)                                                                             (min (length data-string)                                                                                  31))))                                                        (if (or (string= beaming "")                                                                (every #'(lambda (c) (eq c #\Space)) beaming))                                                          nil                                                          beaming))                                                      ;pitch-name                                                      (setf pitch-name (if musedata-pitch-name (transpose-pitch-name musedata-pitch-name transposing-pitch-interval-name)))                                                      ;chromatic-pitch                                                      (setf chromatic-pitch (if musedata-pitch-name (pitch-name-chromatic-pitch pitch-name)))                                                      ;morphetic-pitch                                                      (if musedata-pitch-name (pitch-name-morphetic-pitch pitch-name))                                                      ;midi-note-number                                                      (if musedata-pitch-name (chromatic-pitch-midi-note-number chromatic-pitch))                                                      ))))                                                 (otherwise                                                  (pairlis                                                   '(line-number)                                                   (list                                                    line-number)))))))                                  (setf dal                                        (cons (acons 'type type-value rest-of-alist)                                              dal)))))                                                          ;To fix problems like the one at bar 101 in Gloria of B minor mass,                             ;need to find onset of each attributes record and use this as an offset when                             ;calculating the onset time of each of the other records.                                                   (data-alist-with-onset-times                              (do* ((i 0 (1+ i))                                    (dalwot nil)                                    (this-onset 0)                                    (next-onset 0))                                   ((= i (list-length data-alist))                                    dalwot)                                ;(format t "data-alist: ~a~% line-number: ~d~% i: ~d~%~%"                                ;        (elt data-alist i)                                ;        (val 'line-number (elt data-alist i))                                ;        i)                                (let* ((line-number (val 'line-number (elt data-strings i)))                                       (attributes-alist-position (do* ((j 0 (1+ j))                                                                        (found nil))                                                                       ((or found                                                                            (= j (list-length attributes-alist-list)))                                                                        (if found found                                                                            (progn (format t "ERROR! No attributes record found for this data-alist:~%Data alist: ~a~%Attributes record list: ~a~%~%"                                                                                           (elt data-alist i)                                                                                           attributes-alist-list)                                                                                   (throw 'throw-tag nil))))                                                                    (if (and (< (val 'line-number (elt attributes-alist-list j)) line-number)                                                                             (or (= j (1- (list-length attributes-alist-list)))                                                                                 (< line-number (val 'line-number (elt attributes-alist-list (1+ j))))))                                                                      (setf found                                                                            j))))                                       (divisions-per-quarter-note (let* ((dpqn nil))                                                                     (if (setf dpqn (val 'divisions-per-quarter-note (elt attributes-alist-list attributes-alist-position)))                                                                       dpqn                                                                       (do* ((i (1- attributes-alist-position) (1- i))                                                                             (dpqn-found nil))                                                                            ((or (= i -1)                                                                                 dpqn-found)                                                                             (if dpqn-found                                                                                dpqn-found                                                                               (progn (format t "ERROR! divisions-per-quarter-note value not found.~%~%")                                                                                      (throw 'throw-tag nil))))                                                                         (setf dpqn-found (val 'divisions-per-quarter-note (elt attributes-alist-list i))))))))                                  (case (val 'type (elt data-alist i))                                    ((note rest irest)                                     (setf this-onset next-onset                                           next-onset (+ this-onset (/ (val 'duration (elt data-alist i))                                                                       divisions-per-quarter-note))))                                    (back                                     (setf this-onset next-onset                                           next-onset (- this-onset (/ (val 'duration (elt data-alist i))                                                                       divisions-per-quarter-note))))                                    (measure                                     (setf this-onset next-onset)))                                  (setf dalwot                                        (append dalwot                                                (list (acons 'onset-in-quarter-notes this-onset                                                             (elt data-alist i))))))                                ))                             ;Add in data alists for octave doubled part.                             (data-alist-with-onset-times                              (let (#|(transposing-interval-for-first-attributes-alist                                     (val 'transposing-interval (first attributes-alist-list)))|#                                    (octave-doubling-for-first-attributes-alist                                     (val 'octave-doubling (first attributes-alist-list)))                                    )                                (if (member nil (mapcar #'(lambda (attributes-alist)                                                            (eq octave-doubling-for-first-attributes-alist                                                                (val 'octave-doubling attributes-alist)))                                                        (cdr attributes-alist-list)))                                  (progn (format t "~%ERROR! Attribute records do not all have same octave doubling value.~%attributes-alist-list = ~a.~%~%"                                                 attributes-alist-list)                                         (throw 'throw-tag nil)))                                #|(if (member nil (mapcar #'(lambda (attributes-alist)                                                            (eq transposing-interval-for-first-attributes-alist                                                                (val 'transposing-interval attributes-alist)))                                                        (cdr attributes-alist-list)))                                  (progn (format t "~%ERROR! Attribute records do not all have same transposing interval value.~%attributes-alist-list = ~a.~%~%"                                                 attributes-alist-list)                                         (throw 'throw-tag nil)))|#                                (if octave-doubling-for-first-attributes-alist                                  (append data-alist-with-onset-times                                          (remove-if #'null (mapcar #'(lambda (data-alist-with-onset-time)                                                                        ;(pprint data-alist-with-onset-time)                                                                        ;(read-line t)                                                                        (if (member (val 'type data-alist-with-onset-time)                                                                                    '(note chord-note cue-note grace-note))                                                                          (let* ((new-data-alist nil))                                                                            (dolist (key-value-pair data-alist-with-onset-time new-data-alist)                                                                              (setf new-data-alist                                                                                    (append new-data-alist                                                                                            (list (cond ((eq (car key-value-pair) 'pitch-name)                                                                                                         (cons 'pitch-name                                                                                                               (transpose-pitch-name (cdr key-value-pair)                                                                                                                                     'fp8)))                                                                                                        ((eq (car key-value-pair) 'chromatic-pitch)                                                                                                         (cons 'chromatic-pitch                                                                                                               (- (cdr key-value-pair) 12)))                                                                                                        ((eq (car key-value-pair) 'morphetic-pitch)                                                                                                         (cons 'morphetic-pitch                                                                                                               (- (cdr key-value-pair) 7)))                                                                                                        ((eq (car key-value-pair) 'midi-note-number)                                                                                                         (cons  'midi-note-number                                                                                                               (- (cdr key-value-pair) 12)))                                                                                                        (t key-value-pair)))))))                                                                          ;data-alist-with-onset-time                                                                          ))                                                                    data-alist-with-onset-times)))                                  data-alist-with-onset-times)                                )))                        (sort                          (append header-alist                                  attributes-alist-list                                 comment-alist-list-with-file-index                                 data-alist-with-onset-times)                         #'<                         :key #'(lambda (record) (val 'line-number (cdr record))))                        ))                  musedata-string-lists                  comment-alist-lists))         ;TO FIND VOICE NUMBERS         ;=====================         ;For each record, a string is computed by concatenating the file-index (turned into a string)         ;with the track number (which may be nil). The file-index and track number strings are right-justified in fields that         ;are definitely wide enough to contain any possible values. The complete set of distinct voice-strings is then         ;computed for all files. This set is then sorted and the voice-number of each record in each file is given by the position         ;of its voice-string in this sorted list.         (sorted-voice-string-set          (sort (let* ((svs nil))            (mapcar #'(lambda (musedata-alist-list)                        (mapcar #'(lambda (musedata-alist)                                    (pushnew (format nil "~8@a~8@a"                                                     (val 'file-index musedata-alist)                                                     (val 'track-number musedata-alist))                                             svs                                             :test #'string=))                                musedata-alist-list))                    musedata-alist-lists)            svs)                #'string<))         (musedata-alist-lists          (mapcar #'(lambda (musedata-alist-list)                      (mapcar #'(lambda (musedata-alist)                                  (acons 'voice-number                                         (1+ (position (format nil "~8@a~8@a"                                                               (val 'file-index musedata-alist)                                                               (val 'track-number musedata-alist))                                                       sorted-voice-string-set                                                       :test #'string=))                                         musedata-alist))                              musedata-alist-list))                  musedata-alist-lists)))    #|(mapcar #'(lambda (original-musedata-string-list musedata-alist-list)                (let* ((original-musedata-string-list-length (list-length original-musedata-string-list))                       (musedata-alist-list-length (list-length musedata-alist-list)))                  (format t "~%original-musedata-string-list length = ~d~%musedata-alist-list length = ~d~%"                        original-musedata-string-list-length                        musedata-alist-list-length)                  (if (/= musedata-alist-list-length original-musedata-string-list-length)                    (progn (format t "~%~%ERROR: original-musedata-string-list length not equal to musedata-alist-list length.~%~%")))))            original-musedata-string-lists            musedata-alist-lists)|#    (values musedata-alist-lists            #|(mapcar #'(lambda (original-musedata-string-list musedata-alist-list)                        (mapcar #'(lambda (original-musedata-string musedata-alist)                                    (if (= (val 'line-number original-musedata-string)                                           (val 'line-number musedata-alist))                                      (if (null (val 'string musedata-alist))                                        (cons (assoc 'string original-musedata-string)                                              musedata-alist)                                        musedata-alist)                                      (progn (format t "~%~%ERROR: original-musedata-string line number (~d) not equal to musedata-alist line number (~d).~%~%"                                                     (val 'line-number original-musedata-string)                                                     (val 'line-number musedata-alist))                                             ;(quit)                                             )))                                original-musedata-string-list                                musedata-alist-list))                    original-musedata-string-lists                    musedata-alist-lists)|#            musedata-directory)))(defun musedata2mef-2 (musedata-alist-lists musedata-directory)  (if musedata-alist-lists    (let* ((output-filename nil)           (header-item (list (list 0 "$ MEF-V1~%")))           (pathname-list (pathname-directory musedata-directory))           (position-of-data (position "data" pathname-list :test #'string=))           (musedata-alists (sort (apply #'append                                       musedata-alist-lists)                               #'(lambda (a b)                                   (or (null (val 'onset-in-quarter-notes a))                                       (and (val 'onset-in-quarter-notes b)                                            (< (val 'onset-in-quarter-notes a)                                               (val 'onset-in-quarter-notes b)))))))           (list-of-measure-alists (remove-duplicates (sort (find-alists 'type 'measure                                                                   musedata-alists)                                                     #'<                                                     :key #'(lambda (alist)                                                              (val 'onset-in-quarter-notes                                                                    alist)))                                               :test #'=                                               :key #'(lambda (alist)                                                        (val 'onset-in-quarter-notes alist))                                               ))           (measure-items (mapcar #'(lambda (measure-alist)                                      (list (val 'onset-in-quarter-notes measure-alist)                                            (format nil "/ ~d~%"                                                    (* 480 (val 'onset-in-quarter-notes measure-alist)))))                                  list-of-measure-alists))           (first-bar-number (let* ((onset-in-quarter-notes-of-first-barline                                     (val 'onset-in-quarter-notes                                          (first list-of-measure-alists)))                                    (length-of-bar-in-quarter-notes                                     (let* ((ts (val 'time-signature (first (find-alists 'type 'attributes musedata-alists))))                                            (d (if ts (val 'denominator ts)))                                            (n (if ts (val 'numerator ts))))                                       (if ts                                         (cond ((or (= d n 0)                                                    (and (= n 2)                                                         (= d 0)))                                                4)                                               ((and (= d 0)                                                     (= n 3))                                                3)                                               ((= d 0)                                                (progn (format t "ERROR! Unknown time signature with zero denominator: ~a~%"                                                               ts)                                                       (throw 'throw-tag nil)))                                               (t (* 4 (/ n d))))))))                               (if (or (null length-of-bar-in-quarter-notes)                                       (< onset-in-quarter-notes-of-first-barline                                          length-of-bar-in-quarter-notes))                                 0 1)))           (filename-string (let* ((outstring ""))                              (dolist (dirstring                                        (remove "stage2" (subseq pathname-list (1+ position-of-data))                                               :test #'string=)                                       outstring)                                (setf outstring                                      (concatenate 'string                                                   outstring                                                   (subseq dirstring                                                           0 (min (length dirstring) 6)))))))           (filename-item (list (list 0 (concatenate 'string                                                     "F 0 "                                                     "'"                                                     filename-string                                                     "'"                                                     (format nil " ~d~%" first-bar-number)))))           (opndv-alists (sort (remove-if-not #'(lambda (alist)                                                  (member (val 'type alist)                                                          '(rest chord-note note)))                                              musedata-alists)                               #'<                               :key #'(lambda (alist) (val 'onset-in-quarter-notes alist))))           (note-items nil)           (measure-and-note-items nil))            ;Set tied-to-previous-note to true for those notes that are tied to previous notes.      (do* ((i (- (list-length opndv-alists) 2) (1- i)))           ((< i 0))        ;(format t "~d~%" i)        (if (val 'tie (elt opndv-alists i))          (let* ((this-opndv-alist (elt opndv-alists i))                 (next-onset (+ (val 'duration-in-quarter-notes this-opndv-alist)                                (val 'onset-in-quarter-notes this-opndv-alist)))                 (list-of-possible-next-notes (do* ((j (1+ i) (1+ j))                                                    (lopnn nil))                                                   ((or (= j (list-length opndv-alists))                                                        (and (val 'onset-in-quarter-notes (elt opndv-alists j))                                                             (> (val 'onset-in-quarter-notes (elt opndv-alists j))                                                                next-onset)))                                                    lopnn)                                                (if (and (val 'chromatic-pitch (elt opndv-alists j))                                                         (= (val 'chromatic-pitch this-opndv-alist)                                                            (val 'chromatic-pitch (elt opndv-alists j)))                                                         (val 'onset-in-quarter-notes (elt opndv-alists j))                                                         (= next-onset (val 'onset-in-quarter-notes (elt opndv-alists j))))                                                  (setf lopnn (cons j lopnn)))))                 (list-of-possible-next-notes (if list-of-possible-next-notes list-of-possible-next-notes                                                  (progn (format t "ERROR! No possible next note following a tied note (2). (i=~d, opndv-alist = ~a).~%"                                                                 i this-opndv-alist)                                                         (throw 'throw-tag nil))))                 (next-note-score-list (mapcar #'(lambda (possible-next-note-index)                                                   (let* ((score (if (equalp (val 'pitch-name this-opndv-alist)                                                                             (val 'pitch-name (elt opndv-alists possible-next-note-index)))                                                                   1 0))                                                          (score (if (= (val 'voice-number this-opndv-alist)                                                                        (val 'voice-number (elt opndv-alists possible-next-note-index)))                                                                   (1+ score) score)))                                                     score))                                               list-of-possible-next-notes))                 (next-note (elt list-of-possible-next-notes                                 (position (apply #'max next-note-score-list)                                           next-note-score-list))))            (setf (elt opndv-alists next-note)                  (acons 'tied-to-previous-note t                         (elt opndv-alists next-note))))))            (setf note-items (mapcar #'(lambda (opndv-alist)                                   (list (val 'onset-in-quarter-notes opndv-alist)                                         (format nil (concatenate 'string                                                                   "N ~d ~d/~dv~d ~d"                                                                  (if (val 'tied-to-previous-note opndv-alist)                                                                    ")" "")                                                                  (if (val 'tie opndv-alist)                                                                    "(" "")                                                                  "~%"                                                                  )                                                 (* 480 (val 'onset-in-quarter-notes opndv-alist))                                                 (numerator (/ (val 'duration-in-quarter-notes opndv-alist) 4))                                                 (denominator (/ (val 'duration-in-quarter-notes opndv-alist) 4))                                                 (val 'voice-number opndv-alist)                                                 (if (eql (val 'type opndv-alist) 'rest)                                                   0                                                   (val 'midi-note-number opndv-alist)))))                               opndv-alists))            (setf measure-and-note-items            (sort (append measure-items                          note-items)                  #'(lambda (a b)                      (or (< (first a) (first b))                          (and (= (first a) (first b))                               (eql (char (second a) 0) #\/))))                  ;do the measure items have to be the first in a sequence of items with the same onset?                  ))      ;Deal with chords      (format t "Dealing with chord notes~%")      (do* ((i 0 (1+ i)))           ((>= i (list-length measure-and-note-items))            (setf measure-and-note-items                  (remove-if #'null measure-and-note-items)))        (if (and (elt measure-and-note-items i)                 (eql #\N (char (second (elt measure-and-note-items i)) 0)))          (do* ((j (1+ i) (1+ j)))               ((or (>= j (list-length measure-and-note-items))                    (and (elt measure-and-note-items j)                         (> (first (elt measure-and-note-items j))                            (first (elt measure-and-note-items i))))))            ;(format t "i = ~d, j = ~d~%" i j)            ;(format t ".")            (let* ((mef-item-list-i (mef-item-string-to-list (second (elt measure-and-note-items i))))                   (mef-item-list-j (mef-item-string-to-list (second (elt measure-and-note-items j)))))              (if (and mef-item-list-i mef-item-list-j)                (let* ((first-three-elements-in-i (subseq mef-item-list-i 0 3))                       (first-three-elements-in-j (subseq mef-item-list-j 0 3)))                  (if (equalp first-three-elements-in-i first-three-elements-in-j)                    (setf (second (elt measure-and-note-items i)) (concatenate-string (string-trim '(#\Space)                                                                                                   (apply #'concatenate-string                                                                                                          (append mef-item-list-i (last mef-item-list-j))))                                                                                      (string #\Newline))                          (elt measure-and-note-items j) nil))))))))      (with-open-file (mef-file                       (setf output-filename                             (pathname (concatenate 'string                                                    (pathname-directory-to-string (pathname-directory musedata-directory))                                                    filename-string                                                    ".mef")))                       :direction :output                       :if-exists :rename)        (mapcar #'(lambda (item)                    (format mef-file (second item)))                (append header-item                        filename-item                        measure-and-note-items                        (list (list nil "Q~%")))))      output-filename)))(defun musedata2mef (&optional (auto-file-find nil)                               (use-s-files nil))  (multiple-value-bind (musedata-alist-lists                        musedata-directory)                       (parse-musedata auto-file-find use-s-files)    (musedata2mef-2 musedata-alist-lists musedata-directory)))(defun musedata2opndv-2 (musedata-alist-lists musedata-directory)  (if musedata-alist-lists    (let* ((output-filename nil)           (pathname-list (pathname-directory musedata-directory))           (position-of-data (position "data" pathname-list :test #'string=))           (filename-string (let* ((outstring ""))                              (dolist (dirstring                                        (remove "stage2" (subseq pathname-list (1+ position-of-data))                                               :test #'string=)                                       outstring)                                (setf outstring                                      (concatenate 'string                                                   outstring                                                   (subseq dirstring                                                           0 (min (length dirstring) 6)))))))           (duration-multiplier 1)           (opndv-alists (sort (apply #'append (find-alists 'onset-in-quarter-notes t                                                            (find-alists 'pitch-name t                                                                         (find-alists 'duration-in-quarter-notes t                                                                                      (find-alists 'voice-number t                                                                                                   musedata-alist-lists                                                                                                   t)                                                                                      t)                                                                         t)                                                            t))                               #'<                               :key #'(lambda (alist) (val 'onset-in-quarter-notes alist)))))      (do* ((i (- (list-length opndv-alists) 2) (1- i)))           ((< i 0))        ;(format t "~d~%" i)        (if (val 'tie (elt opndv-alists i))          (let* ((this-opndv-alist (elt opndv-alists i))                 (next-onset (+ (val 'duration-in-quarter-notes this-opndv-alist)                                (val 'onset-in-quarter-notes this-opndv-alist)))                 (list-of-possible-next-notes (do* ((j (1+ i) (1+ j))                                                    (lopnn nil))                                                   ((or (= j (list-length opndv-alists))                                                        (and (val 'onset-in-quarter-notes (elt opndv-alists j))                                                             (> (val 'onset-in-quarter-notes (elt opndv-alists j))                                                                next-onset)))                                                    lopnn)                                                (if (and (val 'chromatic-pitch (elt opndv-alists j))                                                         (= (val 'chromatic-pitch this-opndv-alist)                                                            (val 'chromatic-pitch (elt opndv-alists j)))                                                         (val 'onset-in-quarter-notes (elt opndv-alists j))                                                         (= next-onset (val 'onset-in-quarter-notes (elt opndv-alists j))))                                                  (setf lopnn (cons j lopnn)))))                 (list-of-possible-next-notes (if list-of-possible-next-notes list-of-possible-next-notes                                                  (progn (format t "ERROR! No possible next note following a tied note (1). (i=~d, opndv-alist = ~a).~%"                                                                 i this-opndv-alist)                                                         (throw 'throw-tag nil))))                 (next-note-score-list (mapcar #'(lambda (possible-next-note-index)                                                   (let* ((score (if (equalp (val 'pitch-name this-opndv-alist)                                                                             (val 'pitch-name (elt opndv-alists possible-next-note-index)))                                                                   1 0))                                                          (score (if (= (val 'voice-number this-opndv-alist)                                                                        (val 'voice-number (elt opndv-alists possible-next-note-index)))                                                                   (1+ score) score)))                                                     score))                                               list-of-possible-next-notes))                 (next-note (elt list-of-possible-next-notes                                 (position (apply #'max next-note-score-list)                                           next-note-score-list))))            (setf (elt opndv-alists i)                  (acons 'duration-in-quarter-notes                          (+ (val 'duration-in-quarter-notes (elt opndv-alists i))                            (val 'duration-in-quarter-notes (elt opndv-alists next-note)))                         (elt opndv-alists i))                  (elt opndv-alists next-note)                  nil))))      (setf opndv-alists            (remove-if #'null opndv-alists))      (setf duration-multiplier            (apply #'lcm                   (let* ((denominator-list nil))                     (mapcar #'(lambda (opndv-alist)                                 (let* ((onset (val 'onset-in-quarter-notes opndv-alist))                                        (duration (val 'duration-in-quarter-notes opndv-alist)))                                   (pushnew (denominator onset)                                            denominator-list)                                   (pushnew (denominator duration)                                            denominator-list)))                             opndv-alists)                     denominator-list)))      (with-open-file (opndv-file                       (setf output-filename                             (pathname (concatenate 'string                                                    (pathname-directory-to-string (pathname-directory musedata-directory))                                                    filename-string                                                    ".opndv")))                       :direction :output                       :if-exists :rename)        (pprint (sort                  (mapcar #'(lambda (opndv-alist)                             (list (* duration-multiplier (val 'onset-in-quarter-notes opndv-alist))                                   (val 'pitch-name opndv-alist)                                   (* duration-multiplier (val 'duration-in-quarter-notes opndv-alist))                                   (val 'voice-number opndv-alist)))                         opndv-alists)                 #'<                 :key #'first)                opndv-file))      output-filename)))(defun musedata2opndv (&optional (auto-file-find nil)                                 (use-s-files nil))  (multiple-value-bind (musedata-alist-lists                        musedata-directory)                       (parse-musedata auto-file-find use-s-files)    (musedata2opndv-2 musedata-alist-lists musedata-directory)    ))(defun musedata2opndvandmef (&optional (auto-file-find nil)                                       (use-s-files nil)                                       (directory-name (choose-directory-dialog)))  (multiple-value-bind (musedata-alist-lists                        musedata-directory)                       (parse-musedata auto-file-find use-s-files directory-name)    (let* ((opndv-filename (musedata2opndv-2 musedata-alist-lists musedata-directory))           (mef-filename (musedata2mef-2 musedata-alist-lists musedata-directory)))      (values opndv-filename              mef-filename))))(defun val (a-list-keyword a-list)  (cdr (assoc a-list-keyword a-list)))(defun find-alists (keyword value alist-list-or-list-of-alist-lists &optional (list-of-alist-lists nil))  (if list-of-alist-lists    (mapcar #'(lambda (alist-list)                (remove-if-not #'(lambda (alist)                                   (if (eq value t)                                     (not (null (val keyword alist)))                                     (equalp value (val keyword alist))))                               alist-list))            alist-list-or-list-of-alist-lists)    (remove-if-not #'(lambda (alist)                       (if (eq value t)                         (not (null (val keyword alist)))                         (equalp value (val keyword alist))))                   alist-list-or-list-of-alist-lists)))(defun BASE-40-INTERVAL-PITCH-NAME-INTERVAL (base-40-interval)  (let* ((sign-of-interval (signum base-40-interval))         (absolute-interval (abs base-40-interval))         (absolute-interval-class (mod absolute-interval 40))         (absolute-interval-octave (floor absolute-interval 40))         (undirected-pitch-interval-name-class (case absolute-interval-class                                                 (0 "p1")                                                 (1 "a1")                                                 (4 "d2")                                                 (5 "mi2")                                                 (6 "ma2")                                                 (7 "a2")                                                 (10 "d3")                                                 (11 "mi3")                                                 (12 "ma3")                                                 (13 "a3")                                                 (16 "d4")                                                 (17 "p4")                                                 (18 "a4")                                                 (22 "d5")                                                 (23 "p5")                                                 (24 "a5")                                                 (27 "d6")                                                 (28 "mi6")                                                 (29 "ma6")                                                 (30 "a6")                                                 (33 "d7")                                                 (34 "mi7")                                                 (35 "ma7")                                                 (36 "a7")                                                 (39 "d8")                                                 (40 "p8")                                                 (otherwise (format t "~%~%ERROR: Transposing interval (~d) not in range.~%~%"                                                                    base-40-interval)                                                            (throw 'throw-tag nil))))         (undirected-pitch-interval-name (string-left-trim '(#\r #\f)                                                            (pin-sum undirected-pitch-interval-name-class                                                                    (pin-power 'rp8 absolute-interval-octave)))))    (concatenate 'string                 (case sign-of-interval                   (0 "")                   (1 "r")                   (-1 "f"))                 undirected-pitch-interval-name)    ))(defun transpose-pitch-name (pitch-name pitch-interval-name)  (pn-tran pitch-name pitch-interval-name))(defun pitch-name-chromatic-pitch (pitch-name)  (p-pc (pn-p pitch-name)))(defun pitch-name-morphetic-pitch (pitch-name)  (p-pm (pn-p pitch-name)))(defun chromatic-pitch-midi-note-number (chromatic-pitch)  (+ 21 chromatic-pitch))#|;defined in ps-dphil-test.lisp(defun pitch-name-equal-p (pn1 pn2)  (equalp (pn-p pn1) (pn-p pn2)))|#(defun extract-voices (&optional (opnd-file (choose-file-dialog :button-string "OPND"))                                 (output-directory (choose-directory-dialog :button-string "OUTPUT")))  (let* ((opnd (with-open-file (opnd-stream                                opnd-file)                 (read opnd-stream)))         (max-voice (apply #'max (mapcar #'fourth opnd))))    (do* ((voice-number 1 (1+ voice-number)))         ((> voice-number max-voice))      (with-open-file (opnd-voice-stream                       (make-pathname :directory (pathname-directory output-directory)                                      :name (concatenate 'string                                                          (pathname-name opnd-file)                                                         (format nil "-~d" voice-number))                                      :type (pathname-type opnd-file))                       :direction :output                       :if-exists :rename)        (pprint (remove-if-not #'(lambda (opnd-datapoint)                                   (= (fourth opnd-datapoint)                                      voice-number))                               opnd)                opnd-voice-stream)))))(defun mef-item-string-to-list (mef-item-string)  (if mef-item-string    (do* ((i 0 (1+ i))          (current-element "")          (l nil))         ((= i (length mef-item-string))          (if (whitespace-char-p (char mef-item-string (1- (length mef-item-string))))            (reverse l)            (reverse (cons (concatenate-string current-element " ") l))))      (if (whitespace-char-p (char mef-item-string i))        (setf l (cons (concatenate-string current-element " ") l)              current-element "")        (setf current-element (concatenate 'string current-element (string (char mef-item-string i))))))))(defun whitespace-char-p (c)  (member c '(#\Newline #\Space #\Tab)))(defun concatenate-string (s &rest more-strings)  (concatenate-string-2 s more-strings))(defun concatenate-string-2 (s more-strings)  (cond ((null more-strings) s)        (t (concatenate-string-2 (concatenate 'string s (first more-strings))                                 (cdr more-strings)))))(defun compare-opcdv-with-opdv (&optional (opcdv-filename (choose-file-dialog :button-string "OPCDV"))                                          (opdv-filename (choose-file-dialog :button-string "OPDV")))  (if (and opcdv-filename opdv-filename)    (let* ((opdv (sort (mapcar #'(lambda (opdv-datapoint)                                   (list (first opdv-datapoint)		;onset                                         (second opdv-datapoint)	;chromatic pitch                                         (fourth opdv-datapoint)	;duration                                         (fifth opdv-datapoint)		;voice                                         ))                               (with-open-file (opdv-file                                                opdv-filename)                                 (read opdv-file)))                       #'vector-less-than-p))           (opcdv (sort (with-open-file (opcdv-file                                         opcdv-filename)                          (read opcdv-file))                        #'vector-less-than-p)))      (format t "Total number of datapoints in opdv file: ~dTotal number of datapoints in opcdv file: ~dTotal number of errors: ~d~%"              (list-length opdv)              (list-length opcdv)              (count nil (mapcar #'(lambda (opcdv1 opcdv2)                                     (if (equalp opcdv1 opcdv2)                                       t                                       (format t "opcdv datapoint from opdv file:  ~a~%opcdv datapoint from opcdv file: ~a~%~%"                                               opcdv1 opcdv2)))                                 opdv                                 opcdv)))      )))(defun batch-mef2opcdv (&key (input-directory (choose-directory-dialog :button-string "MEF DIR"))                             (output-directory (choose-directory-dialog :button-string "OPCDV DIR"))                             (divide-by-gcd t))  (let* ((list-of-mef-files (directory (make-pathname :directory (pathname-directory input-directory)                                                      :name :wild                                                      :type "mef"))))    (mapcar #'(lambda (mef-file)                (mef2opcdv :mef-filename mef-file                           :output-directory output-directory                           :divide-by-gcd divide-by-gcd))            list-of-mef-files)))(defun mef2opcdv (&key (mef-filename (choose-file-dialog :button-string "MEF FILE"))                       (output-directory (choose-directory-dialog :button-string "OPCDV DIR"))                       (divide-by-gcd t))  (format t "~%~a" (pathname-name mef-filename))  (if mef-filename    (let* ((mef-string-list (with-open-file (mef-file                                             mef-filename)                              (do* ((l nil)                                    (mef-item (read-line mef-file nil nil)                                              (read-line mef-file nil nil)))                                   ((null mef-item)                                    (reverse l))                                (setf l (cons mef-item l)))))           (mef-string-list (remove-if-not #'(lambda (mef-item)                                               (eql #\N (char mef-item 0)))                                           mef-string-list))           (list-of-mef-item-lists (mapcar #'(lambda (mef-item-string)                                               (mef-item-string-to-list mef-item-string))                                           mef-string-list))           (opcdv-with-tie-flags (do* ((outlist nil)                                       (i 0 (1+ i)))                                      ((= i (list-length list-of-mef-item-lists))                                       (sort outlist                                             #'(lambda (opcdv1 opcdv2)                                                 (or (< (first opcdv1) (first opcdv2))                                                     (and (= (first opcdv1) (first opcdv2))                                                          (< (second opcdv1) (second opcdv2)))))))                                   (setf outlist                                         (append outlist                                                 (let* ((mef-item-list (elt list-of-mef-item-lists i))                                                        (mef-item-midi-note-string-list (remove "0 " (cdddr mef-item-list)                                                                                                :test #'string=))                                                        (mef-item-chromatic-pitch-list (mapcar #'(lambda (midi-note-string)                                                                                                   (- (read-from-string midi-note-string) 21))                                                                                               mef-item-midi-note-string-list))                                                        (mef-item-tie-list (mapcar #'(lambda (midi-note-string)                                                                                       (let* ((tie-list nil)                                                                                              (tie-list (if (position #\( midi-note-string)                                                                                                          (cons 'tied-to-following tie-list)                                                                                                          tie-list))                                                                                              (tie-list (if (position #\) midi-note-string)                                                                                                          (cons 'tied-to-previous tie-list)                                                                                                          tie-list)))                                                                                         tie-list))                                                                                   mef-item-midi-note-string-list))                                                        (onset (read-from-string (second mef-item-list)))                                                        (duration (* 480 4 (read-from-string (third mef-item-list)                                                                                             nil                                                                                             nil                                                                                             :start 0                                                                                             :end (position #\v (third mef-item-list)))))                                                        (voice (read-from-string (third mef-item-list)                                                                                 nil                                                                                 nil                                                                                 :start (1+ (position #\v (third mef-item-list))))))                                                   (mapcar #'(lambda (chromatic-pitch tie-flags)                                                               (list onset chromatic-pitch duration voice tie-flags))                                                           mef-item-chromatic-pitch-list                                                           mef-item-tie-list))))))           (opcdv (do* ((i (- (list-length opcdv-with-tie-flags) 2) (1- i)))                       ((< i 0)                        (mapcar #'butlast (remove-if #'null opcdv-with-tie-flags)))                    ;(format t "~d~%" i)                    (if (member 'tied-to-following (fifth (elt opcdv-with-tie-flags i)))                      (let* ((this-opcdv-datapoint (elt opcdv-with-tie-flags i))                             (next-onset (+ (first this-opcdv-datapoint)                                             (third this-opcdv-datapoint)))                             (list-of-possible-next-notes (do* ((j (1+ i) (1+ j))                                                                (lopnn nil))                                                               ((or (= j (list-length opcdv-with-tie-flags))                                                                    (and (elt opcdv-with-tie-flags j)                                                                         (> (first (elt opcdv-with-tie-flags j))                                                                            next-onset)))                                                                lopnn)                                                            (if (and (elt opcdv-with-tie-flags j)                                                                     (= (second this-opcdv-datapoint)                                                                        (second (elt opcdv-with-tie-flags j)))                                                                     (= next-onset (first (elt opcdv-with-tie-flags j)))                                                                     (member 'tied-to-previous (fifth (elt opcdv-with-tie-flags j))))                                                              (setf lopnn (cons j lopnn)))))                             (list-of-possible-next-notes (if list-of-possible-next-notes list-of-possible-next-notes                                                  (progn (format t "ERROR! No possible next note following a tied note (3). (i=~d, opcdv-datapoint = ~a).~%"                                                                 i this-opcdv-datapoint)                                                         (throw 'throw-tag nil))))                             (next-note-score-list (mapcar #'(lambda (possible-next-note-index)                                                               (let* ((score 0)                                                                      (score (if (= (fourth this-opcdv-datapoint)                                                                                    (fourth (elt opcdv-with-tie-flags                                                                                                 possible-next-note-index)))                                                                               (1+ score) score)))                                                                 score))                                                           list-of-possible-next-notes))                             (next-note (elt list-of-possible-next-notes                                             (position (apply #'max next-note-score-list)                                                       next-note-score-list))))                                                (setf (third (elt opcdv-with-tie-flags i))                              (+ (third (elt opcdv-with-tie-flags i))                                 (third (elt opcdv-with-tie-flags next-note)))                              (elt opcdv-with-tie-flags next-note)                              nil)))))           (onsets (mapcar #'first opcdv))           (durations (mapcar #'third opcdv))           (multiplier (if divide-by-gcd                         (if (and (every #'integerp onsets)                                  (every #'integerp durations))                           (/ 1 (apply #'gcd (list (apply #'gcd onsets)                                                   (apply #'gcd durations))))                           (let ((outlist nil))                             (dolist (d (append (mapcar #'denominator onsets)                                                (mapcar #'denominator durations))                                        (apply #'lcm outlist))                               (pushnew d outlist))))                         1))           (opcdv (do ((i 0 (1+ i)))                      ((= i (list-length opcdv))                       opcdv)                    (setf (first (elt opcdv i))                          (* (first (elt opcdv i)) multiplier)                          (third (elt opcdv i))                          (* (third (elt opcdv i)) multiplier))))           (output-filename nil)           )      (with-open-file (opcdv-file                       (make-pathname :directory (pathname-directory output-directory)                                      :name (pathname-name mef-filename)                                      :type "opcdv")                       :direction :output                       :if-exists :rename-and-delete)        (pprint opcdv                opcdv-file))      output-filename)))(defun musedata-convert (&optional (auto-file-find nil)                                    (use-s-files nil)                                   (directory-name (choose-directory-dialog)))  (pprint directory-name)(format t "~%")  (catch 'throw-tag    (multiple-value-bind (opndv-filename                          mef-filename)                         (musedata2opndvandmef auto-file-find use-s-files directory-name)      (let* ((opcdv-filename (mef2opcdv :mef-filename mef-filename))             (opd-filename (opnd2opd opndv-filename)))        (compare-opcdv-with-opdv opcdv-filename opd-filename)        (opcdv2midi 4 opcdv-filename)))))(defun batch-musedata-convert (&optional (all-unprocessed-files nil)                                         (use-s-files nil)                                         (search-directory (choose-directory-dialog)))  (format t "Search directory: ~a~%" search-directory)  (let* ((list-of-musedata-directories (if all-unprocessed-files                                         (find-musedata-directories-not-already-converted search-directory)                                         (find-musedata-directories search-directory))))    (mapcar #'(lambda (musedata-directory)                ;(pprint musedata-directory)(format t "~%")                (catch 'throw-tag                  (musedata-convert t use-s-files musedata-directory)))            list-of-musedata-directories)))(defun find-musedata-directories (&optional (this-directory (choose-directory-dialog)))  (let* ((musedata-directory-list nil)         (directories-in-this-directory (directory (make-pathname :directory (pathname-directory this-directory)                                                                  :name :wild)                                                    :directories t                                                   :files nil)))    (dolist (directory-in-this-directory             directories-in-this-directory             musedata-directory-list)      (if (string= (first (last (pathname-directory directory-in-this-directory)))                   "stage2")        (setf musedata-directory-list              (append musedata-directory-list                      (directory (make-pathname :directory (pathname-directory directory-in-this-directory)                                                                  :name :wild)                                                    :directories t                                                   :files nil)))        (setf musedata-directory-list              (append musedata-directory-list                      (find-musedata-directories directory-in-this-directory)))))))(defun find-musedata-directories-not-already-converted (&optional (this-directory (choose-directory-dialog)))  (let* ((all-musedata-directories (find-musedata-directories this-directory)))    (remove-if #'null               (mapcar #'(lambda (musedata-directory)                           (let* ((files-in-musedata-directory (directory (make-pathname :directory (pathname-directory musedata-directory)                                                                                         :name :wild)                                                                           :files t))                                  (file-types-in-musedata-directory (mapcar #'pathname-type files-in-musedata-directory)))                             (if (subsetp (list "mef" "mid" "opcdv" "opd" "opndv") file-types-in-musedata-directory :test #'string=)                               nil                               musedata-directory)))                       all-musedata-directories))))(defun find-all-files (file-type                       &optional (this-directory (choose-directory-dialog))                       (return-file-list nil))  (pprint this-directory)(format t "~%")  (catch 'throw-tag    (let* ((all-musedata-directories (find-musedata-directories this-directory))           (directories-with-more-than-one-file nil)           (all-files (remove-if #'null                                 (mapcar #'(lambda (musedata-directory)                                             (let* ((files-in-musedata-directory (directory (make-pathname :directory (pathname-directory musedata-directory)                                                                                                           :name :wild                                                                                                           :type file-type)                                                                                             :files t)))                                               (if (> (list-length files-in-musedata-directory) 1)                                                 (progn (format t "ERROR! More than one ~a file in this directory:~%~s~%"                                                                file-type                                                                musedata-directory)                                                        (setf directories-with-more-than-one-file                                                              (cons musedata-directory                                                                    directories-with-more-than-one-file))                                                        nil)                                                 (first files-in-musedata-directory))))                                         all-musedata-directories))))      (format t "Number of ~a files: ~d~%"              file-type              (list-length all-files))      (format t "Directories containing more than one ~a file:"              file-type              )      (pprint (mapcar #'(lambda (dir)                          (format t "~s~%"                                  dir))                      directories-with-more-than-one-file))      (if return-file-list (progn (format t "~%")                                  all-files))      )))(defun find-all-opndv-files (&optional (this-directory (choose-directory-dialog))                                       (return-file-list nil)                                       (opnd-m-files nil))  (pprint this-directory)(format t "~%")  (catch 'throw-tag    (let* ((all-musedata-directories (find-musedata-directories this-directory))           (directories-with-more-than-one-opndv-file nil)           (all-opndv-files (remove-if #'null                                       (mapcar #'(lambda (musedata-directory)                                                   (let* ((opndv-files-in-musedata-directory (directory (make-pathname :directory (pathname-directory musedata-directory)                                                                                                                       :name :wild                                                                                                                       :type (if opnd-m-files                                                                                                                                "opnd-m"                                                                                                                               "opndv"))                                                                                                         :files t)))                                                     (if (> (list-length opndv-files-in-musedata-directory) 1)                                                       (progn (format t "ERROR! More than one ~a file in this directory:~%~s~%"                                                                      (if opnd-m-files "opnd-m" "opndv")                                                                      musedata-directory)                                                              (setf directories-with-more-than-one-opndv-file                                                                    (cons musedata-directory                                                                          directories-with-more-than-one-opndv-file))                                                              nil)                                                       (first opndv-files-in-musedata-directory))))                                               all-musedata-directories))))      (format t "Number of ~a files: ~d~%"              (if opnd-m-files "opnd-m" "opndv")              (list-length all-opndv-files))      (format t "Total number of notes in all files: ~d~%"              (apply #'+ (mapcar #'(lambda (opndv-file)                                     (with-open-file (opndv-file-stream                                                      opndv-file)                                       (list-length (read opndv-file-stream))))                                 all-opndv-files)))      (format t "Directories containing more than one ~a file:"              (if opnd-m-files "opnd-m" "opndv")              )      (pprint (mapcar #'(lambda (dir)                          (format t "~s~%"                                  dir))                      directories-with-more-than-one-opndv-file))      (if return-file-list (progn (format t "~%")                                  all-opndv-files))      )))(defun find-all-mef-files (&optional (this-directory (choose-directory-dialog))                                       (return-file-list nil))  (pprint this-directory)(format t "~%")  (catch 'throw-tag    (let* ((all-musedata-directories (find-musedata-directories this-directory))           (directories-with-more-than-one-mef-file nil)           (all-mef-files (remove-if #'null                                       (mapcar #'(lambda (musedata-directory)                                                   (let* ((mef-files-in-musedata-directory (directory (make-pathname :directory (pathname-directory musedata-directory)                                                                                                                       :name :wild                                                                                                                       :type "mef")                                                                                                         :files t)))                                                     (if (> (list-length mef-files-in-musedata-directory) 1)                                                       (progn (format t "ERROR! More than one mef file in this directory:~%~s~%"                                                                      musedata-directory)                                                              (setf directories-with-more-than-one-mef-file                                                                    (cons musedata-directory                                                                          directories-with-more-than-one-mef-file))                                                              nil)                                                       (first mef-files-in-musedata-directory))))                                               all-musedata-directories))))      (format t "Number of mef files: ~d~%"              (list-length all-mef-files))      (format t "Directories containing more than one mef file:~%")      (mapcar #'(lambda (dir)                  (format t "~s~%"                          dir))              directories-with-more-than-one-mef-file)      (if return-file-list all-mef-files)      )))#|(setf search-directory (choose-directory-dialog) dum nil)(setf all-mef-files (find-all-mef-files search-directory t) dum nil)(setf all-opndv-files (find-all-opndv-files search-directory t) dum nil)(do* ((i 0 (1+ i))      (j 0 (1+ j)))     ((or (>= i (list-length all-mef-files))          (>= j (list-length all-opndv-files))))  (if (string/= (pathname-name (elt all-mef-files i))                (pathname-name (elt all-opndv-files j)))    (progn (format t "MEF file: ~s~%OPNDV file: ~s~%~%"                   (elt all-mef-files i)                   (elt all-opndv-files j))           (setf j (1+ j))           )))|#(defun old-musedata-convert ()  (format t "Starting musedata2opndvandmef...(Press ENTER)")  (read-line t)  (musedata2opndvandmef)  (format t "...musedata2opndvandmef completed. (Press ENTER)")    (format t "Starting mef2opcdv...(Press ENTER)")  (read-line t)  (mef2opcdv)  (format t "...mef2opcdv completed. (Press ENTER)")    (format t "Starting opnd2opd...(Press ENTER)")  (read-line t)  (opnd2opd)  (format t "...opnd2opd completed. (Press ENTER)")    (format t "Starting compare-opcdv-with-opdv...(Press ENTER)")  (read-line t)  (compare-opcdv-with-opdv)  (format t "...compare-opcdv-with-opdv completed. (Press ENTER)")    (format t "Starting opcdv2midi...(Press ENTER)")  (read-line t)  (opcdv2midi 4)  (format t "...opcdv2midi completed.~%FINISHED.~%")  )(defun remove-hyphens-in-file-names (&optional (this-directory (choose-directory-dialog)))  (pprint this-directory)(format t "~%")  (catch 'throw-tag    (let* ((all-musedata-directories (find-musedata-directories this-directory))           (all-files-with-hyphens (apply #'append                                          (mapcar #'(lambda (musedata-directory)                                                      (let* ((files-in-musedata-directory (directory (make-pathname :directory (pathname-directory musedata-directory)                                                                                                                    :name :wild                                                                                                                    :type :wild)                                                                                                      :files t                                                                                                     :directories nil)))                                                        (remove-if-not #'(lambda (filename)                                                                           (find #\- (pathname-name filename)))                                                                       files-in-musedata-directory)))                                                  all-musedata-directories))))      (mapcar #'(lambda (old-filename)                  (rename-file old-filename                               (make-pathname :directory (pathname-directory old-filename)                                              :name (remove #\- (pathname-name old-filename))                                              :type (pathname-type old-filename))))              all-files-with-hyphens)      )))(defun change--m-to-m (&optional (this-directory (choose-directory-dialog)))  (pprint this-directory)(format t "~%")  (catch 'throw-tag    (let* ((all-musedata-directories (find-musedata-directories this-directory))           (all-files-with--m (apply #'append                                          (mapcar #'(lambda (musedata-directory)                                                      (let* ((files-in-musedata-directory (directory (make-pathname :directory (pathname-directory musedata-directory)                                                                                                                    :name :wild                                                                                                                    :type :wild)                                                                                                      :files t                                                                                                     :directories nil)))                                                        (remove-if-not #'(lambda (filename)                                                                           (and (> (length (pathname-name filename)) 2)                                                                                (string= "-m" (subseq (pathname-name filename)                                                                                                 (- (length (pathname-name filename)) 2)))))                                                                       files-in-musedata-directory)))                                                  all-musedata-directories))))      (mapcar #'(lambda (old-filename)                  (rename-file old-filename                               (make-pathname :directory (pathname-directory old-filename)                                              :name (concatenate 'string                                                                 (subseq (pathname-name old-filename)                                                                          0                                                                         (- (length (pathname-name old-filename)) 2))                                                                 "m")                                              :type (pathname-type old-filename))))              all-files-with--m)      )))(defun copy-all-files (file-type                       &optional (this-directory (choose-directory-dialog :button-string "SOURCE"))                       (target-directory (choose-directory-dialog :button-string "TARGET")))  (let* ((all-files-to-be-copied (find-all-files file-type this-directory t)))    (mapcar #'(lambda (filename)                (copy-file filename                           (make-pathname :directory (pathname-directory target-directory)                                          :name (pathname-name filename)                                          :type (pathname-type filename))))            all-files-to-be-copied)))(defun copy-all-mid-files (&optional (this-directory (choose-directory-dialog :button-string "SOURCE"))                                     (m-mid-target-directory (choose-directory-dialog :button-string "M-MID TARGET"))                                     (mid-target-directory (choose-directory-dialog :button-string "MID TARGET")))  (let* ((all-files-to-be-copied (find-all-files "mid" this-directory t)))    (mapcar #'(lambda (filename)                (copy-file filename                           (make-pathname :directory (pathname-directory (if (char= #\m (char (pathname-name filename)                                                                                              (1- (length (pathname-name filename)))))                                                                           m-mid-target-directory                                                                           mid-target-directory))                                          :name (pathname-name filename)                                          :type (pathname-type filename))))            all-files-to-be-copied)))(defun list-files-in-directory (&optional (this-directory (choose-directory-dialog)))  (directory (make-pathname :directory (pathname-directory this-directory)                            :name :wild                            :type :wild)))(defun opcdv2midi (division &optional (opcdv-filename (choose-file-dialog :button-string "OPCDV")))  (if opcdv-filename    (let* ((opcdv (sort (with-open-file (opcdv-file                                         opcdv-filename)                          (read opcdv-file))                        #'vector-less-than-p))           (dataset (mapcar #'(lambda (opcdv-datapoint)                                (list (first opcdv-datapoint)		;onset                                      (second opcdv-datapoint)	;chromatic pitch                                      nil				;morphetic pitch                                      (third opcdv-datapoint)		;duration                                      (fourth opcdv-datapoint)	;voice                                      ))                            opcdv))           )      (opd2midi division dataset opcdv-filename "opcdv."))))(defun opnd2opd (&optional (filename (choose-file-dialog :button-string "OPND"))                           (output-to-file t)                           (output-directory filename))  (if filename    (let* ((dataset (read-dataset filename))           (opd (mapcar #'(lambda (dp)                            (append (list (first dp))                                    (pn-p (second dp))                                    (cddr dp)))                        dataset))           (opd (sort opd #'vector-less-than-p)))      (if output-to-file         (write-dataset opd ".opd" (pathname-directory output-directory))        opd))))(defun batch-opnd2opd (&optional (opnd-file-suffix "opnd-m")                                 (opnd-directory (choose-directory-dialog :button-string "OPND"))                                 (opd-directory (choose-directory-dialog :button-string "OPD")))  (let* ((list-of-opnd-files (directory (make-pathname :directory (pathname-directory opnd-directory)                                                       :name :wild                                                       :type opnd-file-suffix))))    (mapcar #'(lambda (opnd-file)                (opnd2opd opnd-file t opd-directory))            list-of-opnd-files)))(defun pathname-directory-to-string (pn)  (let ((pns (concatenate 'string (second pn) ":")))    (dolist (pnelt (cddr pn) pns)      (setf pns (concatenate 'string                             pns                              pnelt                             ":")))))#|;defined in ps-dphil-intro.lisp(defun vector-less-than-p (v1 v2)  (cond ((null v2) nil)        ((null v1) t)        ((< (list-length v1)            (list-length v2))         t)        ((> (list-length v1)            (list-length v2))         nil)        ((< (first v1)            (first v2))         t)        ((> (first v1)            (first v2))         nil)        (t (vector-less-than-p (cdr v1) (cdr v2)))))|#(defun pn-p (pn-as-input)  (let* ((n (if (stringp pn-as-input)              (string-upcase pn-as-input)              (string-upcase (string pn-as-input))))         (n (if (and (>= (length n) 2)                     (member (elt n 1) '(#\- #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)))              (concatenate 'string                            (string (elt n 0))                           "N"                           (subseq n 1))              n))         (n (if (and (>= (length n) 3)                     (eq (elt n 1) #\#))              (concatenate 'string                            (string (elt n 0))                           "S"                           (subseq n 2))              n))         (l (string (elt n 0)))         (i (do* ((i "")                  (x 2)                  (j (string (elt n (- x 1))) (string (elt n (- x 1))))                  (i (concatenate 'string i j) (concatenate 'string i j))                  (x (+ 1 x) (+ 1 x)))                 ((or (>= x (length n))                      (member (elt n (- x 1)) '(#\- #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)))                  i)))         (is-good-i (well-formed-inflection-p i))         (o (if is-good-i              (do* ((y (length i))                    (x (+ y 2))                    (o (string (elt n (- x 1))))                    (x (+ 1 x) (+ 1 x))                    (j (if (<= x (length n))                         (string (elt n (- x 1)))                         "")                       (if (<= x (length n))                         (string (elt n (- x 1)))                         ""))                    (o (if (equalp j "") o                           (concatenate 'string o j))                       (if (equalp j "") o                           (concatenate 'string o j))))                   ((equalp j "")                    o))))         (oasa (if is-good-i (read-from-string o nil nil)))         (m (if is-good-i (position l                                    '("A" "B" "C" "D" "E" "F" "G")                                    :test #'equalp)))         (cdash (if is-good-i (elt '(0 2 3 5 7 8 10) m)))         (e (if is-good-i (cond ((equalp i "N") 0)                                ((equalp (elt i 0) #\F) (* -1 (length i)))                                ((member (elt i 0) '(#\S #\#)) (length i)))))         (om (if is-good-i (if (or (= m 1) (= m 0))                             oasa (- oasa 1))))         (pc (if is-good-i (+ e cdash (* 12 om))))         (pm (if is-good-i (+ m (* om 7)))))    (if is-good-i (list pc pm))))(defun p-pm (p)  (second p))(defun p-pc (p)  (first p))#|;defined in ps-dphil-intro.lisp(defun pn-tran (pitch-name pitch-interval-name)  (p-pn (p-tran (pn-p pitch-name) (pin-pi pitch-interval-name))))|#(defun pin-power (pin power)  (case (signum power)    (0 "p1")    (-1 (pin-power (pin-inverse pin) (- power)))    (1 (let ((result (pin-string pin)))         (dotimes (i (1- power) result)           (setf result                 (pin-sum result pin)))))))(defun pin-sum (&rest pin-list)  (pi-pin (apply #'pi-sum (mapcar #'pin-pi pin-list))))(defun pi-sum (&rest pi-list)  (list (apply #'+ (mapcar #'first pi-list))        (apply #'+ (mapcar #'second pi-list))))(defun pin-pi (pitch-interval-name)  (let* ((pin (if (stringp pitch-interval-name)                (string-upcase pitch-interval-name)                (string-upcase (string pitch-interval-name))))         (d (char pin 0))         (d (if (member d '(#\F #\R) :test #'equalp) (string d) ""))         (ty (do* ((ty "")                   (x (if (equalp d "") 0 1))                   (j (string (elt pin x)) (string (elt pin x)))                   (ty (concatenate 'string ty j) (concatenate 'string ty j))                   (x (+ 1 x) (+ 1 x)))                  ((or (>= x (length pin))                       (member (elt pin x) '(#\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)))                   ty)))         (ty-error (not (well-formed-interval-type-p ty)))         (s (if (not ty-error)              (do* ((y (length ty))                    (x (if (equalp d "") y (+ y 1)))                    (s (string (elt pin x)))                    (x (+ 1 x) (+ 1 x))                    (j (if (< x (length pin))                         (string (elt pin x))                         "")                       (if (< x (length pin))                         (string (elt pin x))                         ""))                    (s (if (equalp j "") s                           (concatenate 'string s j))                       (if (equalp j "") s                           (concatenate 'string s j))))                   ((equalp j "")                    s))))         (s-error (if (not ty-error) (not (well-formed-number-string-p s))))         (s-dash (if (or s-error ty-error) nil (read-from-string s)))         (pmintvar (if (or s-error ty-error) nil (if (equalp d "f") (- 1 s-dash) (- s-dash 1))))         (mint-dash (if (or s-error ty-error) nil (MOD (abs pmintvar) 7)))         (cint-dash (if (or s-error ty-error) nil (elt '(0 2 4 5 7 9 11) mint-dash)))         (pcintone (if (or s-error ty-error) nil (+ cint-dash                                                    (* 12                                                       (FLOOR (abs pmintvar)                                                            7)))))         (t-dash (if (or s-error ty-error) nil (elt '("p" "ma" "ma" "p" "p" "ma" "ma") mint-dash)))         (e (if (or s-error ty-error) nil                (cond ((and (equalp ty "p") (equalp t-dash "p")) 0)                      ((and (equalp t-dash "p") (equalp (char ty 0) #\D)) (* (- 1) (length ty)))                      ((and (equalp t-dash "p") (equalp (char ty 0) #\A)) (length ty))                      ((and (equalp ty "ma") (equalp t-dash "ma")) 0)                      ((and (equalp t-dash "ma") (equalp ty "mi")) (- 1))                      ((and (equalp t-dash "ma") (equalp (char ty 0) #\D)) (* (- 1)                                                                             (+ (length ty) 1)))                      ((and (equalp t-dash "ma") (equalp (char ty 0) #\A)) (length ty)))))         (pcintvar (if (or s-error ty-error) nil                       (if (< pmintvar 0) (* (- 1) (+ e pcintone)) (+ e pcintone)))))    (list pcintvar pmintvar)))(defun pi-pin (pint)  (let* ((pmint (p-int-pm-int pint))         (d (cond ((= 0 pmint) "")                  ((> pmint 0) "r")                  ((< pmint 0) "f")))         (sdash (+ 1 (abs pmint)))         (s (format nil "~D" sdash))         (mintdash (mod (abs pmint) 7))         (cintdash (elt '(0 2 4 5 7 9 11) mintdash))         (tdash (elt '("p" "ma" "ma" "p" "p" "ma" "ma") mintdash))         (e (if (>= pmint 0) (- (p-int-gc-int pint) cintdash) (- (p-int-gc-int (invp pint)) cintdash)))         (ty (cond ((and (equalp tdash "p") (= e 0))                   "p")                  ((and (equalp tdash "p") (> e 0))                   (let ((x "")) (dotimes (i e x) (setf x (concatenate 'string x "a")))))                  ((and (equalp tdash "p") (< e 0))                   (let ((x "")) (dotimes (i (- e) x) (setf x (concatenate 'string x "d")))))                  ((and (equalp tdash "ma") (= e 0))                   "ma")                  ((and (equalp tdash "ma") (= e -1))                   "mi")                  ((and (equalp tdash "ma") (< e -1))                   (let ((x "")) (dotimes (i (- (- e) 1) x) (setf x (concatenate 'string x "d")))))                  ((and (equalp tdash "ma") (> e 0))                   (let ((x "")) (dotimes (i e x) (setf x (concatenate 'string x "a"))))))))    (concatenate 'string d ty s)))(defun pin-string (pin)  (if (stringp pin)    (string-downcase pin)    (string-downcase (string pin))))(defun pin-inverse (pin)  (pi-pin (pi-inverse (pin-pi pin))))(defun well-formed-inflection-p (i)  (or (equalp i "N")      (let ((wf t))        (dotimes (j (length i) wf)          (if (not (equalp (char i j) #\F))            (setf wf nil))))      (let ((wf t))        (dotimes (j (length i) wf)          (if (not (member (char i j) '(#\S #\#)))            (setf wf nil))))))(defun write-dataset (dataset &optional                               (file-type nil)                              (output-directory (pathname-directory *file-name*)))  (with-open-file (dataset-file                   (pathname (concatenate 'string                                          (pathname-directory-to-string output-directory)                                          (pathname-name *file-name*)                                           (if (null file-type) ".pcot" file-type)))                   :direction :output                   :if-exists :rename)    (pprint dataset dataset-file)))(defun read-dataset (&optional (filename (choose-file-dialog)))  (with-open-file (dataset-file-stream                   (setf *file-name* filename))    (read dataset-file-stream)))(defun opd2midi (division;                 tempo;                 ts-num ;                 ts-den;                 number-of-sharps;                 major-minor                 &optional ;                 (mc-per-met 24);                 (dsqs-per-midiq 8)                 (dataset nil)                 (file-name nil)                 (output-directory (choose-directory-dialog :button-string "MIDI")))  (let* ((opd (mapcar #'(lambda (opd-dp)                          (list (+ (* 20 division) (* 20 (first opd-dp)))                                (second opd-dp)                                (third opd-dp)                                (- (* 20 (fourth opd-dp)) 1)))                      (if dataset                         dataset                        (with-open-file (dataset-file-stream                                         (setf file-name (choose-file-dialog :button-string "OPD2MIDI FILE")))                          (read dataset-file-stream)))))         (mid-on (mapcar #'(lambda (opd-dp)                             (list (first opd-dp)                                   (+ (second opd-dp) 21)                                   1))                         opd))         (mid-off (mapcar #'(lambda (opd-dp)                              (list (+ (first opd-dp) (fourth opd-dp))                                    (+ (second opd-dp) 21)                                    0))                          opd))         (mid-list (sort (append mid-on mid-off)                         #'<                         :key #'first))         (hdr-chunk-list (construct-hdr-chunk-list (* 20 division)))         ;(set-tempo-list (construct-set-tempo-list tempo))         ;(time-sig-list (construct-time-sig-list ts-num          ;                                        ts-den         ;                                        mc-per-met         ;                                        dsqs-per-midiq))         (end-of-track-list '(0 255 47 0))         ;(key-sig-list (construct-key-sig-list number-of-sharps major-minor))         (note-list (construct-note-list mid-list))         (track-chunk-list (append ;set-tempo-list                                   ;time-sig-list                                   ;key-sig-list                                   note-list                                   end-of-track-list))         (track-chunk-length (list-length track-chunk-list))         (track-chunk-hdr-list (construct-track-chunk-hdr-list track-chunk-length))         (midi-byte-list (append hdr-chunk-list                                  track-chunk-hdr-list                                 track-chunk-list))         (midi-filename (make-pathname                         :directory (pathname-directory output-directory)                         :name (pathname-name file-name)                          :type "mid")))    (with-open-file (midi-file                     midi-filename                     :direction :output                     :if-exists :rename                     :element-type 'unsigned-byte)      (mapc #'(lambda (midi-byte)                (write-byte midi-byte midi-file))            midi-byte-list)      midi-filename)))(defun opd2midi-with-errors (division                             ;                 tempo                             ;                 ts-num                              ;                 ts-den                             ;                 number-of-sharps                             ;                 major-minor                             &optional                              ;                 (mc-per-met 24)                             ;                 (dsqs-per-midiq 8)                             (dataset nil)                             (file-name nil)                             (output-directory (choose-directory-dialog :button-string "MIDI")))  (let* ((opd (mapcar #'(lambda (opd-dp)                          (append (list (+ (* 20 division) (* 20 (first opd-dp)))                                        (second opd-dp)                                        (third opd-dp)                                        (- (* 20 (fourth opd-dp)) 1))                                  (if (member 'error opd-dp)                                    (list 'error)                                    nil)))                      (if dataset                         dataset                        (with-open-file (dataset-file-stream                                         (setf file-name (choose-file-dialog :button-string "OPD2MIDI FILE")))                          (read dataset-file-stream)))))         (mid-on (mapcar #'(lambda (opd-dp)                             (append (list (first opd-dp)                                           (+ (second opd-dp) 21)                                           1)                                     (if (member 'error opd-dp)                                       (list 'error)                                       nil)))                         opd))         (mid-off (mapcar #'(lambda (opd-dp)                              (append (list (+ (first opd-dp) (fourth opd-dp))                                            (+ (second opd-dp) 21)                                            0)                                      (if (member 'error opd-dp)                                        (list 'error)                                        nil)))                          opd))         (mid-list (sort (append mid-on mid-off)                         #'<                         :key #'first))         (hdr-chunk-list (construct-hdr-chunk-list (* 20 division)))         ;(set-tempo-list (construct-set-tempo-list tempo))         ;(time-sig-list (construct-time-sig-list ts-num          ;                                        ts-den         ;                                        mc-per-met         ;                                        dsqs-per-midiq))         (end-of-track-list '(0 255 47 0))         ;(key-sig-list (construct-key-sig-list number-of-sharps major-minor))         (note-list (construct-note-list-with-errors mid-list))         (track-chunk-list (append ;set-tempo-list                                   ;time-sig-list                                   ;key-sig-list                                   note-list                                   end-of-track-list))         (track-chunk-length (list-length track-chunk-list))         (track-chunk-hdr-list (construct-track-chunk-hdr-list track-chunk-length))         (midi-byte-list (append hdr-chunk-list                                  track-chunk-hdr-list                                 track-chunk-list))         (midi-filename (make-pathname                         :directory (pathname-directory output-directory)                         :name (pathname-name file-name)                          :type "mid")))    (with-open-file (midi-file                     midi-filename                     :direction :output                     :if-exists :rename                     :element-type 'unsigned-byte)      (mapc #'(lambda (midi-byte)                (write-byte midi-byte midi-file))            midi-byte-list)      midi-filename)))(defun construct-track-chunk-hdr-list (track-chunk-length)  (multiple-value-bind (big-l3 l4) (floor track-chunk-length 256)    (multiple-value-bind (big-l2 l3) (floor big-l3 256)      (multiple-value-bind (l1 l2) (floor big-l2 256)        (append '(77 84 114 107)                (list l1 l2 l3 l4))))))(defun construct-note-list (mid-list)  (let* ((note-list nil)         (last-onset-time nil))    (dolist (event mid-list note-list)      (setf note-list            (append note-list                    (compute-var-length-value (- (first event) (if last-onset-time                                                                 last-onset-time                                                                 0)))                    (list (if (= 1 (third event)) 144 128)                          (second event)                          (if (= 1 (third event)) 96 64))))      (setf last-onset-time (first event)))))(defun construct-note-list-with-errors (mid-list)  (let* ((note-list nil)         (last-onset-time nil))    (dolist (event mid-list note-list)      (setf note-list            (append note-list                    (compute-var-length-value (- (first event) (if last-onset-time                                                                 last-onset-time                                                                 0)))                    (list (if (= 1 (third event)) 144 128)                          (second event)                          (if (= 1 (third event))                            (if (member 'error event)                              120                              40) 40))))      (setf last-onset-time (first event)))))(defun construct-hdr-chunk-list (division)  (multiple-value-bind (d1 d2) (floor division 256)    (append '(77 84 104 100 0 0 0 6 0 0 0 1)            (list d1 d2))))(defun p-int-pm-int (pint)  (second pint))(defun p-int-pc-int (pint)  (first pint))(defun pi-inverse (pint)  (mapcar #'- pint))(defun invp (pint)  (list (- (p-int-pc-int pint))        (- (p-int-pm-int pint))))(defun p-int-gc-int (pint)  (- (p-int-pc-int pint)     (* 12         (floor (p-int-pm-int pint)             7))))(defun well-formed-number-string-p (s)  (let ((wf t))    (dotimes (i (length s) wf)      (if (not (or (<= (char-code #\0) (char-code (char s i)) (char-code #\9))                   (and (= i 0)                         (equalp (char s i) #\-))))	  (setf wf nil)))))(defun well-formed-interval-type-p (ty)  (or (member ty '("MA" "MI" "P") :test #'equalp)      (let ((wf t))        (dotimes (j (length ty) wf)          (if (not (equalp (char ty j) #\D))            (setf wf nil))))      (let ((wf t))        (dotimes (j (length ty) wf)          (if (not (equalp (char ty j) #\A))            (setf wf nil))))))(defun p-pn (p)  (let* ((m (p-m p))         (l (elt '("A" "B" "C" "D" "E" "F" "G") m))         (gc (p-gc p))         (cdash (elt '(0 2 3 5 7 8 10) m))         (e (- gc cdash))         (i "")         (i (cond ((< e 0) (dotimes (j (- e) i) (setf i (concatenate 'string i "f"))))                  ((> e 0) (dotimes (j e i) (setf i (concatenate 'string i "s"))))                  ((= e 0) "n")))         (om (p-om p))         (oasa (if (or (= m 0) (= m 1))                 om                 (+ 1 om)))         (o (format nil "~D" oasa)))    (concatenate 'string l i o)))(defun p-om (p)  (floor (p-pm p) 7))(defun p-gc (p)  (- (p-pc p)     (* 12 (p-om p))))(defun p-m (p)  (mod (p-pm p) 7))(defun compute-var-length-value (val &optional (var-length-value nil))  (cond ((and (zerop val)              var-length-value)         (append (mapcar #'(lambda (v)                             (+ 128 v))                         (butlast var-length-value))                 (last var-length-value)))        (t (multiple-value-bind (d1 d2)                                (floor val 128)             (compute-var-length-value d1 (cons d2 var-length-value))))));higher division means higher tempo(defun opnd2midi (division                  &optional                  (file-name (choose-file-dialog :button-string "OPND"))                  (output-directory (choose-directory-dialog :button-string "MIDI")))  (opd2midi division             (opnd2opd file-name nil)            file-name            output-directory))(defun opnd2midi-with-errors (division                              &optional                              (file-name (choose-file-dialog :button-string "OPND"))                              (output-directory (choose-directory-dialog :button-string "MIDI")))  (opd2midi-with-errors division                         (opnd2opd file-name nil)                        file-name                        output-directory))#|(defun multi-opnd2midi (division                        &optional                        (input-directory (choose-directory-dialog :button-string "INPUT"))                        (file-name-list (let* ((file-list (directory (make-pathname :directory (pathname-directory input-directory)                                                                                    :name :wild                                                                                    :type :wild)))                                               (shortened-file-list (mapcar #'pathname-name file-list))                                               (selected-files (select-item-from-list shortened-file-list                                                                                      :selection-type :disjoint))                                               (selected-files (remove-if #'null(mapcar #'(lambda (full-file-name)                                                                                            (if (member (pathname-name full-file-name)                                                                                                        selected-files                                                                                                        :test #'string=)                                                                                              full-file-name))                                                                                        file-list))))                                          selected-files                                          ))                        (output-directory (choose-directory-dialog :button-string "MIDI")))  (let* ((complete-opd-dataset (apply #'append (mapcar #'(lambda (file-name)                                                           (opnd2opd file-name nil))                                                       file-name-list))))    (opd2midi division             (opnd2opd file-name nil)            file-name            output-directory)))|#(defun batch-opnd2midi (division                        &optional                        (file-type "opnd-m")                        (input-directory (choose-directory-dialog :button-string "OPND"))                        (output-directory (choose-directory-dialog :button-string "MIDI")))  (let* ((opnd-file-list (directory (make-pathname :directory (pathname-directory input-directory)                                                   :name :wild                                                   :type file-type))))    (dolist (opnd-file opnd-file-list)      (opnd2midi division                 opnd-file                 output-directory))))(defun move-error-files ()  (let* ((dir (choose-directory-dialog))         (file-list (directory (make-pathname :directory (pathname-directory dir)                                              :name :wild                                              :type "mid")))         )    (mapcar #'(lambda (file-name)                (create-file (make-pathname :directory (append (pathname-directory file-name)                                                               (list (pathname-name file-name))))))            file-list)    (mapcar #'(lambda (file-name)                (copy-file file-name                           (make-pathname :directory (append (pathname-directory file-name)                                                             (list (pathname-name file-name)))                                          :name (pathname-name file-name)                                          :type (pathname-type file-name)))                (delete-file file-name)                (copy-file (make-pathname :directory (pathname-directory file-name)                                          :name (pathname-name file-name)                                          :type "opnd-m")                           (make-pathname :directory (append (pathname-directory file-name)                                                             (list (pathname-name file-name)))                                          :name (pathname-name file-name)                                          :type "opnd-m"))                (delete-file (make-pathname :directory (pathname-directory file-name)                                            :name (pathname-name file-name)                                            :type "opnd-m")))            file-list)))(defun opnd-files-equal-p (&optional                           (file1 (choose-file-dialog :button-string "FILE 1"))                           (file2 (choose-file-dialog :button-string "FILE 2")))  (FORMAT T "~%FILE 1: ~A~%FILE 2: ~A~%" FILE1 FILE2)  (equalp (sort (opnd2opd file1 nil) #'vector-less-than-p)          (sort (opnd2opd file2 nil) #'vector-less-than-p)))(defun remove-overlapped-notes (&optional (opnd-filename (choose-file-dialog :button-string "OPND"))                                          (print-removed-notes nil))  (let* ((opnd-as-input (sort-by-onset (with-open-file (opnd-filestream                                                        opnd-filename)                                         (read opnd-filestream))))         (opnd (remove-duplicates opnd-as-input                                  :test #'equalp                                  :key #'(lambda (dp) (list (first dp) (second dp)))))         (removed-notes (set-difference opnd-as-input opnd :test #'equalp))         (new-opnd-filename (pathname (concatenate 'string                                                (pathname-directory-to-string (pathname-directory opnd-filename))                                                (pathname-name opnd-filename)                                                 "m.opnd-m"))))    (with-open-file (new-opnd-filestream                       new-opnd-filename                       :direction :output                       :if-exists :rename-and-delete)        (pprint opnd new-opnd-filestream))    (format t "~%FILE: ~s~%" (pathname-name opnd-filename))    (format t "Number of notes removed: ~d~%" (list-length removed-notes))    (if print-removed-notes (progn (format t "Removed notes:~%")(pprint removed-notes)))    new-opnd-filename))(defun check-if-overlapped-notes-removed (&optional (opnd-m-file (choose-file-dialog)))  (let* ((opnd-m (with-open-file (opnd-m-stream                                  opnd-m-file                                  :direction :input)                   (read opnd-m-stream)))         (opnd-m (sort opnd-m                       #'(lambda (opnd1 opnd2)                           (or (< (first opnd1)                                  (first opnd2))                               (and (= (first opnd1)                                       (first opnd2))                                    (< (first (pn-p (second opnd1)))                                       (first (pn-p (second opnd2)))))))))         (number-of-notes-in-file (list-length opnd-m))         (number-of-notes-in-file-after-removal (list-length (remove-duplicates opnd-m                                                                                :test #'equalp                                                                                :key #'(lambda (dp) (list (first dp) (first (pn-p (second dp)))))))))    (and (= number-of-notes-in-file            number-of-notes-in-file-after-removal)         (do* ((i 0 (1+ i))               (result t))              ((or (null result)                   (= i (- (list-length opnd-m) 2)))               result)           (if (and (= (first (elt opnd-m i))                       (first (elt opnd-m (1+ i))))                    (= (first (pn-p (second (elt opnd-m i))))                       (first (pn-p (second (elt opnd-m (1+ i)))))))             (setf result nil))))))(defun find-nearest-pairs (target &optional                                   (file-prefix "")                                  (corpus-directory (choose-directory-dialog :button-string "CORPUS"))                                  (nfpl (note-file-pair-list file-prefix corpus-directory)))  (do* ((i 0 (1+ i))        (this-score nil)        (set-of-best-pairs nil)        (nearest-score nil))       ((= i (list-length nfpl))        (values nearest-score                set-of-best-pairs))    (do* ((j (1+ i) (1+ j)))         ((= j (list-length nfpl)))      (setf this-score (+ (first (elt nfpl i))                          (first (elt nfpl j))))      (if (or (null set-of-best-pairs)              (> (abs (- nearest-score target))                 (abs (- this-score target))))        (setf set-of-best-pairs              (list (list (elt nfpl i)                          (elt nfpl j)))              nearest-score              this-score)        (if (= (abs (- nearest-score target))               (abs (- this-score target)))          (setf set-of-best-pairs                (cons (list (elt nfpl i)                            (elt nfpl j))                      set-of-best-pairs)))))))#|;defined in ps-dphil-test.lisp(defun note-file-pair-list (&optional (file-prefix "")                                      (corpus-directory (choose-directory-dialog :button-string "CORPUS"))                                      )  (let* ((file-name-list (directory (make-pathname :directory (pathname-directory corpus-directory)                                                   :name (concatenate 'string file-prefix "*")                                                   :type "opnd-m")))         (number-of-notes-list (mapcar #'(lambda (file-name)                                           (with-open-file (file-stream                                                            file-name                                                            :direction :input)                                             (list-length (read file-stream))))                                       file-name-list))         (total-number-of-notes (apply #'+ number-of-notes-list))         (note-file-pair-list (mapcar #'list number-of-notes-list file-name-list)))    (values (sort note-file-pair-list #'< :key #'first)            total-number-of-notes)))|##|;defined in ps-dphil-test.lisp(defun sort-by-onset (opndv-dataset)  (sort opndv-dataset        #'(lambda (opndv-datapoint1 opndv-datapoint2)            (let* ((onset1 (first opndv-datapoint1))                   (onset2 (first opndv-datapoint2))                   (pitch1 (pn2p (second opndv-datapoint1)))                   (pitch2 (pn2p (second opndv-datapoint2)))                   (chromatic-pitch1 (first pitch1))                   (chromatic-pitch2 (first pitch2))                   (morphetic-pitch1 (second pitch1))                   (morphetic-pitch2 (second pitch2))                   (duration1 (third opndv-datapoint1))                   (duration2 (third opndv-datapoint2))                   (voice1 (fourth opndv-datapoint1))                   (voice2 (fourth opndv-datapoint2)))              (vector-less-than-p (list onset1                                         chromatic-pitch1                                        duration1                                        voice1                                        morphetic-pitch1)                                  (list onset2                                        chromatic-pitch2                                        duration2                                        voice2                                        morphetic-pitch2))))))|##|(setf actual-telema-list (sort (mapcar #'pathname-name (mapcar #'second (note-file-pair-list "telema"))) #'string<))(mapcar #'string= actual-telema-list correct-telema-list)(setf actual-telema-nfpl (note-file-pair-list "telema"))(remove-if #'null (mapcar #'(lambda (nfp)                              (let* ((nfp-entry-in-total-list (first (member nfp total-telema-nfpl                                                                             :test #'(lambda (x y)                                                                                       (string= (pathname-name (second x))                                                                                                (pathname-name (second y))))))))                                (unless (= (first nfp-entry-in-total-list)                                           (first nfp))                                  (list nfp nfp-entry-in-total-list))                                ))                          actual-telema-nfpl))(setf total-telema-nfpl      (note-file-pair-list "telema"))(setf correct-telema-list (sort (mapcar #'string-downcase '(telemabrusse1734_40102mtelemabrusse1734_40103mtelemabrusse1734_40202mtelemabrusse1734_40203mtelemabrusse1734_40302mtelemabrusse1734_40303mtelemabrusse1734_40402mtelemabrusse1734_40403mtelemabrusse1734_40503mtelemabrusse1734_40603mtelemabrusse1734_40704mtelemabrusse1734_40804mtelemabrusse1734_40904mtelemabrusse1734_41004mtelemabrusse1734_41104mtelemabrusse1734_41204mtelemamagdebgerman27mtelemamagdebgerman01bmtelemamagdebgerman04mtelemamagdebgerman05mtelemamagdebgerman09mtelemamagdebgerman13mtelemamagdebgerman19mtelemamagdebgerman22mtelemamagdebgerman26mtelemamagdebgerman30mtelemamagdebgerman34mtelemamagdeborpheu3076mtelemamagdeborpheu1012mtelemamagdeborpheu1021mtelemamagdeborpheu1025mtelemabrusse1734_41003mtelemabrusse1734_40903mtelemamagdeborpheu1051mtelemamagdeborpheu1083mtelemamagdeborpheu1092mtelemamagdeborpheu1103mtelemamagdeborpheu2015mtelemamagdeborpheu2031mtelemamagdeborpheu2062mtelemamagdeborpheu2081mtelemamagdeborpheu3013mtelemamagdeborpheu3034mtelemamagdeborpheu3052mtelemamagdeborpheu3074mtelemamagdeborpheu3082m)) #'string<))(setf disallowed-files (mapcar #'string-downcase                               (mapcar #'string '(telemabrusse1734_40102mtelemabrusse1734_40103mtelemabrusse1734_40202mtelemabrusse1734_40203mtelemabrusse1734_40302mtelemabrusse1734_40303mtelemabrusse1734_40402mtelemabrusse1734_40403mtelemabrusse1734_40503mtelemabrusse1734_40603mtelemabrusse1734_40704mtelemabrusse1734_40804mtelemabrusse1734_40904mtelemabrusse1734_41004mtelemabrusse1734_41104mtelemabrusse1734_41204mtelemamagdebgerman01dmtelemamagdebgerman04mtelemamagdebgerman05mtelemamagdebgerman09mtelemamagdebgerman13mtelemamagdebgerman19mtelemamagdebgerman22mtelemamagdebgerman26mtelemamagdebgerman30mtelemamagdebgerman34mtelemamagdebgerman39mtelemamagdeborpheu1012mtelemamagdeborpheu1021mtelemamagdeborpheu1025mtelemamagdeborpheu1042mtelemamagdeborpheu1051mtelemamagdeborpheu1083mtelemamagdeborpheu1092mtelemamagdeborpheu1103mtelemamagdeborpheu2015mtelemamagdeborpheu2031mtelemamagdeborpheu2062mtelemamagdeborpheu2081mtelemamagdeborpheu3013mtelemamagdeborpheu3034mtelemamagdeborpheu3052mtelemamagdeborpheu3074mtelemamagdeborpheu3082mtelemamagdebgerman33mtelemamagdeborpheu3076mtelemamagdebgerman27mtelemamagdebgerman01bm))))(pprint (setf nfpl      (remove-if #'(lambda (size-name-pair)                     (member (pathname-name (second size-name-pair))                             disallowed-files                             :test #'string=))                 '((20 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman32m.opnd-m") (23 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1093m.opnd-m") (24 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman13m.opnd-m") (24 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2015m.opnd-m") (32 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman17m.opnd-m") (35 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman26m.opnd-m") (36 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman05m.opnd-m") (36 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman36m.opnd-m") (37 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1045m.opnd-m") (42 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1084m.opnd-m") (44 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1041m.opnd-m") (45 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2065m.opnd-m") (49 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman07m.opnd-m") (49 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1052m.opnd-m") (56 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1023m.opnd-m") (62 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1091m.opnd-m") (65 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1043m.opnd-m") (68 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman30m.opnd-m") (73 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3083m.opnd-m") (75 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3042m.opnd-m") (77 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman19m.opnd-m") (77 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2052m.opnd-m") (78 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman21m.opnd-m") (81 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3073m.opnd-m") (92 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman03m.opnd-m") (92 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2091m.opnd-m") (93 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman34m.opnd-m") (95 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2017m.opnd-m") (97 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2081m.opnd-m") (98 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman40m.opnd-m") (99 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3031m.opnd-m") (106 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1025m.opnd-m") (110 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3082m.opnd-m") (112 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1031m.opnd-m") (115 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman09m.opnd-m") (118 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman11m.opnd-m") (120 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman23m.opnd-m") (138 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1061m.opnd-m") (139 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2013m.opnd-m") (143 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2021m.opnd-m") (146 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3081m.opnd-m") (150 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman28m.opnd-m") (151 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1014m.opnd-m") (165 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2016m.opnd-m") (167 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2014m.opnd-m") (167 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3075m.opnd-m") (172 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1101m.opnd-m") (181 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_41101m.opnd-m") (199 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_41203m.opnd-m") (214 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1105m.opnd-m") (218 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1012m.opnd-m") (223 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3076m.opnd-m") (227 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40103m.opnd-m") (228 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman39m.opnd-m") (243 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40401m.opnd-m") (249 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40203m.opnd-m") (256 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40403m.opnd-m") (256 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_41201m.opnd-m") (265 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40701m.opnd-m") (266 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1011m.opnd-m") (269 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40301m.opnd-m") (269 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40603m.opnd-m") (270 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3074m.opnd-m") (282 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40201m.opnd-m") (282 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_41003m.opnd-m") (283 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3013m.opnd-m") (288 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_41103m.opnd-m") (292 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40903m.opnd-m") (296 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3072m.opnd-m") (302 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3084m.opnd-m") (305 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1085m.opnd-m") (313 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40501m.opnd-m") (321 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman24m.opnd-m") (341 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman20bm.opnd-m") (344 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2064m.opnd-m") (350 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3043m.opnd-m") (366 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40901m.opnd-m") (385 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40803m.opnd-m") (386 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40101m.opnd-m") (386 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1022m.opnd-m") (388 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1103m.opnd-m") (433 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_41001m.opnd-m") (447 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2066m.opnd-m") (489 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40601m.opnd-m") (506 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3071m.opnd-m") (532 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_41002m.opnd-m") (573 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1013m.opnd-m") (574 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1042m.opnd-m") (579 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40503m.opnd-m") (580 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40801m.opnd-m") (585 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40303m.opnd-m") (589 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3034m.opnd-m") (593 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40602m.opnd-m") (642 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40704m.opnd-m") (649 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1083m.opnd-m") (653 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40404m.opnd-m") (657 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_41104m.opnd-m") (663 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_41202m.opnd-m") (669 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40904m.opnd-m") (669 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_41102m.opnd-m") (670 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2062m.opnd-m") (684 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2031m.opnd-m") (692 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40402m.opnd-m") (709 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40902m.opnd-m") (713 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3041m.opnd-m") (714 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40702m.opnd-m") (724 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1024m.opnd-m") (726 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40104m.opnd-m") (735 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman01cm.opnd-m") (758 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40604m.opnd-m") (766 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1032m.opnd-m") (787 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_41204m.opnd-m") (797 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3014m.opnd-m") (804 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman25m.opnd-m") (806 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40204m.opnd-m") (809 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40202m.opnd-m") (827 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40804m.opnd-m") (827 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1051m.opnd-m") (831 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3052m.opnd-m") (852 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40502m.opnd-m") (866 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3022m.opnd-m") (867 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1081m.opnd-m") (884 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2082m.opnd-m") (898 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_41004m.opnd-m") (900 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman29m.opnd-m") (901 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman22m.opnd-m") (901 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1094m.opnd-m") (904 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40302m.opnd-m") (919 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40802m.opnd-m") (927 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1044m.opnd-m") (980 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1092m.opnd-m") (1020 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40504m.opnd-m") (1037 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1021m.opnd-m") (1048 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman27m.opnd-m") (1070 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40102m.opnd-m") (1075 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu1015m.opnd-m") (1082 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman16m.opnd-m") (1103 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman20am.opnd-m") (1104 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemabrusse1734_40304m.opnd-m") (1105 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman37m.opnd-m") (1128 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman41m.opnd-m") (1198 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman12m.opnd-m") (1245 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2051m.opnd-m") (1256 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu3012m.opnd-m") (1300 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman10m.opnd-m") (1360 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman04m.opnd-m") (1443 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman01am.opnd-m") (1443 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman35m.opnd-m") (1485 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdeborpheu2042m.opnd-m") (1501 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman31m.opnd-m") (1524 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman18m.opnd-m") (2047 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman06m.opnd-m") (2052 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman01bm.opnd-m") (2090 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman02m.opnd-m") (2205 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman33m.opnd-m") (3108 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman01dm.opnd-m") (3417 #P"hd:Users:dave:Documents:Musedata:20040205opnd-m:opnd-m:telemamagdebgerman08m.opnd-m")))))|#(defstruct fl  index  type  prefix  filename)(defun abbreviate-filename (name)  (if (< (length name) 22)    name    (concatenate 'string                  (subseq name 0 10)                 "_"                 (subseq name (- (length name) 10)))))(defun split-up-mef-file-into-movements (&optional (mef-file (choose-file-dialog :button-string "MEF FILE"))                                                   (output-directory (choose-directory-dialog :button-string "OUTPUT DIR")))  (let* ((mef-string-list (with-open-file (mef-stream                                           mef-file                                           :direction :input)                            (do* ((l nil)                                  (mef-item (read-line mef-stream nil nil)                                            (read-line mef-stream nil nil)))                                 ((null mef-item)                                  (reverse l))                              (setf l (cons mef-item l)))))         (length-of-mef-string-list (list-length mef-string-list))         (fl-list (do* ((i 0 (1+ i))                        (fll nil)                        (start-pos nil nil)                        (current-filename-prefix))                       ((= i length-of-mef-string-list)                        (reverse fll))                    (cond ((and (> (length (elt mef-string-list i)) 3)                                (char= (char (elt mef-string-list i) 0)                                       #\F))                           (setf current-filename-prefix (substitute #\_ #\Space								     (subseq (elt mef-string-list i)									     (1+ (setf start-pos (position #\' (elt mef-string-list i))))									     (position #\' (elt mef-string-list i) :start (1+ start-pos)))))                           (setf fll                                 (cons (make-fl :index i						:type 'f						:prefix current-filename-prefix						:filename (abbreviate-filename current-filename-prefix))                                       fll)))                          ((and (> (length (elt mef-string-list i)) 3)                                (char= (char (elt mef-string-list i) 0)                                       #\L))                           (setf fll                                 (cons (make-fl :index i						:type 'l						:prefix current-filename-prefix						:filename (abbreviate-filename                                                           (concatenate 'string 								        current-filename-prefix								        "_"								        (substitute #\_ #\Space 										    (subseq (elt mef-string-list i)											    (1+ (setf start-pos (position #\' (elt mef-string-list i))))											    (position #\' (elt mef-string-list i) :start (1+ start-pos))))))						)                                       fll)))                          (t nil))))         (fl-list (do* ((i 0 (1+ i)))                       ((= i (1- (list-length fl-list)))                        (remove-if #'null fl-list))                    (if (and (eq (fl-type (elt fl-list i)) 'f)                             (eq (fl-type (elt fl-list (1+ i))) 'l))			(setf (elt fl-list i) nil))))         )    (dotimes (i (list-length fl-list))      (let* ((fl (elt fl-list i))	     (next-fl-index (if (< (1+ i) (list-length fl-list))				(fl-index (elt fl-list (1+ i)))				length-of-mef-string-list))	     (new-mef-file-name (make-pathname :directory (pathname-directory output-directory)					       :name (fl-filename fl)					       :type "mef")))	(with-open-file (new-mef-file-stream			 new-mef-file-name			 :direction :output)	  (dolist (mef-string (subseq mef-string-list 				      (fl-index fl) 				      next-fl-index))	    (if (char= (char mef-string 0) #\N)		(write-line mef-string new-mef-file-stream))))))))